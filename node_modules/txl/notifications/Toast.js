'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _desc, _value, _class2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _Base = require('../base/Base');

var _LoadingIndicator = require('../progress-indicators/LoadingIndicator');

var _LoadingIndicator2 = _interopRequireDefault(_LoadingIndicator);

var _helpers = require('../styles/helpers');

var _theme = require('../styles/theme');

var _Toast = require('./Toast.style');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var TxlToast = (0, _radium2.default)(_class = (_class2 = function (_React$Component) {
  (0, _inherits3.default)(TxlToast, _React$Component);

  function TxlToast() {
    var _ref;

    (0, _classCallCheck3.default)(this, TxlToast);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = TxlToast.__proto__ || (0, _getPrototypeOf2.default)(TxlToast)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      expired: false,
      hovered: false,
      loading: false,
      undoing: false
    };

    _this._timeoutId = null;
    _this._remainingLife = 0;
    _this._startTime = null;
    _this._expireFromUndoCallback = (0, _once2.default)(function () {
      _this.setState({
        undoing: false
      }, _this._expire);
    });
    return _this;
  }

  (0, _createClass3.default)(TxlToast, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._startTimer();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._endTimer();
      this._remainingLife = 0;
    }
  }, {
    key: '_handleUndo',
    value: function _handleUndo() {
      // Once the undo button is pressed, the wrapping component is required
      // to handle dismissing the notification, since we don't want it to automatically
      // expire the notification before the undo action is complete.

      this.setState({
        loading: true,
        undoing: true
      });

      this.props.onUndo({
        done: this._expireFromUndoCallback,
        error: this._handleUndoError
      });
    }
  }, {
    key: '_handleUndoError',
    value: function _handleUndoError(message) {
      this.setState({
        errorMessage: message,
        loading: false
      });
    }
  }, {
    key: '_handleMouseEnter',
    value: function _handleMouseEnter() {
      this.setState({ hovered: true });
    }
  }, {
    key: '_handleMouseLeave',
    value: function _handleMouseLeave() {
      this.setState({ hovered: false });
    }
  }, {
    key: '_pauseTimer',
    value: function _pauseTimer() {
      this._endTimer();
      var elapsed = Date.now() - this._startTime;
      this._remainingLife = (this._remainingLife || this.props.lifetime) - elapsed;
    }
  }, {
    key: '_unPauseTimer',
    value: function _unPauseTimer() {
      if (this._remainingLife <= 0) {
        return;
      }
      this._startTimer(this._remainingLife);
    }
  }, {
    key: '_startTimer',
    value: function _startTimer(remainingLife) {
      this._startTime = Date.now();

      if (this.props.lifetime) {
        this._timeoutId = setTimeout(this._expire, remainingLife || this.props.lifetime);
      }
    }
  }, {
    key: '_endTimer',
    value: function _endTimer() {
      clearTimeout(this._timeoutId);
    }
  }, {
    key: '_expire',
    value: function _expire() {
      if (this.state.undoing) {
        return;
      }
      this.setState({ expired: true });
      this.props.onExpire({});
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.state.expired) {
        return null;
      }

      var undoContainer = void 0;
      var mouseEvents = void 0;

      if (this.props.lifetime) {
        mouseEvents = {
          onMouseEnter: this._pauseTimer,
          onMouseLeave: this._unPauseTimer
        };
      }

      if (this.props.onUndo) {
        var undoContent = void 0;

        if (this.state.loading) {
          undoContent = _react2.default.createElement(_LoadingIndicator2.default, { size: 'small', color: _theme.COLOR_NEUTRAL['500c'] });
        } else {
          // @TODO: Abstract these into a pattern that will allow us to use the
          // button component. https://jira.corp.tune.com/browse/TXLENG-4
          var undoButtonColor = this.state.hovered ? _Toast.UNDO_BUTTON_HOVERED : undefined;
          var undoButtonStyle = (0, _helpers.combineStyles)(_Toast.UNDO_BUTTON_BASE, undoButtonColor);

          undoContent = _react2.default.createElement(
            'a',
            {
              'data-test-toast-undo-button': true,
              onClick: this._handleUndo,
              onMouseEnter: this._handleMouseEnter,
              onMouseLeave: this._handleMouseLeave,
              style: undoButtonStyle
            },
            'UNDO'
          );
        }

        undoContainer = _react2.default.createElement(
          'div',
          { style: _Toast.UNDO_CONTAINER_STYLES },
          undoContent
        );
      }

      var toastContent = this.state.errorMessage || this.props.children;

      var toastStyles = (0, _helpers.combineStyles)(this.props._style, _Toast.TOAST_STYLES);

      return _react2.default.createElement(
        'div',
        (0, _extends3.default)({}, mouseEvents, {
          'data-component': 'TxlToast',
          style: toastStyles
        }),
        _react2.default.createElement(
          'div',
          {
            style: _Toast.TOAST_MESSAGE_STYLES,
            'data-test-toast-content': true
          },
          toastContent
        ),
        undoContainer
      );
    }
  }]);
  return TxlToast;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class2.prototype, '_handleUndo', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleUndo'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handleUndoError', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleUndoError'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handleMouseEnter', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleMouseEnter'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handleMouseLeave', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleMouseLeave'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_pauseTimer', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_pauseTimer'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_unPauseTimer', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_unPauseTimer'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_startTimer', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_startTimer'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_endTimer', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_endTimer'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_expire', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_expire'), _class2.prototype)), _class2)) || _class;

exports.default = TxlToast;


TxlToast.propTypes = {
  _style: _react.PropTypes.object,
  children: _react.PropTypes.node.isRequired,
  lifetime: _react.PropTypes.number,
  onExpire: _react.PropTypes.func,
  onUndo: _react.PropTypes.func
};

TxlToast.defaultProps = {
  onExpire: _Base.NOOP
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(TxlToast, 'TxlToast', 'src/notifications/Toast.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub3RpZmljYXRpb25zL1RvYXN0LmpzeCJdLCJuYW1lcyI6WyJUeGxUb2FzdCIsImFyZ3MiLCJzdGF0ZSIsImV4cGlyZWQiLCJob3ZlcmVkIiwibG9hZGluZyIsInVuZG9pbmciLCJfdGltZW91dElkIiwiX3JlbWFpbmluZ0xpZmUiLCJfc3RhcnRUaW1lIiwiX2V4cGlyZUZyb21VbmRvQ2FsbGJhY2siLCJzZXRTdGF0ZSIsIl9leHBpcmUiLCJfc3RhcnRUaW1lciIsIl9lbmRUaW1lciIsInByb3BzIiwib25VbmRvIiwiZG9uZSIsImVycm9yIiwiX2hhbmRsZVVuZG9FcnJvciIsIm1lc3NhZ2UiLCJlcnJvck1lc3NhZ2UiLCJlbGFwc2VkIiwiRGF0ZSIsIm5vdyIsImxpZmV0aW1lIiwicmVtYWluaW5nTGlmZSIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJvbkV4cGlyZSIsInVuZG9Db250YWluZXIiLCJtb3VzZUV2ZW50cyIsIm9uTW91c2VFbnRlciIsIl9wYXVzZVRpbWVyIiwib25Nb3VzZUxlYXZlIiwiX3VuUGF1c2VUaW1lciIsInVuZG9Db250ZW50IiwidW5kb0J1dHRvbkNvbG9yIiwidW5kZWZpbmVkIiwidW5kb0J1dHRvblN0eWxlIiwiX2hhbmRsZVVuZG8iLCJfaGFuZGxlTW91c2VFbnRlciIsIl9oYW5kbGVNb3VzZUxlYXZlIiwidG9hc3RDb250ZW50IiwiY2hpbGRyZW4iLCJ0b2FzdFN0eWxlcyIsIl9zdHlsZSIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIm9iamVjdCIsIm5vZGUiLCJpc1JlcXVpcmVkIiwibnVtYmVyIiwiZnVuYyIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQVNxQkEs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ZmlsZSI6IlRvYXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSYWRpdW0gZnJvbSAncmFkaXVtJztcbmltcG9ydCBvbmNlIGZyb20gJ2xvZGFzaC9vbmNlJztcblxuaW1wb3J0IHsgYXV0b2JpbmQsIE5PT1AgfSBmcm9tICcuLi9iYXNlL0Jhc2UnO1xuaW1wb3J0IExvYWRpbmdJbmRpY2F0b3IgZnJvbSAnLi4vcHJvZ3Jlc3MtaW5kaWNhdG9ycy9Mb2FkaW5nSW5kaWNhdG9yJztcbmltcG9ydCB7IGNvbWJpbmVTdHlsZXMgfSBmcm9tICcuLi9zdHlsZXMvaGVscGVycyc7XG5pbXBvcnQgeyBDT0xPUl9ORVVUUkFMIH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lJztcbmltcG9ydCB7XG4gIFRPQVNUX01FU1NBR0VfU1RZTEVTLFxuICBUT0FTVF9TVFlMRVMsXG4gIFVORE9fQlVUVE9OX0JBU0UsXG4gIFVORE9fQlVUVE9OX0hPVkVSRUQsXG4gIFVORE9fQ09OVEFJTkVSX1NUWUxFUyxcbn0gZnJvbSAnLi9Ub2FzdC5zdHlsZSc7XG5cbkBSYWRpdW1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR4bFRvYXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGV4cGlyZWQ6IGZhbHNlLFxuICAgICAgaG92ZXJlZDogZmFsc2UsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIHVuZG9pbmc6IGZhbHNlLFxuICAgIH07XG5cbiAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMuX3JlbWFpbmluZ0xpZmUgPSAwO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5fZXhwaXJlRnJvbVVuZG9DYWxsYmFjayA9IG9uY2UoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHVuZG9pbmc6IGZhbHNlLFxuICAgICAgfSwgdGhpcy5fZXhwaXJlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX3N0YXJ0VGltZXIoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2VuZFRpbWVyKCk7XG4gICAgdGhpcy5fcmVtYWluaW5nTGlmZSA9IDA7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2hhbmRsZVVuZG8oKSB7XG4gICAgLy8gT25jZSB0aGUgdW5kbyBidXR0b24gaXMgcHJlc3NlZCwgdGhlIHdyYXBwaW5nIGNvbXBvbmVudCBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGhhbmRsZSBkaXNtaXNzaW5nIHRoZSBub3RpZmljYXRpb24sIHNpbmNlIHdlIGRvbid0IHdhbnQgaXQgdG8gYXV0b21hdGljYWxseVxuICAgIC8vIGV4cGlyZSB0aGUgbm90aWZpY2F0aW9uIGJlZm9yZSB0aGUgdW5kbyBhY3Rpb24gaXMgY29tcGxldGUuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICB1bmRvaW5nOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wcm9wcy5vblVuZG8oe1xuICAgICAgZG9uZTogdGhpcy5fZXhwaXJlRnJvbVVuZG9DYWxsYmFjayxcbiAgICAgIGVycm9yOiB0aGlzLl9oYW5kbGVVbmRvRXJyb3IsXG4gICAgfSk7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2hhbmRsZVVuZG9FcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBlcnJvck1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfaGFuZGxlTW91c2VFbnRlcigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZDogdHJ1ZSB9KTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfaGFuZGxlTW91c2VMZWF2ZSgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZDogZmFsc2UgfSk7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX3BhdXNlVGltZXIoKSB7XG4gICAgdGhpcy5fZW5kVGltZXIoKTtcbiAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICB0aGlzLl9yZW1haW5pbmdMaWZlID0gKHRoaXMuX3JlbWFpbmluZ0xpZmUgfHwgdGhpcy5wcm9wcy5saWZldGltZSkgLSBlbGFwc2VkO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF91blBhdXNlVGltZXIoKSB7XG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZ0xpZmUgPD0gMCkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9zdGFydFRpbWVyKHRoaXMuX3JlbWFpbmluZ0xpZmUpO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9zdGFydFRpbWVyKHJlbWFpbmluZ0xpZmUpIHtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMubGlmZXRpbWUpIHtcbiAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fZXhwaXJlLCByZW1haW5pbmdMaWZlIHx8IHRoaXMucHJvcHMubGlmZXRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfZW5kVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2V4cGlyZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS51bmRvaW5nKSB7IHJldHVybjsgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBleHBpcmVkOiB0cnVlIH0pO1xuICAgIHRoaXMucHJvcHMub25FeHBpcmUoe30pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmV4cGlyZWQpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGxldCB1bmRvQ29udGFpbmVyO1xuICAgIGxldCBtb3VzZUV2ZW50cztcblxuICAgIGlmICh0aGlzLnByb3BzLmxpZmV0aW1lKSB7XG4gICAgICBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLl9wYXVzZVRpbWVyLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuX3VuUGF1c2VUaW1lcixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25VbmRvKSB7XG4gICAgICBsZXQgdW5kb0NvbnRlbnQ7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmxvYWRpbmcpIHtcbiAgICAgICAgdW5kb0NvbnRlbnQgPSAoXG4gICAgICAgICAgPExvYWRpbmdJbmRpY2F0b3Igc2l6ZT1cInNtYWxsXCIgY29sb3I9e0NPTE9SX05FVVRSQUxbJzUwMGMnXX0gLz5cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEBUT0RPOiBBYnN0cmFjdCB0aGVzZSBpbnRvIGEgcGF0dGVybiB0aGF0IHdpbGwgYWxsb3cgdXMgdG8gdXNlIHRoZVxuICAgICAgICAvLyBidXR0b24gY29tcG9uZW50LiBodHRwczovL2ppcmEuY29ycC50dW5lLmNvbS9icm93c2UvVFhMRU5HLTRcbiAgICAgICAgY29uc3QgdW5kb0J1dHRvbkNvbG9yID0gdGhpcy5zdGF0ZS5ob3ZlcmVkID8gVU5ET19CVVRUT05fSE9WRVJFRCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdW5kb0J1dHRvblN0eWxlID0gY29tYmluZVN0eWxlcyhcbiAgICAgICAgICBVTkRPX0JVVFRPTl9CQVNFLFxuICAgICAgICAgIHVuZG9CdXR0b25Db2xvclxuICAgICAgICApO1xuXG4gICAgICAgIHVuZG9Db250ZW50ID0gKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBkYXRhLXRlc3QtdG9hc3QtdW5kby1idXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuX2hhbmRsZVVuZG99XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuX2hhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuX2hhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgICAgICBzdHlsZT17dW5kb0J1dHRvblN0eWxlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFVORE9cbiAgICAgICAgICA8L2E+XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHVuZG9Db250YWluZXIgPSAoXG4gICAgICAgIDxkaXYgc3R5bGU9e1VORE9fQ09OVEFJTkVSX1NUWUxFU30+XG4gICAgICAgICAge3VuZG9Db250ZW50fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9hc3RDb250ZW50ID0gdGhpcy5zdGF0ZS5lcnJvck1lc3NhZ2UgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIGNvbnN0IHRvYXN0U3R5bGVzID0gY29tYmluZVN0eWxlcyhcbiAgICAgIHRoaXMucHJvcHMuX3N0eWxlLFxuICAgICAgVE9BU1RfU1RZTEVTXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHsuLi5tb3VzZUV2ZW50c31cbiAgICAgICAgZGF0YS1jb21wb25lbnQ9XCJUeGxUb2FzdFwiXG4gICAgICAgIHN0eWxlPXt0b2FzdFN0eWxlc31cbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIHN0eWxlPXtUT0FTVF9NRVNTQUdFX1NUWUxFU31cbiAgICAgICAgICBkYXRhLXRlc3QtdG9hc3QtY29udGVudFxuICAgICAgICA+XG4gICAgICAgICAge3RvYXN0Q29udGVudH1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHt1bmRvQ29udGFpbmVyfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5UeGxUb2FzdC5wcm9wVHlwZXMgPSB7XG4gIF9zdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gIGxpZmV0aW1lOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvbkV4cGlyZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVW5kbzogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5UeGxUb2FzdC5kZWZhdWx0UHJvcHMgPSB7XG4gIG9uRXhwaXJlOiBOT09QLFxufTtcbiJdfQ==