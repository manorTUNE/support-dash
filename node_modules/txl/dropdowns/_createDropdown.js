'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = createDropDown;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Base = require('../base/Base');

var _ReactUtils = require('../ReactUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var POPOVER_ATTR = 'data-test-tethered-popover';

/**
 * Check to see if element is in item list dropdown. We need to check this so click handler doesn't
 * close parent dropdown when a child dropdown menu is clicked.
 *
 * @param {HTMLElement} el
 * @returns {boolean}
 */
function isElementInDropdown(el) {
  var parentEl = el;
  while (parentEl) {
    if (parentEl.hasAttribute(POPOVER_ATTR)) {
      return true;
    }
    parentEl = parentEl.parentElement;
  }
  return false;
}

/**
 * createDropdown creates a high order component which handles
 * dropdown states changes. The main objective of this decorator
 * is to support flexible way to handle dropdown state using any flux
 * implementation
 *
 * Note 1: It can be used as a decorator
 *
 * @param  {ReactClass} Component   Component to be wrapped by Dropdown
 * @return {ReactClass}            New ReactClass that is wrapped by Dropdown
 */
function createDropDown(Component) {
  var _desc, _value, _class;

  /**
   * Dropdown is higher order components that managers state for a dropdown for
   * the given Component
   */
  var TxlDropdown = (_class = function (_React$Component) {
    (0, _inherits3.default)(TxlDropdown, _React$Component);

    function TxlDropdown() {
      var _ref;

      (0, _classCallCheck3.default)(this, TxlDropdown);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = TxlDropdown.__proto__ || (0, _getPrototypeOf2.default)(TxlDropdown)).call.apply(_ref, [this].concat(args)));

      _this.state = { open: false };
      return _this;
    }

    (0, _createClass3.default)(TxlDropdown, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.props.opened === undefined) {
          window.addEventListener('click', this._handleClick);
          window.addEventListener('click', this._handleClickCapture, true);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.props.opened === undefined) {
          window.removeEventListener('click', this._handleClick);
          window.removeEventListener('click', this._handleClickCapture, true);
        }
      }
    }, {
      key: '_handleClick',
      value: function _handleClick() {
        if (this.state.pendingClose) {
          this.setState({
            open: false,
            pendingClose: undefined
          });
        }
      }
    }, {
      key: '_handleClickCapture',
      value: function _handleClickCapture(e) {
        /**
         * This was implemented to assert that a click happened inside a dropdown even if the dropdown
         * container is appended to the <body> tag in which case the component doesn't actually
         * 'contain' the click target.
         *
         * We need to use 'capture' phase here because the dropdown may be removed from the
         * DOM by the time 'bubble' event handling fires which would falsely lead us to believe that
         * the click happened outside of the dropdown.  Things like clicking a dropdown
         * within a dropdown would close *all* dropdowns when that wasn't the expected behavior.
         *
         * @TODO This should probably be replaced with a more elegant
         * solution that doesn't involve DOM traversal
         * https://jira.corp.tune.com/browse/TXLENG-122
         */
        if (!(0, _ReactUtils.findDOMNode)(this).contains(e.target) && !isElementInDropdown(e.target) && this.state.open) {
          this.setState({ pendingClose: true });
        }
      }
    }, {
      key: '_updateDropdown',
      value: function _updateDropdown(_ref2) {
        var open = _ref2.open;

        this.setState({ open: open });
      }
    }, {
      key: 'render',
      value: function render() {
        // props will override any state variables
        // This way any dropdown component with props.open will be a
        // controlled component.
        return _react2.default.createElement(Component
        // provide hook for grabbing internal component in tests
        , (0, _extends3.default)({ ref: 'unwrappedDropdownComponent',
          updateDropdown: this._updateDropdown
        }, this.state, this.props));
      }
    }]);
    return TxlDropdown;
  }(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, '_handleClick', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleClick'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_handleClickCapture', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_handleClickCapture'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_updateDropdown', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_updateDropdown'), _class.prototype)), _class);

  // make sure the proptypes are passed so can be inherited by other components

  TxlDropdown.propTypes = Component.propTypes;
  TxlDropdown.displayName = 'TxlDropdown(' + (Component.displayName || Component.name) + ')';

  return TxlDropdown;
}
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(POPOVER_ATTR, 'POPOVER_ATTR', 'src/dropdowns/_createDropdown.jsx');

  __REACT_HOT_LOADER__.register(isElementInDropdown, 'isElementInDropdown', 'src/dropdowns/_createDropdown.jsx');

  __REACT_HOT_LOADER__.register(createDropDown, 'createDropDown', 'src/dropdowns/_createDropdown.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kcm9wZG93bnMvX2NyZWF0ZURyb3Bkb3duLmpzeCJdLCJuYW1lcyI6WyJjcmVhdGVEcm9wRG93biIsIlBPUE9WRVJfQVRUUiIsImlzRWxlbWVudEluRHJvcGRvd24iLCJlbCIsInBhcmVudEVsIiwiaGFzQXR0cmlidXRlIiwicGFyZW50RWxlbWVudCIsIkNvbXBvbmVudCIsIlR4bERyb3Bkb3duIiwiYXJncyIsInN0YXRlIiwib3BlbiIsInByb3BzIiwib3BlbmVkIiwidW5kZWZpbmVkIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9oYW5kbGVDbGljayIsIl9oYW5kbGVDbGlja0NhcHR1cmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGVuZGluZ0Nsb3NlIiwic2V0U3RhdGUiLCJlIiwiY29udGFpbnMiLCJ0YXJnZXQiLCJfdXBkYXRlRHJvcGRvd24iLCJwcm9wVHlwZXMiLCJkaXNwbGF5TmFtZSIsIm5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBa0N3QkEsYzs7QUFsQ3hCOzs7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1DLGVBQWUsNEJBQXJCOztBQUVBOzs7Ozs7O0FBT0EsU0FBU0MsbUJBQVQsQ0FBNkJDLEVBQTdCLEVBQWlDO0FBQy9CLE1BQUlDLFdBQVdELEVBQWY7QUFDQSxTQUFPQyxRQUFQLEVBQWlCO0FBQ2YsUUFBSUEsU0FBU0MsWUFBVCxDQUFzQkosWUFBdEIsQ0FBSixFQUF5QztBQUFFLGFBQU8sSUFBUDtBQUFjO0FBQ3pERyxlQUFXQSxTQUFTRSxhQUFwQjtBQUNEO0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV2UsU0FBU04sY0FBVCxDQUF3Qk8sU0FBeEIsRUFBbUM7QUFBQTs7QUFDaEQ7Ozs7QUFEZ0QsTUFLMUNDLFdBTDBDO0FBQUE7O0FBTTlDLDJCQUFxQjtBQUFBOztBQUFBOztBQUFBLHdDQUFOQyxJQUFNO0FBQU5BLFlBQU07QUFBQTs7QUFBQSw2S0FDVkEsSUFEVTs7QUFFbkIsWUFBS0MsS0FBTCxHQUFhLEVBQUVDLE1BQU0sS0FBUixFQUFiO0FBRm1CO0FBR3BCOztBQVQ2QztBQUFBO0FBQUEsMENBVzFCO0FBQ2xCLFlBQUksS0FBS0MsS0FBTCxDQUFXQyxNQUFYLEtBQXNCQyxTQUExQixFQUFxQztBQUNuQ0MsaUJBQU9DLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLEtBQUtDLFlBQXRDO0FBQ0FGLGlCQUFPQyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxLQUFLRSxtQkFBdEMsRUFBMkQsSUFBM0Q7QUFDRDtBQUNGO0FBaEI2QztBQUFBO0FBQUEsNkNBa0J2QjtBQUNyQixZQUFJLEtBQUtOLEtBQUwsQ0FBV0MsTUFBWCxLQUFzQkMsU0FBMUIsRUFBcUM7QUFDbkNDLGlCQUFPSSxtQkFBUCxDQUEyQixPQUEzQixFQUFvQyxLQUFLRixZQUF6QztBQUNBRixpQkFBT0ksbUJBQVAsQ0FBMkIsT0FBM0IsRUFBb0MsS0FBS0QsbUJBQXpDLEVBQThELElBQTlEO0FBQ0Q7QUFDRjtBQXZCNkM7QUFBQTtBQUFBLHFDQTBCL0I7QUFDYixZQUFJLEtBQUtSLEtBQUwsQ0FBV1UsWUFBZixFQUE2QjtBQUMzQixlQUFLQyxRQUFMLENBQWM7QUFDWlYsa0JBQU0sS0FETTtBQUVaUywwQkFBY047QUFGRixXQUFkO0FBSUQ7QUFDRjtBQWpDNkM7QUFBQTtBQUFBLDBDQW9DMUJRLENBcEMwQixFQW9DdkI7QUFDckI7Ozs7Ozs7Ozs7Ozs7O0FBY0EsWUFBSSxDQUFDLDZCQUFZLElBQVosRUFBa0JDLFFBQWxCLENBQTJCRCxFQUFFRSxNQUE3QixDQUFELElBQ0MsQ0FBQ3RCLG9CQUFvQm9CLEVBQUVFLE1BQXRCLENBREYsSUFFQyxLQUFLZCxLQUFMLENBQVdDLElBRmhCLEVBRXNCO0FBQ3BCLGVBQUtVLFFBQUwsQ0FBYyxFQUFFRCxjQUFjLElBQWhCLEVBQWQ7QUFDRDtBQUNGO0FBeEQ2QztBQUFBO0FBQUEsNkNBMkRwQjtBQUFBLFlBQVJULElBQVEsU0FBUkEsSUFBUTs7QUFDeEIsYUFBS1UsUUFBTCxDQUFjLEVBQUVWLFVBQUYsRUFBZDtBQUNEO0FBN0Q2QztBQUFBO0FBQUEsK0JBK0RyQztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQ0UsOEJBQUM7QUFDQztBQURGLG1DQUVFLEtBQUksNEJBRk47QUFHRSwwQkFBZ0IsS0FBS2M7QUFIdkIsV0FJTSxLQUFLZixLQUpYLEVBS00sS0FBS0UsS0FMWCxFQURGO0FBU0Q7QUE1RTZDO0FBQUE7QUFBQSxJQUt0QixnQkFBTUwsU0FMZ0I7O0FBK0VoRDs7QUFDQUMsY0FBWWtCLFNBQVosR0FBd0JuQixVQUFVbUIsU0FBbEM7QUFDQWxCLGNBQVltQixXQUFaLHFCQUF5Q3BCLFVBQVVvQixXQUFWLElBQXlCcEIsVUFBVXFCLElBQTVFOztBQUVBLFNBQU9wQixXQUFQO0FBQ0Q7Ozs7Ozs7O2dDQWpIS1AsWTs7Z0NBU0dDLG1COztnQ0FvQmVGLGMiLCJmaWxlIjoiX2NyZWF0ZURyb3Bkb3duLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgYXV0b2JpbmQgfSBmcm9tICcuLi9iYXNlL0Jhc2UnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICcuLi9SZWFjdFV0aWxzJztcblxuY29uc3QgUE9QT1ZFUl9BVFRSID0gJ2RhdGEtdGVzdC10ZXRoZXJlZC1wb3BvdmVyJztcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgZWxlbWVudCBpcyBpbiBpdGVtIGxpc3QgZHJvcGRvd24uIFdlIG5lZWQgdG8gY2hlY2sgdGhpcyBzbyBjbGljayBoYW5kbGVyIGRvZXNuJ3RcbiAqIGNsb3NlIHBhcmVudCBkcm9wZG93biB3aGVuIGEgY2hpbGQgZHJvcGRvd24gbWVudSBpcyBjbGlja2VkLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50SW5Ecm9wZG93bihlbCkge1xuICBsZXQgcGFyZW50RWwgPSBlbDtcbiAgd2hpbGUgKHBhcmVudEVsKSB7XG4gICAgaWYgKHBhcmVudEVsLmhhc0F0dHJpYnV0ZShQT1BPVkVSX0FUVFIpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcGFyZW50RWwgPSBwYXJlbnRFbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBjcmVhdGVEcm9wZG93biBjcmVhdGVzIGEgaGlnaCBvcmRlciBjb21wb25lbnQgd2hpY2ggaGFuZGxlc1xuICogZHJvcGRvd24gc3RhdGVzIGNoYW5nZXMuIFRoZSBtYWluIG9iamVjdGl2ZSBvZiB0aGlzIGRlY29yYXRvclxuICogaXMgdG8gc3VwcG9ydCBmbGV4aWJsZSB3YXkgdG8gaGFuZGxlIGRyb3Bkb3duIHN0YXRlIHVzaW5nIGFueSBmbHV4XG4gKiBpbXBsZW1lbnRhdGlvblxuICpcbiAqIE5vdGUgMTogSXQgY2FuIGJlIHVzZWQgYXMgYSBkZWNvcmF0b3JcbiAqXG4gKiBAcGFyYW0gIHtSZWFjdENsYXNzfSBDb21wb25lbnQgICBDb21wb25lbnQgdG8gYmUgd3JhcHBlZCBieSBEcm9wZG93blxuICogQHJldHVybiB7UmVhY3RDbGFzc30gICAgICAgICAgICBOZXcgUmVhY3RDbGFzcyB0aGF0IGlzIHdyYXBwZWQgYnkgRHJvcGRvd25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRHJvcERvd24oQ29tcG9uZW50KSB7XG4gIC8qKlxuICAgKiBEcm9wZG93biBpcyBoaWdoZXIgb3JkZXIgY29tcG9uZW50cyB0aGF0IG1hbmFnZXJzIHN0YXRlIGZvciBhIGRyb3Bkb3duIGZvclxuICAgKiB0aGUgZ2l2ZW4gQ29tcG9uZW50XG4gICAqL1xuICBjbGFzcyBUeGxEcm9wZG93biBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICB0aGlzLnN0YXRlID0geyBvcGVuOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub3BlbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2spO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbGlja0NhcHR1cmUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub3BlbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2spO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVDbGlja0NhcHR1cmUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEBhdXRvYmluZFxuICAgIF9oYW5kbGVDbGljaygpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBlbmRpbmdDbG9zZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICAgICAgICBwZW5kaW5nQ2xvc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGF1dG9iaW5kXG4gICAgX2hhbmRsZUNsaWNrQ2FwdHVyZShlKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgd2FzIGltcGxlbWVudGVkIHRvIGFzc2VydCB0aGF0IGEgY2xpY2sgaGFwcGVuZWQgaW5zaWRlIGEgZHJvcGRvd24gZXZlbiBpZiB0aGUgZHJvcGRvd25cbiAgICAgICAqIGNvbnRhaW5lciBpcyBhcHBlbmRlZCB0byB0aGUgPGJvZHk+IHRhZyBpbiB3aGljaCBjYXNlIHRoZSBjb21wb25lbnQgZG9lc24ndCBhY3R1YWxseVxuICAgICAgICogJ2NvbnRhaW4nIHRoZSBjbGljayB0YXJnZXQuXG4gICAgICAgKlxuICAgICAgICogV2UgbmVlZCB0byB1c2UgJ2NhcHR1cmUnIHBoYXNlIGhlcmUgYmVjYXVzZSB0aGUgZHJvcGRvd24gbWF5IGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAqIERPTSBieSB0aGUgdGltZSAnYnViYmxlJyBldmVudCBoYW5kbGluZyBmaXJlcyB3aGljaCB3b3VsZCBmYWxzZWx5IGxlYWQgdXMgdG8gYmVsaWV2ZSB0aGF0XG4gICAgICAgKiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSBvZiB0aGUgZHJvcGRvd24uICBUaGluZ3MgbGlrZSBjbGlja2luZyBhIGRyb3Bkb3duXG4gICAgICAgKiB3aXRoaW4gYSBkcm9wZG93biB3b3VsZCBjbG9zZSAqYWxsKiBkcm9wZG93bnMgd2hlbiB0aGF0IHdhc24ndCB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IuXG4gICAgICAgKlxuICAgICAgICogQFRPRE8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgcmVwbGFjZWQgd2l0aCBhIG1vcmUgZWxlZ2FudFxuICAgICAgICogc29sdXRpb24gdGhhdCBkb2Vzbid0IGludm9sdmUgRE9NIHRyYXZlcnNhbFxuICAgICAgICogaHR0cHM6Ly9qaXJhLmNvcnAudHVuZS5jb20vYnJvd3NlL1RYTEVORy0xMjJcbiAgICAgICAqL1xuICAgICAgaWYgKCFmaW5kRE9NTm9kZSh0aGlzKS5jb250YWlucyhlLnRhcmdldClcbiAgICAgICAgJiYgIWlzRWxlbWVudEluRHJvcGRvd24oZS50YXJnZXQpXG4gICAgICAgICYmIHRoaXMuc3RhdGUub3Blbikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGVuZGluZ0Nsb3NlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIEBhdXRvYmluZFxuICAgIF91cGRhdGVEcm9wZG93bih7IG9wZW4gfSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW4gfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgLy8gcHJvcHMgd2lsbCBvdmVycmlkZSBhbnkgc3RhdGUgdmFyaWFibGVzXG4gICAgICAvLyBUaGlzIHdheSBhbnkgZHJvcGRvd24gY29tcG9uZW50IHdpdGggcHJvcHMub3BlbiB3aWxsIGJlIGFcbiAgICAgIC8vIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENvbXBvbmVudFxuICAgICAgICAgIC8vIHByb3ZpZGUgaG9vayBmb3IgZ3JhYmJpbmcgaW50ZXJuYWwgY29tcG9uZW50IGluIHRlc3RzXG4gICAgICAgICAgcmVmPVwidW53cmFwcGVkRHJvcGRvd25Db21wb25lbnRcIlxuICAgICAgICAgIHVwZGF0ZURyb3Bkb3duPXt0aGlzLl91cGRhdGVEcm9wZG93bn1cbiAgICAgICAgICB7Li4udGhpcy5zdGF0ZX1cbiAgICAgICAgICB7Li4udGhpcy5wcm9wc31cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHRoZSBwcm9wdHlwZXMgYXJlIHBhc3NlZCBzbyBjYW4gYmUgaW5oZXJpdGVkIGJ5IG90aGVyIGNvbXBvbmVudHNcbiAgVHhsRHJvcGRvd24ucHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcbiAgVHhsRHJvcGRvd24uZGlzcGxheU5hbWUgPSBgVHhsRHJvcGRvd24oJHtDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWV9KWA7XG5cbiAgcmV0dXJuIFR4bERyb3Bkb3duO1xufVxuIl19