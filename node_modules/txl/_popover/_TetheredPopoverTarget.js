'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _desc, _value, _class;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _tether = require('tether');

var _tether2 = _interopRequireDefault(_tether);

var _pickBy = require('lodash/pickBy');

var _pickBy2 = _interopRequireDefault(_pickBy);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _ReactUtils = require('../ReactUtils');

var _Base = require('../base/Base');

var _StyleRoot = require('../styles/StyleRoot');

var _StyleRoot2 = _interopRequireDefault(_StyleRoot);

var _jsStyleHelpers = require('../styles/_helpers/jsStyleHelpers');

var _constants = require('../styles/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var TxlTetheredPopoverTarget = (_class = function (_React$Component) {
  (0, _inherits3.default)(TxlTetheredPopoverTarget, _React$Component);

  function TxlTetheredPopoverTarget() {
    var _ref;

    (0, _classCallCheck3.default)(this, TxlTetheredPopoverTarget);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = TxlTetheredPopoverTarget.__proto__ || (0, _getPrototypeOf2.default)(TxlTetheredPopoverTarget)).call.apply(_ref, [this].concat(args)));

    _this._popover = null;
    _this._DOMNode = null;
    _this._bootstrapped = false;
    return _this;
  }

  (0, _createClass3.default)(TxlTetheredPopoverTarget, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!this.props.visible) {
        return;
      }

      this._bootstrapPopover();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (!this._bootstrapped) {
        return;
      }

      this._teardownPopover();
    }

    /**
     * @TODO: May need a special shouldComponentUpdate method so that we don't
     * rerender on width change.
     */

  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.props.visible) {
        if (this._bootstrapped) {
          this._renderPopover();
        } else {
          this._bootstrapPopover();
        }
      } else {
        if (!this._bootstrapped) {
          return;
        }

        this._teardownPopover();
      }
    }
  }, {
    key: '_bootstrapPopover',
    value: function _bootstrapPopover() {
      this._bootstrapped = true;
      this._createPopover();
      this._renderPopover();
    }
  }, {
    key: '_teardownPopover',
    value: function _teardownPopover() {
      this._tether.destroy();

      if (this._bootstrapped) {
        (0, _ReactUtils.unmountComponentAtNode)(this._popover);
        document.querySelector('body').removeChild(this._popover);
      }

      this._bootstrapped = false;
    }
  }, {
    key: '_getTetherOptions',
    value: function _getTetherOptions() {
      return (0, _extends3.default)({}, this.props.configuration, {
        element: this._popover,
        target: this._DOMNode
      });
    }
  }, {
    key: '_createPopover',
    value: function _createPopover() {
      var popover = document.createElement('div');
      // NOTE: we're relying on this 'data-test-tethered-popover' attribute for detecting clicks
      // within dropdown containers. Deleting this will break dropdowns.
      popover.setAttribute('data-test-tethered-popover', true);
      popover.setAttribute('id', this.props.id + '-popover');

      (0, _jsStyleHelpers.setStylesForNode)(popover, {
        opacity: 0,
        zIndex: this.props.popoverZIndex
      });

      this._popover = popover;
      document.body.appendChild(this._popover);
    }
  }, {
    key: '_setTetherOptions',
    value: function _setTetherOptions() {
      if (this._tether) {
        this._tether.setOptions(this._getTetherOptions());
      } else {
        this._tether = new _tether2.default(this._getTetherOptions());
      }
    }
  }, {
    key: '_renderPopover',
    value: function _renderPopover() {
      var _this2 = this;

      if (this.props.popoverWidth) {
        (0, _jsStyleHelpers.setStylesForNode)(this._popover, {
          width: this.props.popoverWidth
        });
      }

      (0, _ReactUtils.render)(_react2.default.createElement(
        _StyleRoot2.default,
        null,
        _react2.default.createElement(
          'div',
          { onClick: this.props.onContentClick },
          this.props.content
        )
      ), this._popover);
      this._setTetherOptions();

      this.props.tetherAdjustFunction(this._tether);
      window.requestAnimationFrame(function () {
        _this2._tether.position();

        (0, _jsStyleHelpers.setStylesForNode)(_this2._popover, { opacity: 1 });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          children = _props.children,
          componentName = _props.componentName,
          id = _props.id,
          style = _props.style,
          others = (0, _objectWithoutProperties3.default)(_props, ['children', 'componentName', 'id', 'style']);

      // only pass along on* event handlers to native <div />
      // but do not pass onContentClick, which is special handler.

      var rest = (0, _omit2.default)(others, 'onContentClick');
      var eventProps = (0, _pickBy2.default)(rest, function (value, key) {
        return key.indexOf('on') === 0;
      });

      return _react2.default.createElement(
        'div',
        (0, _extends3.default)({}, eventProps, {
          ref: function ref(node) {
            _this3._DOMNode = node;
          },
          'data-component': componentName,
          id: id && id + '-target',
          style: style
        }),
        children
      );
    }
  }]);
  return TxlTetheredPopoverTarget;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class.prototype, '_bootstrapPopover', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_bootstrapPopover'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_teardownPopover', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_teardownPopover'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_getTetherOptions', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_getTetherOptions'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_createPopover', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_createPopover'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_setTetherOptions', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_setTetherOptions'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_renderPopover', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_renderPopover'), _class.prototype)), _class);
exports.default = TxlTetheredPopoverTarget;


TxlTetheredPopoverTarget.defaultProps = {
  popoverZIndex: _constants.Z_INDEXES.popover,
  tetherAdjustFunction: _Base.NOOP
};

TxlTetheredPopoverTarget.propTypes = {
  children: _react.PropTypes.node.isRequired,
  componentName: _react.PropTypes.string.isRequired,
  configuration: _react.PropTypes.object.isRequired,
  content: _react.PropTypes.node.isRequired,
  id: _react.PropTypes.string,
  onContentClick: _react.PropTypes.func,
  popoverWidth: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.string]),
  popoverZIndex: _react.PropTypes.string,
  style: _react.PropTypes.object,
  tetherAdjustFunction: _react.PropTypes.func,
  visible: _react.PropTypes.bool
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(TxlTetheredPopoverTarget, 'TxlTetheredPopoverTarget', 'src/_popover/_TetheredPopoverTarget.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fcG9wb3Zlci9fVGV0aGVyZWRQb3BvdmVyVGFyZ2V0LmpzeCJdLCJuYW1lcyI6WyJUeGxUZXRoZXJlZFBvcG92ZXJUYXJnZXQiLCJhcmdzIiwiX3BvcG92ZXIiLCJfRE9NTm9kZSIsIl9ib290c3RyYXBwZWQiLCJwcm9wcyIsInZpc2libGUiLCJfYm9vdHN0cmFwUG9wb3ZlciIsIl90ZWFyZG93blBvcG92ZXIiLCJfcmVuZGVyUG9wb3ZlciIsIl9jcmVhdGVQb3BvdmVyIiwiX3RldGhlciIsImRlc3Ryb3kiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJyZW1vdmVDaGlsZCIsImNvbmZpZ3VyYXRpb24iLCJlbGVtZW50IiwidGFyZ2V0IiwicG9wb3ZlciIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJpZCIsIm9wYWNpdHkiLCJ6SW5kZXgiLCJwb3BvdmVyWkluZGV4IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2V0T3B0aW9ucyIsIl9nZXRUZXRoZXJPcHRpb25zIiwicG9wb3ZlcldpZHRoIiwid2lkdGgiLCJvbkNvbnRlbnRDbGljayIsImNvbnRlbnQiLCJfc2V0VGV0aGVyT3B0aW9ucyIsInRldGhlckFkanVzdEZ1bmN0aW9uIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicG9zaXRpb24iLCJjaGlsZHJlbiIsImNvbXBvbmVudE5hbWUiLCJzdHlsZSIsIm90aGVycyIsInJlc3QiLCJldmVudFByb3BzIiwidmFsdWUiLCJrZXkiLCJpbmRleE9mIiwibm9kZSIsIkNvbXBvbmVudCIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImlzUmVxdWlyZWQiLCJzdHJpbmciLCJvYmplY3QiLCJmdW5jIiwib25lT2ZUeXBlIiwibnVtYmVyIiwiYm9vbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztB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O0FBR25DcEMsaUJBQWUsaUJBQVVzQyxNQUFWLENBQWlCRixVQUhHO0FBSW5DbkIsV0FBUyxpQkFBVWUsSUFBVixDQUFlSSxVQUpXO0FBS25DOUIsTUFBSSxpQkFBVStCLE1BTHFCO0FBTW5DckIsa0JBQWdCLGlCQUFVdUIsSUFOUztBQU9uQ3pCLGdCQUFjLGlCQUFVMEIsU0FBVixDQUFvQixDQUFDLGlCQUFVQyxNQUFYLEVBQW1CLGlCQUFVSixNQUE3QixDQUFwQixDQVBxQjtBQVFuQzVCLGlCQUFlLGlCQUFVNEIsTUFSVTtBQVNuQ1osU0FBTyxpQkFBVWEsTUFUa0I7QUFVbkNuQix3QkFBc0IsaUJBQVVvQixJQVZHO0FBV25DakQsV0FBUyxpQkFBVW9EO0FBWGdCLENBQXJDOzs7Ozs7OztnQ0F4SnFCMUQsd0IiLCJmaWxlIjoiX1RldGhlcmVkUG9wb3ZlclRhcmdldC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGV0aGVyIGZyb20gJ3RldGhlcic7XG5pbXBvcnQgcGlja0J5IGZyb20gJ2xvZGFzaC9waWNrQnknO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuXG5pbXBvcnQge1xuICByZW5kZXIgYXMgcmVhY3RSZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGUsXG59IGZyb20gJy4uL1JlYWN0VXRpbHMnO1xuaW1wb3J0IHsgYXV0b2JpbmQsIE5PT1AgfSBmcm9tICcuLi9iYXNlL0Jhc2UnO1xuaW1wb3J0IFN0eWxlUm9vdCBmcm9tICcuLi9zdHlsZXMvU3R5bGVSb290JztcbmltcG9ydCB7IHNldFN0eWxlc0Zvck5vZGUgfSBmcm9tICcuLi9zdHlsZXMvX2hlbHBlcnMvanNTdHlsZUhlbHBlcnMnO1xuaW1wb3J0IHsgWl9JTkRFWEVTIH0gZnJvbSAnLi4vc3R5bGVzL2NvbnN0YW50cyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHhsVGV0aGVyZWRQb3BvdmVyVGFyZ2V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5fcG9wb3ZlciA9IG51bGw7XG4gICAgdGhpcy5fRE9NTm9kZSA9IG51bGw7XG4gICAgdGhpcy5fYm9vdHN0cmFwcGVkID0gZmFsc2U7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudmlzaWJsZSkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX2Jvb3RzdHJhcFBvcG92ZXIoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICghdGhpcy5fYm9vdHN0cmFwcGVkKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fdGVhcmRvd25Qb3BvdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQFRPRE86IE1heSBuZWVkIGEgc3BlY2lhbCBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICogcmVyZW5kZXIgb24gd2lkdGggY2hhbmdlLlxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnZpc2libGUpIHtcbiAgICAgIGlmICh0aGlzLl9ib290c3RyYXBwZWQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyUG9wb3ZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9wb3ZlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX2Jvb3RzdHJhcHBlZCkgeyByZXR1cm47IH1cblxuICAgICAgdGhpcy5fdGVhcmRvd25Qb3BvdmVyKCk7XG4gICAgfVxuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9ib290c3RyYXBQb3BvdmVyKCkge1xuICAgIHRoaXMuX2Jvb3RzdHJhcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fY3JlYXRlUG9wb3ZlcigpO1xuICAgIHRoaXMuX3JlbmRlclBvcG92ZXIoKTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfdGVhcmRvd25Qb3BvdmVyKCkge1xuICAgIHRoaXMuX3RldGhlci5kZXN0cm95KCk7XG5cbiAgICBpZiAodGhpcy5fYm9vdHN0cmFwcGVkKSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuX3BvcG92ZXIpO1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLnJlbW92ZUNoaWxkKHRoaXMuX3BvcG92ZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2Jvb3RzdHJhcHBlZCA9IGZhbHNlO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9nZXRUZXRoZXJPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24sXG4gICAgICBlbGVtZW50OiB0aGlzLl9wb3BvdmVyLFxuICAgICAgdGFyZ2V0OiB0aGlzLl9ET01Ob2RlLFxuICAgIH07XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2NyZWF0ZVBvcG92ZXIoKSB7XG4gICAgY29uc3QgcG9wb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIE5PVEU6IHdlJ3JlIHJlbHlpbmcgb24gdGhpcyAnZGF0YS10ZXN0LXRldGhlcmVkLXBvcG92ZXInIGF0dHJpYnV0ZSBmb3IgZGV0ZWN0aW5nIGNsaWNrc1xuICAgIC8vIHdpdGhpbiBkcm9wZG93biBjb250YWluZXJzLiBEZWxldGluZyB0aGlzIHdpbGwgYnJlYWsgZHJvcGRvd25zLlxuICAgIHBvcG92ZXIuc2V0QXR0cmlidXRlKCdkYXRhLXRlc3QtdGV0aGVyZWQtcG9wb3ZlcicsIHRydWUpO1xuICAgIHBvcG92ZXIuc2V0QXR0cmlidXRlKCdpZCcsIGAke3RoaXMucHJvcHMuaWR9LXBvcG92ZXJgKTtcblxuICAgIHNldFN0eWxlc0Zvck5vZGUocG9wb3Zlciwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHpJbmRleDogdGhpcy5wcm9wcy5wb3BvdmVyWkluZGV4LFxuICAgIH0pO1xuXG4gICAgdGhpcy5fcG9wb3ZlciA9IHBvcG92ZXI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9wb3BvdmVyKTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfc2V0VGV0aGVyT3B0aW9ucygpIHtcbiAgICBpZiAodGhpcy5fdGV0aGVyKSB7XG4gICAgICB0aGlzLl90ZXRoZXIuc2V0T3B0aW9ucyh0aGlzLl9nZXRUZXRoZXJPcHRpb25zKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZXRoZXIgPSBuZXcgVGV0aGVyKHRoaXMuX2dldFRldGhlck9wdGlvbnMoKSk7XG4gICAgfVxuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9yZW5kZXJQb3BvdmVyKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnBvcG92ZXJXaWR0aCkge1xuICAgICAgc2V0U3R5bGVzRm9yTm9kZSh0aGlzLl9wb3BvdmVyLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLnBvcG92ZXJXaWR0aCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlYWN0UmVuZGVyKFxuICAgICAgPFN0eWxlUm9vdD5cbiAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLnByb3BzLm9uQ29udGVudENsaWNrfT5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5jb250ZW50fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvU3R5bGVSb290PixcbiAgICAgIHRoaXMuX3BvcG92ZXJcbiAgICApO1xuICAgIHRoaXMuX3NldFRldGhlck9wdGlvbnMoKTtcblxuICAgIHRoaXMucHJvcHMudGV0aGVyQWRqdXN0RnVuY3Rpb24odGhpcy5fdGV0aGVyKTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX3RldGhlci5wb3NpdGlvbigpO1xuXG4gICAgICBzZXRTdHlsZXNGb3JOb2RlKHRoaXMuX3BvcG92ZXIsIHsgb3BhY2l0eTogMSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICBpZCxcbiAgICAgIHN0eWxlLFxuICAgICAgLi4ub3RoZXJzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBvbmx5IHBhc3MgYWxvbmcgb24qIGV2ZW50IGhhbmRsZXJzIHRvIG5hdGl2ZSA8ZGl2IC8+XG4gICAgLy8gYnV0IGRvIG5vdCBwYXNzIG9uQ29udGVudENsaWNrLCB3aGljaCBpcyBzcGVjaWFsIGhhbmRsZXIuXG4gICAgY29uc3QgcmVzdCA9IG9taXQob3RoZXJzLCAnb25Db250ZW50Q2xpY2snKTtcbiAgICBjb25zdCBldmVudFByb3BzID0gcGlja0J5KHJlc3QsICh2YWx1ZSwga2V5KSA9PiBrZXkuaW5kZXhPZignb24nKSA9PT0gMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICB7Li4uZXZlbnRQcm9wc31cbiAgICAgICAgcmVmPXsobm9kZSkgPT4geyB0aGlzLl9ET01Ob2RlID0gbm9kZTsgfX1cbiAgICAgICAgZGF0YS1jb21wb25lbnQ9e2NvbXBvbmVudE5hbWV9XG4gICAgICAgIGlkPXtpZCAmJiBgJHtpZH0tdGFyZ2V0YH1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblR4bFRldGhlcmVkUG9wb3ZlclRhcmdldC5kZWZhdWx0UHJvcHMgPSB7XG4gIHBvcG92ZXJaSW5kZXg6IFpfSU5ERVhFUy5wb3BvdmVyLFxuICB0ZXRoZXJBZGp1c3RGdW5jdGlvbjogTk9PUCxcbn07XG5cblR4bFRldGhlcmVkUG9wb3ZlclRhcmdldC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICBjb21wb25lbnROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGNvbmZpZ3VyYXRpb246IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY29udGVudDogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ29udGVudENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgcG9wb3ZlcldpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHBvcG92ZXJaSW5kZXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0ZXRoZXJBZGp1c3RGdW5jdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIHZpc2libGU6IFByb3BUeXBlcy5ib29sLFxufTtcbiJdfQ==