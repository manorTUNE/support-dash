'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ITEM_PROP_TYPES = exports.ITEM_DEFAULT_PROPS = exports.getItemStyle = exports.getContainerStyle = exports.CONTAINER_PROP_TYPES = exports.CONTAINER_DEFAULT_PROPS = undefined;

var _react = require('react');

// start of flex style enum
var FLEX_START = 'flex-start'; /**
                                * FlexBox.style contains various resuable style generation for flex-specific style implementation.
                                * Since each browser interprets flex style differently, it is probably good idea to
                                * have single point of flex style generation.
                                *
                                * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/
                                */

var FLEX_END = 'flex-end';
var CENTER = 'center';
var AUTO = 'auto';
var BASELINE = 'baseline';
var STRETCH = 'stretch';
var SPACE_BETWEEN = 'space-between';
var SPACE_AROUND = 'space-around';
var NOWRAP = 'nowrap';
var WRAP = 'wrap';
var WRAP_REVERSE = 'wrap-reverse';
var ROW = 'row';
var ROW_REVERSE = 'row-reverse';
var COLUMN = 'column';
var COLUMN_REVERSE = 'column-reverse';
// end of flex style enums

/**
 * returns flex-container specific style object
 * As of now, there isn't much thing to add.
 *
 * @param  {FlexContainerStyle} style   FlexContainerStyle style object which
 *                                      contains flex-container specific properties.
 * @return {FlexContainerStyle}         New FlexContainerStyle with flex display property
 */
function getContainerStyle(style) {
  var flexWrap = style.flexWrap,
      flexDirection = style.flexDirection,
      justifyContent = style.justifyContent,
      alignItems = style.alignItems,
      alignContent = style.alignContent;


  return {
    alignContent: alignContent,
    alignItems: alignItems,
    display: 'flex',
    flexDirection: flexDirection,
    flexWrap: flexWrap,
    justifyContent: justifyContent
  };
}

/**
 * returns flex-item specific style object.
 * This function reduces flexGrow, flexShirnk, and flexBasis into single "flex" property. IE does
 * not know how to inteprete above properties, correctly.
 *
 * returned object can be used for IE, too.
 * @param  {FlexItemProps} style  FlexItemStyle object
 * @return {FlexItemStyle}       style
 */
function getItemStyle(style) {
  return {
    alignSelf: style.alignSelf,
    flex: style.flexGrow + ' ' + style.flexShrink + ' ' + style.flexBasis,
    order: style.order
  };
}

var ALIGN_CONTENT_TYPE = _react.PropTypes.oneOf([FLEX_START, FLEX_END, CENTER, SPACE_BETWEEN, SPACE_AROUND, STRETCH]);

var ALIGN_ITEMS_TYPE = _react.PropTypes.oneOf([FLEX_START, FLEX_END, CENTER, BASELINE, STRETCH]);

var FLEX_DIRECTION_TYPE = _react.PropTypes.oneOf([ROW, ROW_REVERSE, COLUMN, COLUMN_REVERSE]);

var FLEX_WRAP_TYPE = _react.PropTypes.oneOf([NOWRAP, WRAP, WRAP_REVERSE]);

var JUSTIFY_CONTENT_TYPE = _react.PropTypes.oneOf([FLEX_START, FLEX_END, CENTER, SPACE_BETWEEN, SPACE_AROUND]);

var ALIGN_SELF_TYPE = _react.PropTypes.oneOf([AUTO, FLEX_START, FLEX_END, CENTER, BASELINE]);

/**
 * type FlexContainerPropTypes
 *
 * @type {Object}
 */
var CONTAINER_PROP_TYPES = {
  alignContent: ALIGN_CONTENT_TYPE,
  alignItems: ALIGN_ITEMS_TYPE,
  children: _react.PropTypes.node,
  flexDirection: FLEX_DIRECTION_TYPE,
  flexWrap: FLEX_WRAP_TYPE,
  justifyContent: JUSTIFY_CONTENT_TYPE,
  style: _react.PropTypes.object,
  tagName: _react.PropTypes.string
};

/**
 * type FlexItemPropTypes
 *
 * @type {Object}
 */
var ITEM_PROP_TYPES = {
  alignSelf: ALIGN_SELF_TYPE,
  children: _react.PropTypes.node,
  flexBasis: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
  flexGrow: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
  flexShrink: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
  order: _react.PropTypes.number,
  style: _react.PropTypes.object,
  tagName: _react.PropTypes.string
};

var CONTAINER_DEFAULT_PROPS = {
  alignContent: STRETCH,
  alignItems: FLEX_START,
  flexDirection: ROW,
  flexWrap: NOWRAP,
  justifyContent: FLEX_START,
  tagName: 'div'
};

var ITEM_DEFAULT_PROPS = {
  flexBasis: 'auto',
  flexGrow: 0,
  flexShrink: 0,
  tagName: 'div'
};

exports.CONTAINER_DEFAULT_PROPS = CONTAINER_DEFAULT_PROPS;
exports.CONTAINER_PROP_TYPES = CONTAINER_PROP_TYPES;
exports.getContainerStyle = getContainerStyle;
exports.getItemStyle = getItemStyle;
exports.ITEM_DEFAULT_PROPS = ITEM_DEFAULT_PROPS;
exports.ITEM_PROP_TYPES = ITEM_PROP_TYPES;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(FLEX_START, 'FLEX_START', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(FLEX_END, 'FLEX_END', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(CENTER, 'CENTER', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(AUTO, 'AUTO', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(BASELINE, 'BASELINE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(STRETCH, 'STRETCH', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(SPACE_BETWEEN, 'SPACE_BETWEEN', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(SPACE_AROUND, 'SPACE_AROUND', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(NOWRAP, 'NOWRAP', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(WRAP, 'WRAP', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(WRAP_REVERSE, 'WRAP_REVERSE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ROW, 'ROW', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ROW_REVERSE, 'ROW_REVERSE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(COLUMN, 'COLUMN', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(COLUMN_REVERSE, 'COLUMN_REVERSE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(getContainerStyle, 'getContainerStyle', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(getItemStyle, 'getItemStyle', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ALIGN_CONTENT_TYPE, 'ALIGN_CONTENT_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ALIGN_ITEMS_TYPE, 'ALIGN_ITEMS_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(FLEX_DIRECTION_TYPE, 'FLEX_DIRECTION_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(FLEX_WRAP_TYPE, 'FLEX_WRAP_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(JUSTIFY_CONTENT_TYPE, 'JUSTIFY_CONTENT_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ALIGN_SELF_TYPE, 'ALIGN_SELF_TYPE', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(CONTAINER_PROP_TYPES, 'CONTAINER_PROP_TYPES', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ITEM_PROP_TYPES, 'ITEM_PROP_TYPES', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(CONTAINER_DEFAULT_PROPS, 'CONTAINER_DEFAULT_PROPS', 'src/layout/FlexBox.style.js');

  __REACT_HOT_LOADER__.register(ITEM_DEFAULT_PROPS, 'ITEM_DEFAULT_PROPS', 'src/layout/FlexBox.style.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXlvdXQvRmxleEJveC5zdHlsZS5qcyJdLCJuYW1lcyI6WyJGTEVYX1NUQVJUIiwiRkxFWF9FTkQiLCJDRU5URVIiLCJBVVRPIiwiQkFTRUxJTkUiLCJTVFJFVENIIiwiU1BBQ0VfQkVUV0VFTiIsIlNQQUNFX0FST1VORCIsIk5PV1JBUCIsIldSQVAiLCJXUkFQX1JFVkVSU0UiLCJST1ciLCJST1dfUkVWRVJTRSIsIkNPTFVNTiIsIkNPTFVNTl9SRVZFUlNFIiwiZ2V0Q29udGFpbmVyU3R5bGUiLCJzdHlsZSIsImZsZXhXcmFwIiwiZmxleERpcmVjdGlvbiIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsImFsaWduQ29udGVudCIsImRpc3BsYXkiLCJnZXRJdGVtU3R5bGUiLCJhbGlnblNlbGYiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4U2hyaW5rIiwiZmxleEJhc2lzIiwib3JkZXIiLCJBTElHTl9DT05URU5UX1RZUEUiLCJvbmVPZiIsIkFMSUdOX0lURU1TX1RZUEUiLCJGTEVYX0RJUkVDVElPTl9UWVBFIiwiRkxFWF9XUkFQX1RZUEUiLCJKVVNUSUZZX0NPTlRFTlRfVFlQRSIsIkFMSUdOX1NFTEZfVFlQRSIsIkNPTlRBSU5FUl9QUk9QX1RZUEVTIiwiY2hpbGRyZW4iLCJub2RlIiwib2JqZWN0IiwidGFnTmFtZSIsInN0cmluZyIsIklURU1fUFJPUF9UWVBFUyIsIm9uZU9mVHlwZSIsIm51bWJlciIsIkNPTlRBSU5FUl9ERUZBVUxUX1BST1BTIiwiSVRFTV9ERUZBVUxUX1BST1BTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQSxJQUFNQSxhQUFhLFlBQW5CLEMsQ0FWQTs7Ozs7Ozs7QUFXQSxJQUFNQyxXQUFXLFVBQWpCO0FBQ0EsSUFBTUMsU0FBUyxRQUFmO0FBQ0EsSUFBTUMsT0FBTyxNQUFiO0FBQ0EsSUFBTUMsV0FBVyxVQUFqQjtBQUNBLElBQU1DLFVBQVUsU0FBaEI7QUFDQSxJQUFNQyxnQkFB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eC5zdHlsZSBjb250YWlucyB2YXJpb3VzIHJlc3VhYmxlIHN0eWxlIGdlbmVyYXRpb24gZm9yIGZsZXgtc3BlY2lmaWMgc3R5bGUgaW1wbGVtZW50YXRpb24uXG4gKiBTaW5jZSBlYWNoIGJyb3dzZXIgaW50ZXJwcmV0cyBmbGV4IHN0eWxlIGRpZmZlcmVudGx5LCBpdCBpcyBwcm9iYWJseSBnb29kIGlkZWEgdG9cbiAqIGhhdmUgc2luZ2xlIHBvaW50IG9mIGZsZXggc3R5bGUgZ2VuZXJhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc25pcHBldHMvY3NzL2EtZ3VpZGUtdG8tZmxleGJveC9cbiAqL1xuaW1wb3J0IHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBzdGFydCBvZiBmbGV4IHN0eWxlIGVudW1cbmNvbnN0IEZMRVhfU1RBUlQgPSAnZmxleC1zdGFydCc7XG5jb25zdCBGTEVYX0VORCA9ICdmbGV4LWVuZCc7XG5jb25zdCBDRU5URVIgPSAnY2VudGVyJztcbmNvbnN0IEFVVE8gPSAnYXV0byc7XG5jb25zdCBCQVNFTElORSA9ICdiYXNlbGluZSc7XG5jb25zdCBTVFJFVENIID0gJ3N0cmV0Y2gnO1xuY29uc3QgU1BBQ0VfQkVUV0VFTiA9ICdzcGFjZS1iZXR3ZWVuJztcbmNvbnN0IFNQQUNFX0FST1VORCA9ICdzcGFjZS1hcm91bmQnO1xuY29uc3QgTk9XUkFQID0gJ25vd3JhcCc7XG5jb25zdCBXUkFQID0gJ3dyYXAnO1xuY29uc3QgV1JBUF9SRVZFUlNFID0gJ3dyYXAtcmV2ZXJzZSc7XG5jb25zdCBST1cgPSAncm93JztcbmNvbnN0IFJPV19SRVZFUlNFID0gJ3Jvdy1yZXZlcnNlJztcbmNvbnN0IENPTFVNTiA9ICdjb2x1bW4nO1xuY29uc3QgQ09MVU1OX1JFVkVSU0UgPSAnY29sdW1uLXJldmVyc2UnO1xuLy8gZW5kIG9mIGZsZXggc3R5bGUgZW51bXNcblxuLyoqXG4gKiByZXR1cm5zIGZsZXgtY29udGFpbmVyIHNwZWNpZmljIHN0eWxlIG9iamVjdFxuICogQXMgb2Ygbm93LCB0aGVyZSBpc24ndCBtdWNoIHRoaW5nIHRvIGFkZC5cbiAqXG4gKiBAcGFyYW0gIHtGbGV4Q29udGFpbmVyU3R5bGV9IHN0eWxlICAgRmxleENvbnRhaW5lclN0eWxlIHN0eWxlIG9iamVjdCB3aGljaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zIGZsZXgtY29udGFpbmVyIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtGbGV4Q29udGFpbmVyU3R5bGV9ICAgICAgICAgTmV3IEZsZXhDb250YWluZXJTdHlsZSB3aXRoIGZsZXggZGlzcGxheSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRDb250YWluZXJTdHlsZShzdHlsZSkge1xuICBjb25zdCB7XG4gICAgZmxleFdyYXAsXG4gICAgZmxleERpcmVjdGlvbixcbiAgICBqdXN0aWZ5Q29udGVudCxcbiAgICBhbGlnbkl0ZW1zLFxuICAgIGFsaWduQ29udGVudCxcbiAgfSA9IHN0eWxlO1xuXG4gIHJldHVybiB7XG4gICAgYWxpZ25Db250ZW50LFxuICAgIGFsaWduSXRlbXMsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb24sXG4gICAgZmxleFdyYXAsXG4gICAganVzdGlmeUNvbnRlbnQsXG4gIH07XG59XG5cbi8qKlxuICogcmV0dXJucyBmbGV4LWl0ZW0gc3BlY2lmaWMgc3R5bGUgb2JqZWN0LlxuICogVGhpcyBmdW5jdGlvbiByZWR1Y2VzIGZsZXhHcm93LCBmbGV4U2hpcm5rLCBhbmQgZmxleEJhc2lzIGludG8gc2luZ2xlIFwiZmxleFwiIHByb3BlcnR5LiBJRSBkb2VzXG4gKiBub3Qga25vdyBob3cgdG8gaW50ZXByZXRlIGFib3ZlIHByb3BlcnRpZXMsIGNvcnJlY3RseS5cbiAqXG4gKiByZXR1cm5lZCBvYmplY3QgY2FuIGJlIHVzZWQgZm9yIElFLCB0b28uXG4gKiBAcGFyYW0gIHtGbGV4SXRlbVByb3BzfSBzdHlsZSAgRmxleEl0ZW1TdHlsZSBvYmplY3RcbiAqIEByZXR1cm4ge0ZsZXhJdGVtU3R5bGV9ICAgICAgIHN0eWxlXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZW1TdHlsZShzdHlsZSkge1xuICByZXR1cm4ge1xuICAgIGFsaWduU2VsZjogc3R5bGUuYWxpZ25TZWxmLFxuICAgIGZsZXg6IGAke3N0eWxlLmZsZXhHcm93fSAke3N0eWxlLmZsZXhTaHJpbmt9ICR7c3R5bGUuZmxleEJhc2lzfWAsXG4gICAgb3JkZXI6IHN0eWxlLm9yZGVyLFxuICB9O1xufVxuXG5jb25zdCBBTElHTl9DT05URU5UX1RZUEUgPSBQcm9wVHlwZXMub25lT2YoW1xuICBGTEVYX1NUQVJULFxuICBGTEVYX0VORCxcbiAgQ0VOVEVSLFxuICBTUEFDRV9CRVRXRUVOLFxuICBTUEFDRV9BUk9VTkQsXG4gIFNUUkVUQ0gsXG5dKTtcblxuY29uc3QgQUxJR05fSVRFTVNfVFlQRSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIEZMRVhfU1RBUlQsXG4gIEZMRVhfRU5ELFxuICBDRU5URVIsXG4gIEJBU0VMSU5FLFxuICBTVFJFVENILFxuXSk7XG5cbmNvbnN0IEZMRVhfRElSRUNUSU9OX1RZUEUgPSBQcm9wVHlwZXMub25lT2YoW1xuICBST1csXG4gIFJPV19SRVZFUlNFLFxuICBDT0xVTU4sXG4gIENPTFVNTl9SRVZFUlNFLFxuXSk7XG5cbmNvbnN0IEZMRVhfV1JBUF9UWVBFID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgTk9XUkFQLFxuICBXUkFQLFxuICBXUkFQX1JFVkVSU0UsXG5dKTtcblxuY29uc3QgSlVTVElGWV9DT05URU5UX1RZUEUgPSBQcm9wVHlwZXMub25lT2YoW1xuICBGTEVYX1NUQVJULFxuICBGTEVYX0VORCxcbiAgQ0VOVEVSLFxuICBTUEFDRV9CRVRXRUVOLFxuICBTUEFDRV9BUk9VTkQsXG5dKTtcblxuY29uc3QgQUxJR05fU0VMRl9UWVBFID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgQVVUTyxcbiAgRkxFWF9TVEFSVCxcbiAgRkxFWF9FTkQsXG4gIENFTlRFUixcbiAgQkFTRUxJTkUsXG5dKTtcblxuLyoqXG4gKiB0eXBlIEZsZXhDb250YWluZXJQcm9wVHlwZXNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBDT05UQUlORVJfUFJPUF9UWVBFUyA9IHtcbiAgYWxpZ25Db250ZW50OiBBTElHTl9DT05URU5UX1RZUEUsXG4gIGFsaWduSXRlbXM6IEFMSUdOX0lURU1TX1RZUEUsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgZmxleERpcmVjdGlvbjogRkxFWF9ESVJFQ1RJT05fVFlQRSxcbiAgZmxleFdyYXA6IEZMRVhfV1JBUF9UWVBFLFxuICBqdXN0aWZ5Q29udGVudDogSlVTVElGWV9DT05URU5UX1RZUEUsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB0YWdOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxufTtcblxuLyoqXG4gKiB0eXBlIEZsZXhJdGVtUHJvcFR5cGVzXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgSVRFTV9QUk9QX1RZUEVTID0ge1xuICBhbGlnblNlbGY6IEFMSUdOX1NFTEZfVFlQRSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBmbGV4QmFzaXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZmxleEdyb3c6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZmxleFNocmluazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBvcmRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHRhZ05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG59O1xuXG5jb25zdCBDT05UQUlORVJfREVGQVVMVF9QUk9QUyA9IHtcbiAgYWxpZ25Db250ZW50OiBTVFJFVENILFxuICBhbGlnbkl0ZW1zOiBGTEVYX1NUQVJULFxuICBmbGV4RGlyZWN0aW9uOiBST1csXG4gIGZsZXhXcmFwOiBOT1dSQVAsXG4gIGp1c3RpZnlDb250ZW50OiBGTEVYX1NUQVJULFxuICB0YWdOYW1lOiAnZGl2Jyxcbn07XG5cbmNvbnN0IElURU1fREVGQVVMVF9QUk9QUyA9IHtcbiAgZmxleEJhc2lzOiAnYXV0bycsXG4gIGZsZXhHcm93OiAwLFxuICBmbGV4U2hyaW5rOiAwLFxuICB0YWdOYW1lOiAnZGl2Jyxcbn07XG5cbmV4cG9ydCB7XG4gIENPTlRBSU5FUl9ERUZBVUxUX1BST1BTLFxuICBDT05UQUlORVJfUFJPUF9UWVBFUyxcbiAgZ2V0Q29udGFpbmVyU3R5bGUsXG4gIGdldEl0ZW1TdHlsZSxcbiAgSVRFTV9ERUZBVUxUX1BST1BTLFxuICBJVEVNX1BST1BfVFlQRVMsXG59O1xuIl19