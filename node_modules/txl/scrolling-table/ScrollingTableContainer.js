'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _immutable = require('immutable');

var _LoadingIndicator = require('../progress-indicators/LoadingIndicator');

var _LoadingIndicator2 = _interopRequireDefault(_LoadingIndicator);

var _ScrollingTableRow = require('./ScrollingTableRow');

var _ScrollingTableRow2 = _interopRequireDefault(_ScrollingTableRow);

var _ScrollState = require('./records/ScrollState');

var _ScrollState2 = _interopRequireDefault(_ScrollState);

var _ = require('./');

var _ScrollingTable = require('./ScrollingTable.style');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var babelPluginFlowReactPropTypes_proptype_Headers = require('./constants').babelPluginFlowReactPropTypes_proptype_Headers || require('react').PropTypes.any;

var ScrollingTableContainer = function (_Component) {
  (0, _inherits3.default)(ScrollingTableContainer, _Component);

  function ScrollingTableContainer() {
    (0, _classCallCheck3.default)(this, ScrollingTableContainer);
    return (0, _possibleConstructorReturn3.default)(this, (ScrollingTableContainer.__proto__ || (0, _getPrototypeOf2.default)(ScrollingTableContainer)).apply(this, arguments));
  }

  (0, _createClass3.default)(ScrollingTableContainer, [{
    key: '_getStart',
    value: function _getStart() {
      return Math.max(this.props.scrollState.get('offset') - 1, 0);
    }
  }, {
    key: '_getEnd',
    value: function _getEnd() {
      var _props = this.props,
          scrollState = _props.scrollState,
          viewSizeInRows = _props.viewSizeInRows,
          totalRows = _props.totalRows;

      return Math.min(scrollState.get('offset') + viewSizeInRows, totalRows);
    }
  }, {
    key: '_renderTopOffset',
    value: function _renderTopOffset() {
      var start = this._getStart();
      var rowHeight = this.props.rowHeight;


      if (start === 0) {
        return null;
      }

      return _react2.default.createElement('tr', { key: 'start', style: { height: start * rowHeight } });
    }
  }, {
    key: '_renderBottomOffset',
    value: function _renderBottomOffset() {
      var _props2 = this.props,
          totalRows = _props2.totalRows,
          rowHeight = _props2.rowHeight;

      var end = this._getEnd();
      if (end === totalRows) {
        return null;
      }

      return _react2.default.createElement('tr', { key: 'end', style: { height: (totalRows - end) * rowHeight } });
    }
  }, {
    key: '_renderRows',
    value: function _renderRows() {
      var rows = [];
      var _props3 = this.props,
          rowHeight = _props3.rowHeight,
          viewSizeInRows = _props3.viewSizeInRows;

      var start = this._getStart();
      var end = this._getEnd();

      for (var i = start; i < end; i++) {
        var data = this.props.rows.getIn(['' + i, 'data']);
        /**
         * This key function is important, by taking the modulo of
         * the current row number by the view port size we can be
         * assured that ScrollingTableRow containers are recycled,
         * improving render perf.
         */
        var key = i % (viewSizeInRows + 1);

        rows.push(_react2.default.createElement(_ScrollingTableRow2.default, {
          key: key,
          headers: this.props.headers,
          data: data == null ? new _immutable.List() : data,
          height: rowHeight,
          rowNumber: i
        }));
      }

      return rows;
    }
  }, {
    key: '_renderHeaders',
    value: function _renderHeaders() {
      return this.props.headers.valueSeq().toArray().map(function (header) {
        return _react2.default.createElement(
          'th',
          {
            key: header.id,
            style: (0, _extends3.default)({
              minWidth: header.minWidth,
              padding: 0
            }, _ScrollingTable.HEADER_CELL_PLACEHOLDER_STYLES)
          },
          _react2.default.createElement('div', { style: { width: header.width } })
        );
      });
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.props.loading) {
        return _react2.default.createElement(
          'div',
          { style: _ScrollingTable.TABLE_STYLES },
          _react2.default.createElement(
            'div',
            { style: _ScrollingTable.LOADING_INDICATOR_STYLES },
            _react2.default.createElement(_LoadingIndicator2.default, { size: 'large' })
          )
        );
      }

      return _react2.default.createElement(
        'table',
        {
          style: _ScrollingTable.TABLE_STYLES,
          cellPadding: 0,
          cellSpacing: 0
        },
        _react2.default.createElement(
          'thead',
          null,
          _react2.default.createElement(
            'tr',
            null,
            this._renderHeaders()
          )
        ),
        _react2.default.createElement(
          'tbody',
          null,
          this._renderTopOffset(),
          this._renderRows(),
          this._renderBottomOffset()
        )
      );
    }
  }]);
  return ScrollingTableContainer;
}(_react.Component);

ScrollingTableContainer.propTypes = {
  headers: babelPluginFlowReactPropTypes_proptype_Headers,
  loading: require('react').PropTypes.bool.isRequired,
  rowHeight: require('react').PropTypes.number.isRequired,
  rows: require('react').PropTypes.any.isRequired,
  scrollState: require('react').PropTypes.any.isRequired,
  totalRows: require('react').PropTypes.number.isRequired,
  viewSizeInRows: require('react').PropTypes.number.isRequired
};
exports.default = ScrollingTableContainer;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(ScrollingTableContainer, 'ScrollingTableContainer', 'src/scrolling-table/ScrollingTableContainer.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JvbGxpbmctdGFibGUvU2Nyb2xsaW5nVGFibGVDb250YWluZXIuanN4Il0sIm5hbWVzIjpbIlNjcm9sbGluZ1RhYmxlQ29udGFpbmVyIiwiTWF0aCIsIm1heCIsInByb3BzIiwic2Nyb2xsU3RhdGUiLCJnZXQiLCJ2aWV3U2l6ZUluUm93cyIsInRvdGFsUm93cyIsIm1pbiIsInN0YXJ0IiwiX2dldFN0YXJ0Iiwicm93SGVpZ2h0IiwiaGVpZ2h0IiwiZW5kIiwiX2dldEVuZCIsInJvd3MiLCJpIiwiZGF0YSIsImdldEluIiwia2V5IiwicHVzaCIsImhlYWRlcnMiLCJ2YWx1ZVNlcSIsInRvQXJyYXkiLCJtYXAiLCJoZWFkZXIiLCJpZCIsIm1pbldpZHRoIiwicGFkZGluZyIsIndpZHRoIiwibG9hZGluZyIsIl9yZW5kZXJIZWFkZXJzIiwiX3JlbmRlclRvcE9mZnNldCIsIl9yZW5kZXJSb3dzIiwiX3JlbmRlckJvdHRvbU9mZnNldCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztJQWlCcUJBLHVCOzs7Ozs7Ozs7O2dDQUlDO0FBQ2xCLGFBQU9DLEtBQUtDLEdBQUwsQ0FBUyxLQUFLQyxLQUFMLENBQVdDLFdBQVgsQ0FBdUJDLEdBQXZCLENBQTJCLFFBQTNCLElBQXVDLENBQWhELEVBQW1ELENBQW5ELENBQVA7QUFDRDs7OzhCQUVpQjtBQUFBLG1CQUNtQyxLQUFLRixLQUR4QztBQUFBLFVBQ1JDLFdBRFEsVUFDUkEsV0FEUTtBQUFBLFVBQ0tFLGNBREwsVUFDS0EsY0FETDtBQUFBLFVBQ3FCQyxTQURyQixVQUNxQkEsU0FEckI7O0FBRWhCLGFBQU9OLEtBQUtPLEdBQUwsQ0FBU0osWUFBWUMsR0FBWixDQUFnQixRQUFoQixJQUE0QkMsY0FBckMsRUFBcURDLFNBQXJELENBQVA7QUFDRDs7O3VDQUVxQztBQUNwQyxVQUFNRSxRQUFRLEtBQUtDLFNBQUwsRUFBZDtBQURvQyxVQUU1QkMsU0FGNEIsR0FFZCxLQUFLUixLQUZTLENBRTVCUSxTQUY0Qjs7O0FBSXBDLFVBQUlGLFVBQVUsQ0FBZCxFQUFpQjtBQUNmLGVBQU8sSUFBUDtBQUNEOztBQUVELGFBQU8sc0NBQUksS0FBSSxPQUFSLEVBQWdCLE9BQU8sRUFBRUcsUUFBUUgsUUFBUUUsU0FBbEIsRUFBdkIsR0FBUDtBQUNEOzs7MENBRXdDO0FBQUEsb0JBQ04sS0FBS1IsS0FEQztBQUFBLFVBQy9CSSxTQUQrQixXQUMvQkEsU0FEK0I7QUFBQSxVQUNwQkksU0FEb0IsV0FDcEJBLFNBRG9COztBQUV2QyxVQUFNRSxNQUFNLEtBQUtDLE9BQUwsRUFBWjtBQUNBLFVBQUlELFFBQVFOLFNBQVosRUFBdUI7QUFDckIsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsYUFBTyxzQ0FBSSxLQUFJLEtBQVIsRUFBYyxPQUFPLEVBQUVLLFFBQVEsQ0FBQ0wsWUFBWU0sR0FBYixJQUFvQkYsU0FBOUIsRUFBckIsR0FBUDtBQUNEOzs7a0NBRXNDO0FBQ3JDLFVBQU1JLE9BQU8sRUFBYjtBQURxQyxvQkFFQyxLQUFLWixLQUZOO0FBQUEsVUFFN0JRLFNBRjZCLFdBRTdCQSxTQUY2QjtBQUFBLFVBRWxCTCxjQUZrQixXQUVsQkEsY0FGa0I7O0FBR3JDLFVBQU1HLFFBQVEsS0FBS0MsU0FBTCxFQUFkO0FBQ0EsVUFBTUcsTUFBTSxLQUFLQyxPQUFMLEVBQVo7O0FBRUEsV0FBSyxJQUFJRSxJQUFJUCxLQUFiLEVBQW9CTyxJQUFJSCxHQUF4QixFQUE2QkcsR0FBN0IsRUFBa0M7QUFDaEMsWUFBTUMsT0FBTyxLQUFLZCxLQUFMLENBQVdZLElBQVgsQ0FBZ0JHLEtBQWhCLENBQXNCLE1BQUlGLENBQUosRUFBUyxNQUFULENBQXRCLENBQWI7QUFDQTs7Ozs7O0FBTUEsWUFBTUcsTUFBTUgsS0FBS1YsaUJBQWlCLENBQXRCLENBQVo7O0FBRUFTLGFBQUtLLElBQUwsQ0FDRTtBQUNFLGVBQUtELEdBRFA7QUFFRSxtQkFBUyxLQUFLaEIsS0FBTCxDQUFXa0IsT0FGdEI7QUFHRSxnQkFBTUosUUFBUSxJQUFSLEdBQWUscUJBQWYsR0FBNEJBLElBSHBDO0FBSUUsa0JBQVFOLFNBSlY7QUFLRSxxQkFBV0s7QUFMYixVQURGO0FBU0Q7O0FBRUQsYUFBT0QsSUFBUDtBQUNEOzs7cUNBRXlDO0FBQ3hDLGFBQU8sS0FBS1osS0FBTCxDQUFXa0IsT0FBWCxDQUFtQkMsUUFBbkIsR0FBOEJDLE9BQTlCLEdBQ0pDLEdBREksQ0FDQSxVQUFDQyxNQUFEO0FBQUEsZUFDSDtBQUFBO0FBQUE7QUFDRSxpQkFBS0EsT0FBT0MsRUFEZDtBQUVFO0FBQ0VDLHdCQUFVRixPQUFPRSxRQURuQjtBQUVFQyx1QkFBUztBQUZYO0FBRkY7QUFRRSxpREFBSyxPQUFPLEVBQUVDLE9BQU9KLE9BQU9JLEtBQWhCLEVBQVo7QUFSRixTQURHO0FBQUEsT0FEQSxDQUFQO0FBYUQ7Ozs2QkFFMkI7QUFDMUIsVUFBSSxLQUFLMUIsS0FBTCxDQUFXMkIsT0FBZixFQUF3QjtBQUN0QixlQUNFO0FBQUE7QUFBQSxZQUFLLG1DQUFMO0FBQ0U7QUFBQTtBQUFBLGNBQUssK0NBQUw7QUFDRSx3RUFBa0IsTUFBSyxPQUF2QjtBQURGO0FBREYsU0FERjtBQU9EOztBQUVELGFBQ0U7QUFBQTtBQUFBO0FBQ0UsNkNBREY7QUFFRSx1QkFBYSxDQUZmO0FBR0UsdUJBQWE7QUFIZjtBQUtFO0FBQUE7QUFBQTtBQUNFO0FBQUE7QUFBQTtBQUNHLGlCQUFLQyxjQUFMO0FBREg7QUFERixTQUxGO0FBVUU7QUFBQTtBQUFBO0FBQ0csZUFBS0MsZ0JBQUwsRUFESDtBQUVHLGVBQUtDLFdBQUwsRUFGSDtBQUdHLGVBQUtDLG1CQUFMO0FBSEg7QUFWRixPQURGO0FBa0JEOzs7Ozs7Ozs7Ozs7OztrQkE3R2tCbEMsdUI7Ozs7Ozs7O2dDQUFBQSx1QiIsImZpbGUiOiJTY3JvbGxpbmdUYWJsZUNvbnRhaW5lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcblxuaW1wb3J0IExvYWRpbmdJbmRpY2F0b3IgZnJvbSAnLi4vcHJvZ3Jlc3MtaW5kaWNhdG9ycy9Mb2FkaW5nSW5kaWNhdG9yJztcbmltcG9ydCBTY3JvbGxpbmdUYWJsZVJvdyBmcm9tICcuL1Njcm9sbGluZ1RhYmxlUm93JztcbmltcG9ydCBTY3JvbGxTdGF0ZSBmcm9tICcuL3JlY29yZHMvU2Nyb2xsU3RhdGUnO1xuaW1wb3J0IHsgSGVhZGVyLCBSb3dzIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHtcbiAgSEVBREVSX0NFTExfUExBQ0VIT0xERVJfU1RZTEVTLFxuICBMT0FESU5HX0lORElDQVRPUl9TVFlMRVMsXG4gIFRBQkxFX1NUWUxFUyxcbn0gZnJvbSAnLi9TY3JvbGxpbmdUYWJsZS5zdHlsZSc7XG5pbXBvcnQgdHlwZSB7IEhlYWRlcnMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGhlYWRlcnM6IEhlYWRlcnMsXG4gIGxvYWRpbmc6IGJvb2xlYW4sXG4gIHJvd0hlaWdodDogbnVtYmVyLFxuICByb3dzOiBSb3dzLFxuICBzY3JvbGxTdGF0ZTogU2Nyb2xsU3RhdGUsXG4gIHRvdGFsUm93czogbnVtYmVyLFxuICB2aWV3U2l6ZUluUm93czogbnVtYmVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsaW5nVGFibGVDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gIHByb3BzOiBQcm9wcztcblxuICBfZ2V0U3RhcnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wcm9wcy5zY3JvbGxTdGF0ZS5nZXQoJ29mZnNldCcpIC0gMSwgMCk7XG4gIH1cblxuICBfZ2V0RW5kKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBzY3JvbGxTdGF0ZSwgdmlld1NpemVJblJvd3MsIHRvdGFsUm93cyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gTWF0aC5taW4oc2Nyb2xsU3RhdGUuZ2V0KCdvZmZzZXQnKSArIHZpZXdTaXplSW5Sb3dzLCB0b3RhbFJvd3MpO1xuICB9XG5cbiAgX3JlbmRlclRvcE9mZnNldCgpOiA/UmVhY3QuRWxlbWVudDwqPiB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9nZXRTdGFydCgpO1xuICAgIGNvbnN0IHsgcm93SGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gPHRyIGtleT1cInN0YXJ0XCIgc3R5bGU9e3sgaGVpZ2h0OiBzdGFydCAqIHJvd0hlaWdodCB9fSAvPjtcbiAgfVxuXG4gIF9yZW5kZXJCb3R0b21PZmZzZXQoKTogP1JlYWN0LkVsZW1lbnQ8Kj4ge1xuICAgIGNvbnN0IHsgdG90YWxSb3dzLCByb3dIZWlnaHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0RW5kKCk7XG4gICAgaWYgKGVuZCA9PT0gdG90YWxSb3dzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gPHRyIGtleT1cImVuZFwiIHN0eWxlPXt7IGhlaWdodDogKHRvdGFsUm93cyAtIGVuZCkgKiByb3dIZWlnaHQgfX0gLz47XG4gIH1cblxuICBfcmVuZGVyUm93cygpOiBBcnJheTxSZWFjdC5FbGVtZW50PCo+PiB7XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuICAgIGNvbnN0IHsgcm93SGVpZ2h0LCB2aWV3U2l6ZUluUm93cyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2dldFN0YXJ0KCk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0RW5kKCk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMucHJvcHMucm93cy5nZXRJbihbYCR7aX1gLCAnZGF0YSddKTtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBrZXkgZnVuY3Rpb24gaXMgaW1wb3J0YW50LCBieSB0YWtpbmcgdGhlIG1vZHVsbyBvZlxuICAgICAgICogdGhlIGN1cnJlbnQgcm93IG51bWJlciBieSB0aGUgdmlldyBwb3J0IHNpemUgd2UgY2FuIGJlXG4gICAgICAgKiBhc3N1cmVkIHRoYXQgU2Nyb2xsaW5nVGFibGVSb3cgY29udGFpbmVycyBhcmUgcmVjeWNsZWQsXG4gICAgICAgKiBpbXByb3ZpbmcgcmVuZGVyIHBlcmYuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGtleSA9IGkgJSAodmlld1NpemVJblJvd3MgKyAxKTtcblxuICAgICAgcm93cy5wdXNoKFxuICAgICAgICA8U2Nyb2xsaW5nVGFibGVSb3dcbiAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICBoZWFkZXJzPXt0aGlzLnByb3BzLmhlYWRlcnN9XG4gICAgICAgICAgZGF0YT17ZGF0YSA9PSBudWxsID8gbmV3IExpc3QoKSA6IGRhdGF9XG4gICAgICAgICAgaGVpZ2h0PXtyb3dIZWlnaHR9XG4gICAgICAgICAgcm93TnVtYmVyPXtpfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIF9yZW5kZXJIZWFkZXJzKCk6IEFycmF5PFJlYWN0LkVsZW1lbnQ8Kj4+IHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5oZWFkZXJzLnZhbHVlU2VxKCkudG9BcnJheSgpXG4gICAgICAubWFwKChoZWFkZXI6IEhlYWRlcik6IFJlYWN0LkVsZW1lbnQ8Kj4gPT4gKFxuICAgICAgICA8dGhcbiAgICAgICAgICBrZXk9e2hlYWRlci5pZH1cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgbWluV2lkdGg6IGhlYWRlci5taW5XaWR0aCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAuLi5IRUFERVJfQ0VMTF9QTEFDRUhPTERFUl9TVFlMRVMsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IGhlYWRlci53aWR0aCB9fSAvPlxuICAgICAgICA8L3RoPlxuICAgICAgKSk7XG4gIH1cblxuICByZW5kZXIoKTogP1JlYWN0LkVsZW1lbnQ8Kj4ge1xuICAgIGlmICh0aGlzLnByb3BzLmxvYWRpbmcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e1RBQkxFX1NUWUxFU30+XG4gICAgICAgICAgPGRpdiBzdHlsZT17TE9BRElOR19JTkRJQ0FUT1JfU1RZTEVTfT5cbiAgICAgICAgICAgIDxMb2FkaW5nSW5kaWNhdG9yIHNpemU9XCJsYXJnZVwiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRhYmxlXG4gICAgICAgIHN0eWxlPXtUQUJMRV9TVFlMRVN9XG4gICAgICAgIGNlbGxQYWRkaW5nPXswfVxuICAgICAgICBjZWxsU3BhY2luZz17MH1cbiAgICAgID5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIHt0aGlzLl9yZW5kZXJIZWFkZXJzKCl9XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgIHt0aGlzLl9yZW5kZXJUb3BPZmZzZXQoKX1cbiAgICAgICAgICB7dGhpcy5fcmVuZGVyUm93cygpfVxuICAgICAgICAgIHt0aGlzLl9yZW5kZXJCb3R0b21PZmZzZXQoKX1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgKTtcbiAgfVxufVxuIl19