'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _desc, _value, _class2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _sortBy = require('lodash/sortBy');

var _sortBy2 = _interopRequireDefault(_sortBy);

var _Base = require('../base/Base');

var _propTypes = require('../utils/propTypes');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _CalendarPresets = require('./_CalendarPresets');

var _CalendarPresets2 = _interopRequireDefault(_CalendarPresets);

var _CalendarUtils = require('./_CalendarUtils');

var _CalendarPicker = require('./CalendarPicker');

var _CalendarPicker2 = _interopRequireDefault(_CalendarPicker);

var _CalendarPickerWithPresets = require('./CalendarPickerWithPresets.style');

var _CalendarPickerWithPresets2 = _interopRequireDefault(_CalendarPickerWithPresets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * subtracting here to make sure second calendar is one showing the selected date range,
 * e.g., I pick last month with today being 3/1/2015, the date picker would be set to show
 * Feb as calendar two which requires us to set the datepicker date to Jan or Feb - 1 month
 */
function getPrevMonthAsMoment(date) {
  return (0, _moment2.default)(date).subtract(1, 'month');
}

function getPresetFromKey(presetKey) {
  return _CalendarUtils.DATE_RANGE_PRESETS.filter(function (preset) {
    return preset.key === presetKey;
  })[0];
}

function getDateForCalPicker(_ref) {
  var presetKey = _ref.presetKey,
      range = _ref.range;

  var preset = getPresetFromKey(presetKey);
  // for presets other than 'custom', preset.endDate will be a real date, but if user's picked a
  // custom range, we want to use their selected endDate and not the preset default, which is
  // today's date
  return getPrevMonthAsMoment(preset.key !== 'custom' ? preset.endDate : range[1]);
}

function getStateFromProps(props) {
  var preset = getPresetFromKey(props.presetKey);
  var range = props.range || [preset.startDate, preset.endDate];
  return {
    presetKey: preset.key,
    range: range
  };
}

function getSortedDates() {
  for (var _len = arguments.length, dates = Array(_len), _key = 0; _key < _len; _key++) {
    dates[_key] = arguments[_key];
  }

  return (0, _sortBy2.default)([].concat(dates), function (obj) {
    return obj.unix();
  });
}

var TxlCalendarPickerWithPresets = (0, _radium2.default)(_class = (_class2 = function (_React$Component) {
  (0, _inherits3.default)(TxlCalendarPickerWithPresets, _React$Component);

  function TxlCalendarPickerWithPresets() {
    var _ref2;

    (0, _classCallCheck3.default)(this, TxlCalendarPickerWithPresets);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref2 = TxlCalendarPickerWithPresets.__proto__ || (0, _getPrototypeOf2.default)(TxlCalendarPickerWithPresets)).call.apply(_ref2, [this].concat(args)));

    var initialState = getStateFromProps(_this.props);
    _this.state = (0, _extends3.default)({}, initialState, {
      date: getDateForCalPicker(initialState)
    });
    _this._firstClick = null;
    return _this;
  }

  (0, _createClass3.default)(TxlCalendarPickerWithPresets, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      this.setState(getStateFromProps(newProps));
    }
  }, {
    key: '_handleDateClick',
    value: function _handleDateClick(_ref3) {
      var date = _ref3.date;

      var range = void 0;

      if (!this.state.findMode) {
        // first date select
        range = [date, date];
        this._firstClick = date;
      } else {
        // second date select
        var onDateSelect = this.props.onDateSelect;


        range = getSortedDates(this._firstClick, date);
        this._firstClick = null;

        onDateSelect({
          endDate: range[1],
          presetKey: this.state.presetKey,
          startDate: range[0]
        });
      }

      this.setState({
        findMode: !this.state.findMode,
        presetKey: 'custom',
        range: range
      });
    }
  }, {
    key: '_handleHoverUpdate',
    value: function _handleHoverUpdate(_ref4) {
      var date = _ref4.date;

      if (this.state.findMode) {
        this.setState({
          range: getSortedDates(this._firstClick, date || this._firstClick // handleCase where null cell hovered
          )
        });
      }
    }
  }, {
    key: '_handleNextClick',
    value: function _handleNextClick() {
      this.setState({ date: (0, _moment2.default)(this.state.date).add(1, 'month') });
    }
  }, {
    key: '_handlePrevClick',
    value: function _handlePrevClick() {
      this.setState({ date: (0, _moment2.default)(this.state.date).subtract(1, 'month') });
    }
  }, {
    key: '_handlePresetSelect',
    value: function _handlePresetSelect(_ref5) {
      var _this2 = this;

      var presetKey = _ref5.key,
          preset = _ref5.preset;
      var endDate = preset.endDate,
          startDate = preset.startDate;

      var newState = {
        findMode: false,
        presetKey: presetKey
      };

      if (presetKey === 'custom') {
        // Clicking 'Custom' preset shouldn't update selected date or trigger date select handler,
        // but we still need to update the selected preset value
        this.setState(newState);
      } else {
        // update
        this.setState((0, _extends3.default)({}, newState, {
          date: getPrevMonthAsMoment(endDate),
          range: [startDate, endDate]
        }), function () {
          return _this2.props.onDateSelect({
            endDate: endDate,
            presetKey: presetKey,
            startDate: startDate
          });
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          date = _state.date,
          findMode = _state.findMode,
          presetKey = _state.presetKey,
          range = _state.range;
      var _props = this.props,
          outOfRangeTooltip = _props.outOfRangeTooltip,
          rangeEndBoundary = _props.rangeEndBoundary,
          rangeStartBoundary = _props.rangeStartBoundary;


      return _react2.default.createElement(
        'div',
        {
          'data-component': 'TxlCalendarPickerWithPresets',
          style: _CalendarPickerWithPresets2.default.container
        },
        _react2.default.createElement(
          'div',
          { style: _CalendarPickerWithPresets2.default.presets },
          _react2.default.createElement(_CalendarPresets2.default, {
            onSelect: this._handlePresetSelect,
            presets: _CalendarUtils.DATE_RANGE_PRESETS,
            ref: 'calPresets',
            selectedKey: presetKey
          })
        ),
        _react2.default.createElement(
          'div',
          { style: _CalendarPickerWithPresets2.default.picker },
          _react2.default.createElement(_CalendarPicker2.default, {
            date: date,
            findMode: findMode,
            onDateClick: this._handleDateClick,
            onHoverUpdate: this._handleHoverUpdate,
            onNextClick: this._handleNextClick,
            onPrevClick: this._handlePrevClick,
            outOfRangeTooltip: outOfRangeTooltip,
            range: range,
            rangeEndBoundary: rangeEndBoundary,
            rangeStartBoundary: rangeStartBoundary,
            ref: 'calPicker'
          })
        )
      );
    }
  }]);
  return TxlCalendarPickerWithPresets;
}(_react2.default.Component), (_applyDecoratedDescriptor(_class2.prototype, '_handleDateClick', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleDateClick'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handleHoverUpdate', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleHoverUpdate'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handleNextClick', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handleNextClick'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handlePrevClick', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handlePrevClick'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_handlePresetSelect', [_Base.autobind], (0, _getOwnPropertyDescriptor2.default)(_class2.prototype, '_handlePresetSelect'), _class2.prototype)), _class2)) || _class;

exports.default = TxlCalendarPickerWithPresets;


TxlCalendarPickerWithPresets.propTypes = {
  onDateSelect: _react.PropTypes.func.isRequired,
  outOfRangeTooltip: _CalendarPicker2.default.propTypes.outOfRangeTooltip,
  presetKey: _react.PropTypes.oneOf(_CalendarUtils.DATE_RANGE_PRESETS.map(function (preset) {
    return preset.key;
  })),
  range: _propTypes2.default.dateRange,
  rangeEndBoundary: _CalendarPicker2.default.propTypes.rangeEndBoundary,
  rangeStartBoundary: _CalendarPicker2.default.propTypes.rangeStartBoundary
};

TxlCalendarPickerWithPresets.defaultProps = {
  presetKey: 'last7Days'
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(getPrevMonthAsMoment, 'getPrevMonthAsMoment', 'src/calendar-picker/CalendarPickerWithPresets.jsx');

  __REACT_HOT_LOADER__.register(getPresetFromKey, 'getPresetFromKey', 'src/calendar-picker/CalendarPickerWithPresets.jsx');

  __REACT_HOT_LOADER__.register(getDateForCalPicker, 'getDateForCalPicker', 'src/calendar-picker/CalendarPickerWithPresets.jsx');

  __REACT_HOT_LOADER__.register(getStateFromProps, 'getStateFromProps', 'src/calendar-picker/CalendarPickerWithPresets.jsx');

  __REACT_HOT_LOADER__.register(getSortedDates, 'getSortedDates', 'src/calendar-picker/CalendarPickerWithPresets.jsx');

  __REACT_HOT_LOADER__.register(TxlCalendarPickerWithPresets, 'TxlCalendarPickerWithPresets', 'src/calendar-picker/CalendarPickerWithPresets.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jYWxlbmRhci1waWNrZXIvQ2FsZW5kYXJQaWNrZXJXaXRoUHJlc2V0cy5qc3giXSwibmFtZXMiOlsiZ2V0UHJldk1vbnRoQXNNb21lbnQiLCJkYXRlIiwic3VidHJhY3QiLCJnZXRQcmVzZXRGcm9tS2V5IiwicHJlc2V0S2V5IiwiZmlsdGVyIiwicHJlc2V0Iiwia2V5IiwiZ2V0RGF0ZUZvckNhbFBpY2tlciIsInJhbmdlIiwiZW5kRGF0ZSIsImdldFN0YXRlRnJvbVByb3BzIiwicHJvcHMiLCJzdGFydERhdGUiLCJnZXRTb3J0ZWREYXRlcyIsImRhdGVzIiwib2JqIiwidW5peCIsIlR4bENhbGVuZGFyUGlja2VyV2l0aFByZXNldHMiLCJhcmdzIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJfZmlyc3RDbGljayIsIm5ld1Byb3BzIiwic2V0U3RhdGUiLCJmaW5kTW9kZSIsIm9uRGF0ZVNlbGVjdCIsImFkZCIsIm5ld1N0YXRlIiwib3V0T2ZSYW5nZVRvb2x0aXAiLCJyYW5nZUVuZEJvdW5kYXJ5IiwicmFuZ2VTdGFydEJvdW5kYXJ5IiwiY29udGFpbmVyIiwicHJlc2V0cyIsIl9oYW5kbGVQcmVzZXRTZWxlY3QiLCJwaWNrZXIiLCJfaGFuZGxlRGF0ZUNsaWNrIiwiX2hhbmRsZUhvdmVyVXBkYXRlIiwiX2hhbmRsZU5leHRDbGljayIsIl9oYW5kbGVQcmV2Q2xpY2siLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIm9uZU9mIiwibWFwIiwiZGF0ZVJhbmdlIiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7QUFLQSxTQUFTQSxv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U0FBZixDQUF5QlgsZ0JBTEo7QUFNdkNDLHNCQUFvQix5QkFBZVUsU0FBZixDQUF5QlY7QUFOTixDQUF6Qzs7QUFTQWIsNkJBQTZCNkIsWUFBN0IsR0FBNEM7QUFDMUMzQyxhQUFXO0FBRCtCLENBQTVDOzs7Ozs7OztnQ0F4TFNKLG9COztnQ0FJQUcsZ0I7O2dDQUlBSyxtQjs7Z0NBUUFHLGlCOztnQ0FTQUcsYzs7Z0NBS1lJLDRCIiwiZmlsZSI6IkNhbGVuZGFyUGlja2VyV2l0aFByZXNldHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IFJhZGl1bSBmcm9tICdyYWRpdW0nO1xuaW1wb3J0IHNvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JztcblxuaW1wb3J0IHsgYXV0b2JpbmQgfSBmcm9tICcuLi9iYXNlL0Jhc2UnO1xuaW1wb3J0IFR4bFByb3BUeXBlcyBmcm9tICcuLi91dGlscy9wcm9wVHlwZXMnO1xuaW1wb3J0IENhbGVuZGFyUHJlc2V0cyBmcm9tICcuL19DYWxlbmRhclByZXNldHMnO1xuaW1wb3J0IHsgREFURV9SQU5HRV9QUkVTRVRTIH0gZnJvbSAnLi9fQ2FsZW5kYXJVdGlscyc7XG5pbXBvcnQgQ2FsZW5kYXJQaWNrZXIgZnJvbSAnLi9DYWxlbmRhclBpY2tlcic7XG5pbXBvcnQgU1RZTEUgZnJvbSAnLi9DYWxlbmRhclBpY2tlcldpdGhQcmVzZXRzLnN0eWxlJztcblxuLyoqXG4gKiBzdWJ0cmFjdGluZyBoZXJlIHRvIG1ha2Ugc3VyZSBzZWNvbmQgY2FsZW5kYXIgaXMgb25lIHNob3dpbmcgdGhlIHNlbGVjdGVkIGRhdGUgcmFuZ2UsXG4gKiBlLmcuLCBJIHBpY2sgbGFzdCBtb250aCB3aXRoIHRvZGF5IGJlaW5nIDMvMS8yMDE1LCB0aGUgZGF0ZSBwaWNrZXIgd291bGQgYmUgc2V0IHRvIHNob3dcbiAqIEZlYiBhcyBjYWxlbmRhciB0d28gd2hpY2ggcmVxdWlyZXMgdXMgdG8gc2V0IHRoZSBkYXRlcGlja2VyIGRhdGUgdG8gSmFuIG9yIEZlYiAtIDEgbW9udGhcbiAqL1xuZnVuY3Rpb24gZ2V0UHJldk1vbnRoQXNNb21lbnQoZGF0ZSkge1xuICByZXR1cm4gbW9tZW50KGRhdGUpLnN1YnRyYWN0KDEsICdtb250aCcpO1xufVxuXG5mdW5jdGlvbiBnZXRQcmVzZXRGcm9tS2V5KHByZXNldEtleSkge1xuICByZXR1cm4gREFURV9SQU5HRV9QUkVTRVRTLmZpbHRlcihwcmVzZXQgPT4gcHJlc2V0LmtleSA9PT0gcHJlc2V0S2V5KVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZUZvckNhbFBpY2tlcih7IHByZXNldEtleSwgcmFuZ2UgfSkge1xuICBjb25zdCBwcmVzZXQgPSBnZXRQcmVzZXRGcm9tS2V5KHByZXNldEtleSk7XG4gIC8vIGZvciBwcmVzZXRzIG90aGVyIHRoYW4gJ2N1c3RvbScsIHByZXNldC5lbmREYXRlIHdpbGwgYmUgYSByZWFsIGRhdGUsIGJ1dCBpZiB1c2VyJ3MgcGlja2VkIGFcbiAgLy8gY3VzdG9tIHJhbmdlLCB3ZSB3YW50IHRvIHVzZSB0aGVpciBzZWxlY3RlZCBlbmREYXRlIGFuZCBub3QgdGhlIHByZXNldCBkZWZhdWx0LCB3aGljaCBpc1xuICAvLyB0b2RheSdzIGRhdGVcbiAgcmV0dXJuIGdldFByZXZNb250aEFzTW9tZW50KHByZXNldC5rZXkgIT09ICdjdXN0b20nID8gcHJlc2V0LmVuZERhdGUgOiByYW5nZVsxXSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHByZXNldCA9IGdldFByZXNldEZyb21LZXkocHJvcHMucHJlc2V0S2V5KTtcbiAgY29uc3QgcmFuZ2UgPSBwcm9wcy5yYW5nZSB8fCBbcHJlc2V0LnN0YXJ0RGF0ZSwgcHJlc2V0LmVuZERhdGVdO1xuICByZXR1cm4ge1xuICAgIHByZXNldEtleTogcHJlc2V0LmtleSxcbiAgICByYW5nZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0ZXMoLi4uZGF0ZXMpIHtcbiAgcmV0dXJuIHNvcnRCeShbLi4uZGF0ZXNdLCBvYmogPT4gb2JqLnVuaXgoKSk7XG59XG5cbkBSYWRpdW1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR4bENhbGVuZGFyUGlja2VyV2l0aFByZXNldHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGdldFN0YXRlRnJvbVByb3BzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgICBkYXRlOiBnZXREYXRlRm9yQ2FsUGlja2VyKGluaXRpYWxTdGF0ZSksXG4gICAgfTtcbiAgICB0aGlzLl9maXJzdENsaWNrID0gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKGdldFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzKSk7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2hhbmRsZURhdGVDbGljayh7IGRhdGUgfSkge1xuICAgIGxldCByYW5nZTtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5maW5kTW9kZSkge1xuICAgICAgLy8gZmlyc3QgZGF0ZSBzZWxlY3RcbiAgICAgIHJhbmdlID0gW2RhdGUsIGRhdGVdO1xuICAgICAgdGhpcy5fZmlyc3RDbGljayA9IGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNlY29uZCBkYXRlIHNlbGVjdFxuICAgICAgY29uc3QgeyBvbkRhdGVTZWxlY3QgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHJhbmdlID0gZ2V0U29ydGVkRGF0ZXModGhpcy5fZmlyc3RDbGljaywgZGF0ZSk7XG4gICAgICB0aGlzLl9maXJzdENsaWNrID0gbnVsbDtcblxuICAgICAgb25EYXRlU2VsZWN0KHtcbiAgICAgICAgZW5kRGF0ZTogcmFuZ2VbMV0sXG4gICAgICAgIHByZXNldEtleTogdGhpcy5zdGF0ZS5wcmVzZXRLZXksXG4gICAgICAgIHN0YXJ0RGF0ZTogcmFuZ2VbMF0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbmRNb2RlOiAhdGhpcy5zdGF0ZS5maW5kTW9kZSxcbiAgICAgIHByZXNldEtleTogJ2N1c3RvbScsXG4gICAgICByYW5nZSxcbiAgICB9KTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBfaGFuZGxlSG92ZXJVcGRhdGUoeyBkYXRlIH0pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5maW5kTW9kZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHJhbmdlOiBnZXRTb3J0ZWREYXRlcyhcbiAgICAgICAgICB0aGlzLl9maXJzdENsaWNrLFxuICAgICAgICAgIGRhdGUgfHwgdGhpcy5fZmlyc3RDbGljayAvLyBoYW5kbGVDYXNlIHdoZXJlIG51bGwgY2VsbCBob3ZlcmVkXG4gICAgICAgICksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgX2hhbmRsZU5leHRDbGljaygpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZGF0ZTogbW9tZW50KHRoaXMuc3RhdGUuZGF0ZSkuYWRkKDEsICdtb250aCcpIH0pO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9oYW5kbGVQcmV2Q2xpY2soKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGRhdGU6IG1vbWVudCh0aGlzLnN0YXRlLmRhdGUpLnN1YnRyYWN0KDEsICdtb250aCcpIH0pO1xuICB9XG5cbiAgQGF1dG9iaW5kXG4gIF9oYW5kbGVQcmVzZXRTZWxlY3QoeyBrZXk6IHByZXNldEtleSwgcHJlc2V0IH0pIHtcbiAgICBjb25zdCB7IGVuZERhdGUsIHN0YXJ0RGF0ZSB9ID0gcHJlc2V0O1xuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgZmluZE1vZGU6IGZhbHNlLFxuICAgICAgcHJlc2V0S2V5LFxuICAgIH07XG5cbiAgICBpZiAocHJlc2V0S2V5ID09PSAnY3VzdG9tJykge1xuICAgICAgLy8gQ2xpY2tpbmcgJ0N1c3RvbScgcHJlc2V0IHNob3VsZG4ndCB1cGRhdGUgc2VsZWN0ZWQgZGF0ZSBvciB0cmlnZ2VyIGRhdGUgc2VsZWN0IGhhbmRsZXIsXG4gICAgICAvLyBidXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGVkIHByZXNldCB2YWx1ZVxuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBkYXRlOiBnZXRQcmV2TW9udGhBc01vbWVudChlbmREYXRlKSxcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLnByb3BzLm9uRGF0ZVNlbGVjdCh7XG4gICAgICAgIGVuZERhdGUsXG4gICAgICAgIHByZXNldEtleSxcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRlLFxuICAgICAgZmluZE1vZGUsXG4gICAgICBwcmVzZXRLZXksXG4gICAgICByYW5nZSxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IHtcbiAgICAgIG91dE9mUmFuZ2VUb29sdGlwLFxuICAgICAgcmFuZ2VFbmRCb3VuZGFyeSxcbiAgICAgIHJhbmdlU3RhcnRCb3VuZGFyeSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGRhdGEtY29tcG9uZW50PVwiVHhsQ2FsZW5kYXJQaWNrZXJXaXRoUHJlc2V0c1wiXG4gICAgICAgIHN0eWxlPXtTVFlMRS5jb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIDxkaXYgc3R5bGU9e1NUWUxFLnByZXNldHN9PlxuICAgICAgICAgIDxDYWxlbmRhclByZXNldHNcbiAgICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLl9oYW5kbGVQcmVzZXRTZWxlY3R9XG4gICAgICAgICAgICBwcmVzZXRzPXtEQVRFX1JBTkdFX1BSRVNFVFN9XG4gICAgICAgICAgICByZWY9XCJjYWxQcmVzZXRzXCJcbiAgICAgICAgICAgIHNlbGVjdGVkS2V5PXtwcmVzZXRLZXl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9e1NUWUxFLnBpY2tlcn0+XG4gICAgICAgICAgPENhbGVuZGFyUGlja2VyXG4gICAgICAgICAgICBkYXRlPXtkYXRlfVxuICAgICAgICAgICAgZmluZE1vZGU9e2ZpbmRNb2RlfVxuICAgICAgICAgICAgb25EYXRlQ2xpY2s9e3RoaXMuX2hhbmRsZURhdGVDbGlja31cbiAgICAgICAgICAgIG9uSG92ZXJVcGRhdGU9e3RoaXMuX2hhbmRsZUhvdmVyVXBkYXRlfVxuICAgICAgICAgICAgb25OZXh0Q2xpY2s9e3RoaXMuX2hhbmRsZU5leHRDbGlja31cbiAgICAgICAgICAgIG9uUHJldkNsaWNrPXt0aGlzLl9oYW5kbGVQcmV2Q2xpY2t9XG4gICAgICAgICAgICBvdXRPZlJhbmdlVG9vbHRpcD17b3V0T2ZSYW5nZVRvb2x0aXB9XG4gICAgICAgICAgICByYW5nZT17cmFuZ2V9XG4gICAgICAgICAgICByYW5nZUVuZEJvdW5kYXJ5PXtyYW5nZUVuZEJvdW5kYXJ5fVxuICAgICAgICAgICAgcmFuZ2VTdGFydEJvdW5kYXJ5PXtyYW5nZVN0YXJ0Qm91bmRhcnl9XG4gICAgICAgICAgICByZWY9XCJjYWxQaWNrZXJcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5UeGxDYWxlbmRhclBpY2tlcldpdGhQcmVzZXRzLnByb3BUeXBlcyA9IHtcbiAgb25EYXRlU2VsZWN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvdXRPZlJhbmdlVG9vbHRpcDogQ2FsZW5kYXJQaWNrZXIucHJvcFR5cGVzLm91dE9mUmFuZ2VUb29sdGlwLFxuICBwcmVzZXRLZXk6IFByb3BUeXBlcy5vbmVPZihEQVRFX1JBTkdFX1BSRVNFVFMubWFwKHByZXNldCA9PiBwcmVzZXQua2V5KSksXG4gIHJhbmdlOiBUeGxQcm9wVHlwZXMuZGF0ZVJhbmdlLFxuICByYW5nZUVuZEJvdW5kYXJ5OiBDYWxlbmRhclBpY2tlci5wcm9wVHlwZXMucmFuZ2VFbmRCb3VuZGFyeSxcbiAgcmFuZ2VTdGFydEJvdW5kYXJ5OiBDYWxlbmRhclBpY2tlci5wcm9wVHlwZXMucmFuZ2VTdGFydEJvdW5kYXJ5LFxufTtcblxuVHhsQ2FsZW5kYXJQaWNrZXJXaXRoUHJlc2V0cy5kZWZhdWx0UHJvcHMgPSB7XG4gIHByZXNldEtleTogJ2xhc3Q3RGF5cycsXG59O1xuIl19