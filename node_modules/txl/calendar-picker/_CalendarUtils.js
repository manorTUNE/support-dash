'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeObjFromMoment = exports.stringToTimeObj = exports.momentToDate = exports.isValidDateRange = exports.isTimeWithinRange = exports.isMonthPartOfRange = exports.isDateWithinRange = exports.getPrevHalfHour = exports.getNextHalfHour = exports.dateToMoment = exports.dateStringToMoment = exports.DATE_RANGE_PRESETS = exports.buildTimeIntervalOptions = undefined;

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _TimeZones = require('../constants/_TimeZones');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Map UTC date string to moment instance
 *
 * @param {String} date - UTC-formatted date string (@TODO: validate pattern of arg)
 * @returns {(moment|boolean)}
 */
function dateStringToMoment(date) {
  // already a valid moment
  if (date.isValid && date.isValid()) return date;
  // try to instantiate a new moment
  return typeof date === 'string' && (0, _moment2.default)(date).isValid() ? (0, _moment2.default)(date) : null;
}

function dateToMoment(date) {
  var momentDate = date;
  if (!date || date && !date._isAMomentObject) {
    momentDate = (0, _moment2.default)(date);
  }
  return momentDate;
}

/**
 * Are dates valid and does start come before end?
 *
 * @param {moment} momentStart
 * @param {moment} momentEnd
 * @returns {Boolean}
 */
function isValidDateRange(momentStart, momentEnd) {
  var start = dateToMoment(momentStart);
  var end = dateToMoment(momentEnd);
  return start && end && start.isValid() && end.isValid() && start.isSameOrBefore(end);
}

/**
 * Is date within provided boundaries? (exclusive)
 * @param {moment} date
 * @param {moment} rangeStart
 * @param {moment} rangeEnd
 * @param {Boolean} [useTimes] - Respect times of rangeStart/End moments or only compare dates
 * @returns {Boolean}
 */
function isDateWithinRange(date, rangeStart, rangeEnd) {
  var useTimes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var formattedRangeStart = rangeStart;
  var formattedRangeEnd = rangeEnd;

  if (!useTimes) {
    formattedRangeStart = rangeStart && rangeStart.clone().startOf('day');
    formattedRangeEnd = rangeEnd && rangeEnd.clone().endOf('day');
  }

  var isAfterStart = formattedRangeStart ? date.isSameOrAfter(formattedRangeStart) : true;
  var isBeforeEnd = formattedRangeEnd ? date.isSameOrBefore(formattedRangeEnd) : true;

  return isAfterStart && isBeforeEnd;
}

/**
 * Verify time (not date) falls within provided range
 *
 * @param time {TimeObject}
 * @param rangeStart {TimeObject}
 * @param rangeEnd {TimeObject}
 * @returns {Boolean}
 */
function isTimeWithinRange(time, rangeStart, rangeEnd) {
  // missing boundary param means we can't really check range
  if (!rangeStart || !rangeEnd) return false;
  return (0, _moment2.default)(time).isBetween((0, _moment2.default)(rangeStart), (0, _moment2.default)(rangeEnd), null, '[]');
}

/**
 * Map moment obj to `{ hour: 20, minute: 15, second: 30 }` format
 *
 * @param time {moment}
 * @returns {TimeObject}
 */
function timeObjFromMoment(time) {
  return {
    hour: time.hour(),
    minute: time.minute(),
    second: time.second()
  };
}

/**
 * Round down time by a half hour
 * @param obj
 * @param obj.time {moment}
 * @param obj.pattern {String} - Format pattern used by moment
 * @returns {String} - Formatted date string
 */
function getPrevHalfHour(_ref) {
  var _ref$time = _ref.time,
      time = _ref$time === undefined ? (0, _moment2.default)() : _ref$time,
      pattern = _ref.pattern;

  return time.clone().set({
    millisecond: 0,
    minutes: time.minutes() >= 30 ? 30 : 0
  }).format(pattern);
}

/**
 * Round up time by a half hour
 * @param obj
 * @param obj.time {moment}
 * @param obj.pattern {String} - Format pattern used by moment
 * @returns {String} - Formatted date string
 */
function getNextHalfHour(_ref2) {
  var _ref2$time = _ref2.time,
      time = _ref2$time === undefined ? (0, _moment2.default)() : _ref2$time,
      pattern = _ref2.pattern;

  return time.clone().set({
    millisecond: 0,
    minutes: time.minutes() >= 30 ? 0 : 30
  })
  // need to bump hour if rounding up
  .add(time.minutes() >= 30 ? 1 : 0, 'h').format(pattern);
}

/**
 * A config obj used to define date ranges used in calendars, et al.
 *
 * @typedef {Object} TimeObject
 * @property {Number} hour - Hour between 0-23
 * @property {Number} minute - Minute between 0-59
 */

/**
 * Create array of time option objects for use in dropdowns
 *
 * @param {TimeObject} [boundaryEnd]
 * @param {TimeObject} [boundaryStart]
 * @param {Number} [interval] - Number of minutes between options
 * @param {String} [pattern] - moment-recognized formatting pattern
 * @returns {Object[]} - Array of objects w/ shape: { hour, minute, second, label, value }
 */
function buildTimeIntervalOptions(_ref3) {
  var _ref3$boundaryEnd = _ref3.boundaryEnd,
      boundaryEnd = _ref3$boundaryEnd === undefined ? { hour: 23, minute: 59, second: 59 } : _ref3$boundaryEnd,
      _ref3$boundaryStart = _ref3.boundaryStart,
      boundaryStart = _ref3$boundaryStart === undefined ? { hour: 0, minute: 0, second: 0 } : _ref3$boundaryStart,
      _ref3$interval = _ref3.interval,
      interval = _ref3$interval === undefined ? 30 : _ref3$interval,
      _ref3$pattern = _ref3.pattern,
      pattern = _ref3$pattern === undefined ? _TimeZones.DEFAULT_TIME_PATTERN : _ref3$pattern;

  var ret = [];
  // seconds will always equal zero for default options
  var second = 0;
  for (var hour = boundaryStart.hour; hour <= boundaryEnd.hour; hour++) {
    for (var minute = 0; minute < 60; minute += interval) {
      if (isTimeWithinRange({ hour: hour, minute: minute, second: second }, boundaryStart, boundaryEnd)) {
        var option = (0, _moment2.default)({ hour: hour, minute: minute, second: second }).format(pattern);
        ret.push({
          hour: hour,
          label: option,
          minute: minute,
          second: second,
          value: option
        });
      }
    }
  }
  return ret;
}

/**
 * Does the date provided fall within the months of the range, even if the date itself does not,
 * e.g., `isMonthPartOfRange(<Jan 02, 2016>, <Jan 15, 2016>, <March 15, 2016>)` returns true
 *
 * @param date {moment}
 * @param rangeStart {moment}
 * @param rangeEnd {moment}
 * @returns {Boolean}
 */
function isMonthPartOfRange(date, rangeStart, rangeEnd) {
  // no boundaries means date is valid
  if (!rangeStart || !rangeEnd) return true;
  return isDateWithinRange(date, rangeStart, rangeEnd)
  // date may be out of range, but within same month
  || date.isSame(rangeStart, 'month') || date.isSame(rangeEnd, 'month');
}

function momentToDate(momentDate) {
  if (momentDate && momentDate._isAMomentObject) {
    return momentDate.toDate();
  }
  return momentDate;
}

/**
 * Convert formatted time string to { hour: 1, minute: 11, second: 59 }
 *
 * @param {String} time - Formatted time, e.g., "02:13:00 PM"
 * @param {String} pattern - moment pattern for displaying/parsing time, e.g., 'hh:mma'
 * @returns {TimeObject|boolean} - Returns false if time string is invalid
 */
function stringToTimeObj(time, pattern) {
  var timeMoment = (0, _moment2.default)(time, pattern, true);
  return timeMoment.isValid() && {
    hour: timeMoment.hour(),
    minute: timeMoment.minute(),
    second: timeMoment.second()
  };
}

/**
 * A config obj used to define date ranges used in calendars, et al.
 *
 * @typedef {Object} DateRangePreset
 * @property {String} key - ID for preset
 * @property {String} label - Nice name for user (@TODO should probably be translated)
 * @property {moment} startDate - Start date in range
 * @property {moment} endDate - End date in range
 */

/**
 * Collection of date range presets
 * @type {DateRangePreset[]}
 */
var DATE_RANGE_PRESETS = [{
  endDate: (0, _moment2.default)().endOf('day'),
  key: 'today',
  label: 'Today',
  startDate: (0, _moment2.default)().startOf('day')
}, {
  endDate: (0, _moment2.default)().endOf('day').subtract(1, 'day'),
  key: 'yesterday',
  label: 'Yesterday',
  startDate: (0, _moment2.default)().startOf('day').subtract(1, 'day')
}, {
  endDate: (0, _moment2.default)().endOf('day').subtract(1, 'day'),
  key: 'last7Days',
  label: 'Last 7 Days',
  startDate: (0, _moment2.default)().startOf('day').subtract(7, 'day')
}, {
  endDate: (0, _moment2.default)().subtract(1, 'week').endOf('week'),
  key: 'prevWeek',
  label: 'Previous Week',
  startDate: (0, _moment2.default)().subtract(1, 'week').startOf('week')
}, {
  endDate: (0, _moment2.default)().endOf('day'),
  key: 'monthToDate',
  label: 'Month to Date',
  startDate: (0, _moment2.default)().startOf('month')
}, {
  endDate: (0, _moment2.default)().endOf('day').subtract(1, 'day'),
  key: 'last30Days',
  label: 'Last 30 Days',
  startDate: (0, _moment2.default)().startOf('day').subtract(30, 'day')
}, {
  endDate: (0, _moment2.default)().subtract(1, 'month').endOf('month'),
  key: 'lastMonth',
  label: 'Last Month',
  startDate: (0, _moment2.default)().subtract(1, 'month').startOf('month')
}, {
  endDate: (0, _moment2.default)().endOf('day'),
  key: 'custom',
  label: 'Custom',
  startDate: (0, _moment2.default)().startOf('day')
}];

exports.buildTimeIntervalOptions = buildTimeIntervalOptions;
exports.DATE_RANGE_PRESETS = DATE_RANGE_PRESETS;
exports.dateStringToMoment = dateStringToMoment;
exports.dateToMoment = dateToMoment;
exports.getNextHalfHour = getNextHalfHour;
exports.getPrevHalfHour = getPrevHalfHour;
exports.isDateWithinRange = isDateWithinRange;
exports.isMonthPartOfRange = isMonthPartOfRange;
exports.isTimeWithinRange = isTimeWithinRange;
exports.isValidDateRange = isValidDateRange;
exports.momentToDate = momentToDate;
exports.stringToTimeObj = stringToTimeObj;
exports.timeObjFromMoment = timeObjFromMoment;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(dateStringToMoment, 'dateStringToMoment', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(dateToMoment, 'dateToMoment', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(isValidDateRange, 'isValidDateRange', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(isDateWithinRange, 'isDateWithinRange', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(isTimeWithinRange, 'isTimeWithinRange', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(timeObjFromMoment, 'timeObjFromMoment', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(getPrevHalfHour, 'getPrevHalfHour', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(getNextHalfHour, 'getNextHalfHour', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(buildTimeIntervalOptions, 'buildTimeIntervalOptions', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(isMonthPartOfRange, 'isMonthPartOfRange', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(momentToDate, 'momentToDate', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(stringToTimeObj, 'stringToTimeObj', 'src/calendar-picker/_CalendarUtils.js');

  __REACT_HOT_LOADER__.register(DATE_RANGE_PRESETS, 'DATE_RANGE_PRESETS', 'src/calendar-picker/_CalendarUtils.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jYWxlbmRhci1waWNrZXIvX0NhbGVuZGFyVXRpbHMuanMiXSwibmFtZXMiOlsiZGF0ZVN0cmluZ1RvTW9tZW50IiwiZGF0ZSIsImlzVmFsaWQiLCJkYXRlVG9Nb21lbnQiLCJtb21lbnREYXRlIiwiX2lzQU1vbWVudE9iamVjdCIsImlzVmFsaWREYXRlUmFuZ2UiLCJtb21lbnRTdGFydCIsIm1vbWVudEVuZCIsInN0YXJ0IiwiZW5kIiwiaXNTYW1lT3JCZWZvcmUiLCJpc0RhdGVXaXRoaW5SYW5nZSIsInJhbmdlU3RhcnQiLCJyYW5nZUVuZCIsInVzZVRpbWVzIiwiZm9ybWF0dGVkUmFuZ2VTdGFydCIsImZvcm1hdHRlZFJhbmdlRW5kIiwiY2xvbmUiLCJzdGFydE9mIiwiZW5kT2YiLCJpc0FmdGVyU3RhcnQiLCJpc1NhbWVPckFmdGVyIiwiaXNCZWZvcmVFbmQiLCJpc1RpbWVXaXRoaW5SYW5nZSIsInRpbWUiLCJpc0JldHdlZW4iLCJ0aW1lT2JqRnJvbU1vbWVudCIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJnZXRQcmV2SGFsZkhvdXIiLCJwYXR0ZXJuIiwic2V0IiwibWlsbGlzZWNvbmQiLCJtaW51dGVzIiwiZm9ybWF0IiwiZ2V0TmV4dEhhbGZIb3VyIiwiYWRkIiwiYnVpbGRUaW1lSW50ZXJ2YWxPcHRpb25zIiwiYm91bmRhcnlFbmQiLCJib3VuZGFyeVN0YXJ0IiwiaW50ZXJ2YWwiLCJyZXQiLCJvcHRpb24iLCJwdXNoIiwibGFiZWwiLCJ2YWx1ZSIsImlzTW9udGhQYXJ0T2ZSYW5nZSIsImlzU2FtZSIsIm1vbWVudFRvRGF0ZSIsInRvRGF0ZSIsInN0cmluZ1RvVGltZU9iaiIsInRpbWVNb21lbnQiLCJEQVRFX1JBTkdFX1BSRVNFVFMiLCJlbmREYXRlIiwia2V5Iiwic3RhcnREYXRlIiwic3VidHJhY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUVBOzs7O0FBRUE7Ozs7OztBQU1BLFNBQVNBLGtCQUFULENB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QUksZTs7Z0NBaUJBTSxlOztnQ0E2QkFFLHdCOztnQ0FtQ0FTLGtCOztnQ0FTQUUsWTs7Z0NBY0FFLGU7O2dDQXVCSEUsa0IiLCJmaWxlIjoiX0NhbGVuZGFyVXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmltcG9ydCB7IERFRkFVTFRfVElNRV9QQVRURVJOIH0gZnJvbSAnLi4vY29uc3RhbnRzL19UaW1lWm9uZXMnO1xuXG4vKipcbiAqIE1hcCBVVEMgZGF0ZSBzdHJpbmcgdG8gbW9tZW50IGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGUgLSBVVEMtZm9ybWF0dGVkIGRhdGUgc3RyaW5nIChAVE9ETzogdmFsaWRhdGUgcGF0dGVybiBvZiBhcmcpXG4gKiBAcmV0dXJucyB7KG1vbWVudHxib29sZWFuKX1cbiAqL1xuZnVuY3Rpb24gZGF0ZVN0cmluZ1RvTW9tZW50KGRhdGUpIHtcbiAgLy8gYWxyZWFkeSBhIHZhbGlkIG1vbWVudFxuICBpZiAoZGF0ZS5pc1ZhbGlkICYmIGRhdGUuaXNWYWxpZCgpKSByZXR1cm4gZGF0ZTtcbiAgLy8gdHJ5IHRvIGluc3RhbnRpYXRlIGEgbmV3IG1vbWVudFxuICByZXR1cm4gdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnICYmIG1vbWVudChkYXRlKS5pc1ZhbGlkKCkgPyBtb21lbnQoZGF0ZSkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9Nb21lbnQoZGF0ZSkge1xuICBsZXQgbW9tZW50RGF0ZSA9IGRhdGU7XG4gIGlmICghZGF0ZSB8fCAoZGF0ZSAmJiAhZGF0ZS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgIG1vbWVudERhdGUgPSBtb21lbnQoZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG1vbWVudERhdGU7XG59XG5cbi8qKlxuICogQXJlIGRhdGVzIHZhbGlkIGFuZCBkb2VzIHN0YXJ0IGNvbWUgYmVmb3JlIGVuZD9cbiAqXG4gKiBAcGFyYW0ge21vbWVudH0gbW9tZW50U3RhcnRcbiAqIEBwYXJhbSB7bW9tZW50fSBtb21lbnRFbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRGF0ZVJhbmdlKG1vbWVudFN0YXJ0LCBtb21lbnRFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSBkYXRlVG9Nb21lbnQobW9tZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBkYXRlVG9Nb21lbnQobW9tZW50RW5kKTtcbiAgcmV0dXJuIHN0YXJ0ICYmIGVuZFxuICAgICYmIHN0YXJ0LmlzVmFsaWQoKSAmJiBlbmQuaXNWYWxpZCgpXG4gICAgJiYgc3RhcnQuaXNTYW1lT3JCZWZvcmUoZW5kKTtcbn1cblxuLyoqXG4gKiBJcyBkYXRlIHdpdGhpbiBwcm92aWRlZCBib3VuZGFyaWVzPyAoZXhjbHVzaXZlKVxuICogQHBhcmFtIHttb21lbnR9IGRhdGVcbiAqIEBwYXJhbSB7bW9tZW50fSByYW5nZVN0YXJ0XG4gKiBAcGFyYW0ge21vbWVudH0gcmFuZ2VFbmRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZVRpbWVzXSAtIFJlc3BlY3QgdGltZXMgb2YgcmFuZ2VTdGFydC9FbmQgbW9tZW50cyBvciBvbmx5IGNvbXBhcmUgZGF0ZXNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RhdGVXaXRoaW5SYW5nZShkYXRlLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgdXNlVGltZXMgPSBmYWxzZSkge1xuICBsZXQgZm9ybWF0dGVkUmFuZ2VTdGFydCA9IHJhbmdlU3RhcnQ7XG4gIGxldCBmb3JtYXR0ZWRSYW5nZUVuZCA9IHJhbmdlRW5kO1xuXG4gIGlmICghdXNlVGltZXMpIHtcbiAgICBmb3JtYXR0ZWRSYW5nZVN0YXJ0ID0gcmFuZ2VTdGFydCAmJiByYW5nZVN0YXJ0LmNsb25lKCkuc3RhcnRPZignZGF5Jyk7XG4gICAgZm9ybWF0dGVkUmFuZ2VFbmQgPSByYW5nZUVuZCAmJiByYW5nZUVuZC5jbG9uZSgpLmVuZE9mKCdkYXknKTtcbiAgfVxuXG4gIGNvbnN0IGlzQWZ0ZXJTdGFydCA9IGZvcm1hdHRlZFJhbmdlU3RhcnQgPyBkYXRlLmlzU2FtZU9yQWZ0ZXIoZm9ybWF0dGVkUmFuZ2VTdGFydCkgOiB0cnVlO1xuICBjb25zdCBpc0JlZm9yZUVuZCA9IGZvcm1hdHRlZFJhbmdlRW5kID8gZGF0ZS5pc1NhbWVPckJlZm9yZShmb3JtYXR0ZWRSYW5nZUVuZCkgOiB0cnVlO1xuXG4gIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG59XG5cbi8qKlxuICogVmVyaWZ5IHRpbWUgKG5vdCBkYXRlKSBmYWxscyB3aXRoaW4gcHJvdmlkZWQgcmFuZ2VcbiAqXG4gKiBAcGFyYW0gdGltZSB7VGltZU9iamVjdH1cbiAqIEBwYXJhbSByYW5nZVN0YXJ0IHtUaW1lT2JqZWN0fVxuICogQHBhcmFtIHJhbmdlRW5kIHtUaW1lT2JqZWN0fVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGltZVdpdGhpblJhbmdlKHRpbWUsIHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gIC8vIG1pc3NpbmcgYm91bmRhcnkgcGFyYW0gbWVhbnMgd2UgY2FuJ3QgcmVhbGx5IGNoZWNrIHJhbmdlXG4gIGlmICghcmFuZ2VTdGFydCB8fCAhcmFuZ2VFbmQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG1vbWVudCh0aW1lKS5pc0JldHdlZW4obW9tZW50KHJhbmdlU3RhcnQpLCBtb21lbnQocmFuZ2VFbmQpLCBudWxsLCAnW10nKTtcbn1cblxuLyoqXG4gKiBNYXAgbW9tZW50IG9iaiB0byBgeyBob3VyOiAyMCwgbWludXRlOiAxNSwgc2Vjb25kOiAzMCB9YCBmb3JtYXRcbiAqXG4gKiBAcGFyYW0gdGltZSB7bW9tZW50fVxuICogQHJldHVybnMge1RpbWVPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHRpbWVPYmpGcm9tTW9tZW50KHRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBob3VyOiB0aW1lLmhvdXIoKSxcbiAgICBtaW51dGU6IHRpbWUubWludXRlKCksXG4gICAgc2Vjb25kOiB0aW1lLnNlY29uZCgpLFxuICB9O1xufVxuXG4vKipcbiAqIFJvdW5kIGRvd24gdGltZSBieSBhIGhhbGYgaG91clxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIG9iai50aW1lIHttb21lbnR9XG4gKiBAcGFyYW0gb2JqLnBhdHRlcm4ge1N0cmluZ30gLSBGb3JtYXQgcGF0dGVybiB1c2VkIGJ5IG1vbWVudFxuICogQHJldHVybnMge1N0cmluZ30gLSBGb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0UHJldkhhbGZIb3VyKHsgdGltZSA9IG1vbWVudCgpLCBwYXR0ZXJuIH0pIHtcbiAgcmV0dXJuIHRpbWVcbiAgICAuY2xvbmUoKVxuICAgIC5zZXQoe1xuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgICBtaW51dGVzOiB0aW1lLm1pbnV0ZXMoKSA+PSAzMCA/IDMwIDogMCxcbiAgICB9KVxuICAgIC5mb3JtYXQocGF0dGVybik7XG59XG5cbi8qKlxuICogUm91bmQgdXAgdGltZSBieSBhIGhhbGYgaG91clxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIG9iai50aW1lIHttb21lbnR9XG4gKiBAcGFyYW0gb2JqLnBhdHRlcm4ge1N0cmluZ30gLSBGb3JtYXQgcGF0dGVybiB1c2VkIGJ5IG1vbWVudFxuICogQHJldHVybnMge1N0cmluZ30gLSBGb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dEhhbGZIb3VyKHsgdGltZSA9IG1vbWVudCgpLCBwYXR0ZXJuIH0pIHtcbiAgcmV0dXJuIHRpbWVcbiAgICAuY2xvbmUoKVxuICAgIC5zZXQoe1xuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgICBtaW51dGVzOiB0aW1lLm1pbnV0ZXMoKSA+PSAzMCA/IDAgOiAzMCxcbiAgICB9KVxuICAgIC8vIG5lZWQgdG8gYnVtcCBob3VyIGlmIHJvdW5kaW5nIHVwXG4gICAgLmFkZCh0aW1lLm1pbnV0ZXMoKSA+PSAzMCA/IDEgOiAwLCAnaCcpXG4gICAgLmZvcm1hdChwYXR0ZXJuKTtcbn1cblxuLyoqXG4gKiBBIGNvbmZpZyBvYmogdXNlZCB0byBkZWZpbmUgZGF0ZSByYW5nZXMgdXNlZCBpbiBjYWxlbmRhcnMsIGV0IGFsLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVPYmplY3RcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBob3VyIC0gSG91ciBiZXR3ZWVuIDAtMjNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW51dGUgLSBNaW51dGUgYmV0d2VlbiAwLTU5XG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYXJyYXkgb2YgdGltZSBvcHRpb24gb2JqZWN0cyBmb3IgdXNlIGluIGRyb3Bkb3duc1xuICpcbiAqIEBwYXJhbSB7VGltZU9iamVjdH0gW2JvdW5kYXJ5RW5kXVxuICogQHBhcmFtIHtUaW1lT2JqZWN0fSBbYm91bmRhcnlTdGFydF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW50ZXJ2YWxdIC0gTnVtYmVyIG9mIG1pbnV0ZXMgYmV0d2VlbiBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdHRlcm5dIC0gbW9tZW50LXJlY29nbml6ZWQgZm9ybWF0dGluZyBwYXR0ZXJuXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IC0gQXJyYXkgb2Ygb2JqZWN0cyB3LyBzaGFwZTogeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbGFiZWwsIHZhbHVlIH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRUaW1lSW50ZXJ2YWxPcHRpb25zKHtcbiAgYm91bmRhcnlFbmQgPSB7IGhvdXI6IDIzLCBtaW51dGU6IDU5LCBzZWNvbmQ6IDU5IH0sXG4gIGJvdW5kYXJ5U3RhcnQgPSB7IGhvdXI6IDAsIG1pbnV0ZTogMCwgc2Vjb25kOiAwIH0sXG4gIGludGVydmFsID0gMzAsXG4gIHBhdHRlcm4gPSBERUZBVUxUX1RJTUVfUEFUVEVSTixcbn0pIHtcbiAgY29uc3QgcmV0ID0gW107XG4gICAvLyBzZWNvbmRzIHdpbGwgYWx3YXlzIGVxdWFsIHplcm8gZm9yIGRlZmF1bHQgb3B0aW9uc1xuICBjb25zdCBzZWNvbmQgPSAwO1xuICBmb3IgKGxldCBob3VyID0gYm91bmRhcnlTdGFydC5ob3VyOyBob3VyIDw9IGJvdW5kYXJ5RW5kLmhvdXI7IGhvdXIrKykge1xuICAgIGZvciAobGV0IG1pbnV0ZSA9IDA7IG1pbnV0ZSA8IDYwOyBtaW51dGUgKz0gaW50ZXJ2YWwpIHtcbiAgICAgIGlmIChpc1RpbWVXaXRoaW5SYW5nZSh7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kIH0sIGJvdW5kYXJ5U3RhcnQsIGJvdW5kYXJ5RW5kKSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBtb21lbnQoeyBob3VyLCBtaW51dGUsIHNlY29uZCB9KS5mb3JtYXQocGF0dGVybik7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBob3VyLFxuICAgICAgICAgIGxhYmVsOiBvcHRpb24sXG4gICAgICAgICAgbWludXRlLFxuICAgICAgICAgIHNlY29uZCxcbiAgICAgICAgICB2YWx1ZTogb3B0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBEb2VzIHRoZSBkYXRlIHByb3ZpZGVkIGZhbGwgd2l0aGluIHRoZSBtb250aHMgb2YgdGhlIHJhbmdlLCBldmVuIGlmIHRoZSBkYXRlIGl0c2VsZiBkb2VzIG5vdCxcbiAqIGUuZy4sIGBpc01vbnRoUGFydE9mUmFuZ2UoPEphbiAwMiwgMjAxNj4sIDxKYW4gMTUsIDIwMTY+LCA8TWFyY2ggMTUsIDIwMTY+KWAgcmV0dXJucyB0cnVlXG4gKlxuICogQHBhcmFtIGRhdGUge21vbWVudH1cbiAqIEBwYXJhbSByYW5nZVN0YXJ0IHttb21lbnR9XG4gKiBAcGFyYW0gcmFuZ2VFbmQge21vbWVudH1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vbnRoUGFydE9mUmFuZ2UoZGF0ZSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgLy8gbm8gYm91bmRhcmllcyBtZWFucyBkYXRlIGlzIHZhbGlkXG4gIGlmICghcmFuZ2VTdGFydCB8fCAhcmFuZ2VFbmQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gICAgLy8gZGF0ZSBtYXkgYmUgb3V0IG9mIHJhbmdlLCBidXQgd2l0aGluIHNhbWUgbW9udGhcbiAgICB8fCBkYXRlLmlzU2FtZShyYW5nZVN0YXJ0LCAnbW9udGgnKVxuICAgIHx8IGRhdGUuaXNTYW1lKHJhbmdlRW5kLCAnbW9udGgnKTtcbn1cblxuZnVuY3Rpb24gbW9tZW50VG9EYXRlKG1vbWVudERhdGUpIHtcbiAgaWYgKG1vbWVudERhdGUgJiYgbW9tZW50RGF0ZS5faXNBTW9tZW50T2JqZWN0KSB7XG4gICAgcmV0dXJuIG1vbWVudERhdGUudG9EYXRlKCk7XG4gIH1cbiAgcmV0dXJuIG1vbWVudERhdGU7XG59XG5cbi8qKlxuICogQ29udmVydCBmb3JtYXR0ZWQgdGltZSBzdHJpbmcgdG8geyBob3VyOiAxLCBtaW51dGU6IDExLCBzZWNvbmQ6IDU5IH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGltZSAtIEZvcm1hdHRlZCB0aW1lLCBlLmcuLCBcIjAyOjEzOjAwIFBNXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIC0gbW9tZW50IHBhdHRlcm4gZm9yIGRpc3BsYXlpbmcvcGFyc2luZyB0aW1lLCBlLmcuLCAnaGg6bW1hJ1xuICogQHJldHVybnMge1RpbWVPYmplY3R8Ym9vbGVhbn0gLSBSZXR1cm5zIGZhbHNlIGlmIHRpbWUgc3RyaW5nIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9UaW1lT2JqKHRpbWUsIHBhdHRlcm4pIHtcbiAgY29uc3QgdGltZU1vbWVudCA9IG1vbWVudCh0aW1lLCBwYXR0ZXJuLCB0cnVlKTtcbiAgcmV0dXJuIHRpbWVNb21lbnQuaXNWYWxpZCgpICYmIHtcbiAgICBob3VyOiB0aW1lTW9tZW50LmhvdXIoKSxcbiAgICBtaW51dGU6IHRpbWVNb21lbnQubWludXRlKCksXG4gICAgc2Vjb25kOiB0aW1lTW9tZW50LnNlY29uZCgpLFxuICB9O1xufVxuXG4vKipcbiAqIEEgY29uZmlnIG9iaiB1c2VkIHRvIGRlZmluZSBkYXRlIHJhbmdlcyB1c2VkIGluIGNhbGVuZGFycywgZXQgYWwuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRGF0ZVJhbmdlUHJlc2V0XG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2V5IC0gSUQgZm9yIHByZXNldFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsIC0gTmljZSBuYW1lIGZvciB1c2VyIChAVE9ETyBzaG91bGQgcHJvYmFibHkgYmUgdHJhbnNsYXRlZClcbiAqIEBwcm9wZXJ0eSB7bW9tZW50fSBzdGFydERhdGUgLSBTdGFydCBkYXRlIGluIHJhbmdlXG4gKiBAcHJvcGVydHkge21vbWVudH0gZW5kRGF0ZSAtIEVuZCBkYXRlIGluIHJhbmdlXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGRhdGUgcmFuZ2UgcHJlc2V0c1xuICogQHR5cGUge0RhdGVSYW5nZVByZXNldFtdfVxuICovXG5jb25zdCBEQVRFX1JBTkdFX1BSRVNFVFMgPSBbe1xuICBlbmREYXRlOiBtb21lbnQoKS5lbmRPZignZGF5JyksXG4gIGtleTogJ3RvZGF5JyxcbiAgbGFiZWw6ICdUb2RheScsXG4gIHN0YXJ0RGF0ZTogbW9tZW50KCkuc3RhcnRPZignZGF5JyksXG59LCB7XG4gIGVuZERhdGU6IG1vbWVudCgpLmVuZE9mKCdkYXknKS5zdWJ0cmFjdCgxLCAnZGF5JyksXG4gIGtleTogJ3llc3RlcmRheScsXG4gIGxhYmVsOiAnWWVzdGVyZGF5JyxcbiAgc3RhcnREYXRlOiBtb21lbnQoKS5zdGFydE9mKCdkYXknKS5zdWJ0cmFjdCgxLCAnZGF5JyksXG59LCB7XG4gIGVuZERhdGU6IG1vbWVudCgpLmVuZE9mKCdkYXknKS5zdWJ0cmFjdCgxLCAnZGF5JyksXG4gIGtleTogJ2xhc3Q3RGF5cycsXG4gIGxhYmVsOiAnTGFzdCA3IERheXMnLFxuICBzdGFydERhdGU6IG1vbWVudCgpLnN0YXJ0T2YoJ2RheScpLnN1YnRyYWN0KDcsICdkYXknKSxcbn0sIHtcbiAgZW5kRGF0ZTogbW9tZW50KCkuc3VidHJhY3QoMSwgJ3dlZWsnKS5lbmRPZignd2VlaycpLFxuICBrZXk6ICdwcmV2V2VlaycsXG4gIGxhYmVsOiAnUHJldmlvdXMgV2VlaycsXG4gIHN0YXJ0RGF0ZTogbW9tZW50KCkuc3VidHJhY3QoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyksXG59LCB7XG4gIGVuZERhdGU6IG1vbWVudCgpLmVuZE9mKCdkYXknKSxcbiAga2V5OiAnbW9udGhUb0RhdGUnLFxuICBsYWJlbDogJ01vbnRoIHRvIERhdGUnLFxuICBzdGFydERhdGU6IG1vbWVudCgpLnN0YXJ0T2YoJ21vbnRoJyksXG59LCB7XG4gIGVuZERhdGU6IG1vbWVudCgpLmVuZE9mKCdkYXknKS5zdWJ0cmFjdCgxLCAnZGF5JyksXG4gIGtleTogJ2xhc3QzMERheXMnLFxuICBsYWJlbDogJ0xhc3QgMzAgRGF5cycsXG4gIHN0YXJ0RGF0ZTogbW9tZW50KCkuc3RhcnRPZignZGF5Jykuc3VidHJhY3QoMzAsICdkYXknKSxcbn0sIHtcbiAgZW5kRGF0ZTogbW9tZW50KCkuc3VidHJhY3QoMSwgJ21vbnRoJykuZW5kT2YoJ21vbnRoJyksXG4gIGtleTogJ2xhc3RNb250aCcsXG4gIGxhYmVsOiAnTGFzdCBNb250aCcsXG4gIHN0YXJ0RGF0ZTogbW9tZW50KCkuc3VidHJhY3QoMSwgJ21vbnRoJykuc3RhcnRPZignbW9udGgnKSxcbn0sIHtcbiAgZW5kRGF0ZTogbW9tZW50KCkuZW5kT2YoJ2RheScpLFxuICBrZXk6ICdjdXN0b20nLFxuICBsYWJlbDogJ0N1c3RvbScsXG4gIHN0YXJ0RGF0ZTogbW9tZW50KCkuc3RhcnRPZignZGF5JyksXG59XTtcblxuZXhwb3J0IHtcbiAgYnVpbGRUaW1lSW50ZXJ2YWxPcHRpb25zLFxuICBEQVRFX1JBTkdFX1BSRVNFVFMsXG4gIGRhdGVTdHJpbmdUb01vbWVudCxcbiAgZGF0ZVRvTW9tZW50LFxuICBnZXROZXh0SGFsZkhvdXIsXG4gIGdldFByZXZIYWxmSG91cixcbiAgaXNEYXRlV2l0aGluUmFuZ2UsXG4gIGlzTW9udGhQYXJ0T2ZSYW5nZSxcbiAgaXNUaW1lV2l0aGluUmFuZ2UsXG4gIGlzVmFsaWREYXRlUmFuZ2UsXG4gIG1vbWVudFRvRGF0ZSxcbiAgc3RyaW5nVG9UaW1lT2JqLFxuICB0aW1lT2JqRnJvbU1vbWVudCxcbn07XG4iXX0=