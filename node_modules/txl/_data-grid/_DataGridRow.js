'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _class;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _debounce = require('lodash/debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _ReactUtils = require('../ReactUtils');

var _DataGridStyles = require('./DataGridStyles');

var _jsStyleHelpers = require('../styles/_helpers/jsStyleHelpers');

var _attributes = require('./_attributes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PINNED_WRAPPER_STYLES = (0, _extends3.default)({}, _DataGridStyles.CELL_WRAPPER, {
  backgroundColor: 'white',
  left: 0,
  position: 'absolute'
});

function getCell(cellRenderer, record, extraProps, isHovering, model, index, arr) {
  // need to assign here or JSX won't work correctly
  var Renderer = cellRenderer;
  var props = (0, _extends3.default)({}, extraProps, {
    isHovering: isHovering,
    key: model.key,
    last: index === arr.length - 1,
    model: model,
    record: record
  });

  return _react2.default.createElement(Renderer, props);
}

var TxlDataGridRow = (0, _radium2.default)(_class = function (_React$Component) {
  (0, _inherits3.default)(TxlDataGridRow, _React$Component);

  function TxlDataGridRow() {
    var _ref;

    (0, _classCallCheck3.default)(this, TxlDataGridRow);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = TxlDataGridRow.__proto__ || (0, _getPrototypeOf2.default)(TxlDataGridRow)).call.apply(_ref, [this].concat(args)));

    _this._updateHeights = function () {
      return _this.___updateHeights__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._setBaseRowHeight = function () {
      return _this.___setBaseRowHeight__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleMouseEnter = function () {
      return _this.___handleMouseEnter__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleMouseLeave = function () {
      return _this.___handleMouseLeave__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this.state = { isHovering: false };

    _this._debouncedUpdateHeights = (0, _debounce2.default)(_this._updateHeights, 70);
    _this._baseHeight = null;
    return _this;
  }

  (0, _createClass3.default)(TxlDataGridRow, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._setBaseRowHeight();
      this._updateHeights();
      window.addEventListener('resize', this._debouncedUpdateHeights);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this._debouncedUpdateHeights);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._updateHeights();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.columnModel !== nextProps.columnModel) {
        this._updateHeights();
      }
    }
  }, {
    key: '___updateHeights__REACT_HOT_LOADER__',
    value: function ___updateHeights__REACT_HOT_LOADER__() {
      return this.___updateHeights__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateHeights__REACT_HOT_LOADER__',
    value: function ___updateHeights__REACT_HOT_LOADER__() {
      return this.___updateHeights__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateHeights__REACT_HOT_LOADER__',
    value: function ___updateHeights__REACT_HOT_LOADER__() {
      /**
       * When we have a pinned column and allow for truncating within cells, we need to
       * set the height for pinned/unpinned container to accomodate for the truncation.
       * The unpinned container will adjust accordingly when truncation occurs so
       * we just have to adjust the height for the pinned container, however
       * we still need to account for cases when the base pinned container height is
       * greater than the unpinned in which case we would set the unpinnedContainer
       * height to the pinned container height.
       */
      if (!this.refs.pinnedColumns) return;

      var onHeightUpdated = this.props.onHeightUpdated;


      var unpinnedContainer = (0, _ReactUtils.findDOMNode)(this.refs.unpinnedColumns);
      var pinnedContainer = (0, _ReactUtils.findDOMNode)(this.refs.pinnedColumns);

      window.requestAnimationFrame(function () {
        // Remove height styling so we can determine the minimum height needed to display
        // either container.
        unpinnedContainer.style.removeProperty('height');
        pinnedContainer.style.removeProperty('height');

        var pinnedContainerHeight = pinnedContainer.getBoundingClientRect().height;
        var unpinnedContainerHeight = unpinnedContainer.getBoundingClientRect().height;

        var changedNode = pinnedContainerHeight > unpinnedContainerHeight ? unpinnedContainer : pinnedContainer;
        var changedHeight = Math.max(pinnedContainerHeight, unpinnedContainerHeight);

        (0, _jsStyleHelpers.setStylesForNode)(changedNode, {
          height: changedHeight + 'px'
        });

        onHeightUpdated && onHeightUpdated({ changedNode: changedNode });
      });
    }
  }, {
    key: '___setBaseRowHeight__REACT_HOT_LOADER__',
    value: function ___setBaseRowHeight__REACT_HOT_LOADER__() {
      return this.___setBaseRowHeight__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___setBaseRowHeight__REACT_HOT_LOADER__',
    value: function ___setBaseRowHeight__REACT_HOT_LOADER__() {
      return this.___setBaseRowHeight__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___setBaseRowHeight__REACT_HOT_LOADER__',
    value: function ___setBaseRowHeight__REACT_HOT_LOADER__() {
      /**
       * This is setting the row baseHeight because we need this to make comparisons with in cases
       * where the pinned container height is larger than unpinned by default, which will
       * occur for any pinned cell with text that wraps
       *
       * NOTE: Only applies if we have a pinned column
       */
      if (!this.refs.pinnedColumns) return;
      var pinnedContainer = (0, _ReactUtils.findDOMNode)(this.refs.pinnedColumns);
      var pinnedContainerHeight = pinnedContainer.getBoundingClientRect().height;

      this._baseHeight = pinnedContainerHeight;
    }
  }, {
    key: '___handleMouseEnter__REACT_HOT_LOADER__',
    value: function ___handleMouseEnter__REACT_HOT_LOADER__() {
      return this.___handleMouseEnter__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleMouseEnter__REACT_HOT_LOADER__',
    value: function ___handleMouseEnter__REACT_HOT_LOADER__() {
      return this.___handleMouseEnter__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleMouseEnter__REACT_HOT_LOADER__',
    value: function ___handleMouseEnter__REACT_HOT_LOADER__() {
      this.setState({ isHovering: true });
    }
  }, {
    key: '___handleMouseLeave__REACT_HOT_LOADER__',
    value: function ___handleMouseLeave__REACT_HOT_LOADER__() {
      return this.___handleMouseLeave__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleMouseLeave__REACT_HOT_LOADER__',
    value: function ___handleMouseLeave__REACT_HOT_LOADER__() {
      return this.___handleMouseLeave__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleMouseLeave__REACT_HOT_LOADER__',
    value: function ___handleMouseLeave__REACT_HOT_LOADER__() {
      this.setState({ isHovering: false });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          cellRenderer = _props.cellRenderer,
          columnModel = _props.columnModel,
          componentName = _props.componentName,
          index = _props.index,
          record = _props.record,
          style = _props.style,
          props = (0, _objectWithoutProperties3.default)(_props, ['cellRenderer', 'columnModel', 'componentName', 'index', 'record', 'style']);

      var PINNED_ATTR = (0, _defineProperty3.default)({}, _attributes.PINNED_WRAPPER_ATTR, true);
      var UNPINNED_ATTR = (0, _defineProperty3.default)({}, _attributes.UNPINNED_WRAPPER_ATTR, true);
      var boundGetCell = function boundGetCell() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return getCell.apply(undefined, [cellRenderer, record, (0, _extends3.default)({ index: index }, props), _this2.state.isHovering].concat(args));
      };

      var pinnedCells = columnModel.filter(function (model) {
        return model.pinned;
      }).map(boundGetCell);

      var unpinnedCells = columnModel.filter(function (model) {
        return !model.pinned;
      }).map(boundGetCell);

      return _react2.default.createElement(
        'div',
        {
          'data-component': componentName,
          'data-row': index,
          style: style,
          key: index,
          onMouseEnter: this._handleMouseEnter,
          onMouseLeave: this._handleMouseLeave
        },
        !!pinnedCells.length && _react2.default.createElement(
          'div',
          (0, _extends3.default)({}, PINNED_ATTR, {
            key: 'pinned',
            ref: 'pinnedColumns',
            style: PINNED_WRAPPER_STYLES
          }),
          pinnedCells
        ),
        _react2.default.createElement(
          'div',
          (0, _extends3.default)({}, UNPINNED_ATTR, {
            key: 'unpinned',
            ref: 'unpinnedColumns',
            style: _DataGridStyles.CELL_WRAPPER
          }),
          unpinnedCells
        )
      );
    }
  }]);
  return TxlDataGridRow;
}(_react2.default.Component)) || _class;

exports.default = TxlDataGridRow;


TxlDataGridRow.propTypes = {
  cellRenderer: _react.PropTypes.any,
  columnModel: _react.PropTypes.array,
  componentName: _react.PropTypes.string.isRequired,
  index: _react.PropTypes.number,
  lastRow: _react.PropTypes.bool,
  onHeightUpdated: _react.PropTypes.func,
  pinnedCells: _react.PropTypes.arrayOf(_react.PropTypes.node),
  record: _react.PropTypes.object,
  style: _react.PropTypes.object,
  unpinnedCells: _react.PropTypes.arrayOf(_react.PropTypes.node)
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(PINNED_WRAPPER_STYLES, 'PINNED_WRAPPER_STYLES', 'src/_data-grid/_DataGridRow.jsx');

  __REACT_HOT_LOADER__.register(getCell, 'getCell', 'src/_data-grid/_DataGridRow.jsx');

  __REACT_HOT_LOADER__.register(TxlDataGridRow, 'TxlDataGridRow', 'src/_data-grid/_DataGridRow.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fZGF0YS1ncmlkL19EYXRhR3JpZFJvdy5qc3giXSwibmFtZXMiOlsiUElOTkVEX1dSQVBQRVJfU1RZTEVTIiwiYmFja2dyb3VuZENvbG9yIiwibGVmdCIsInBvc2l0aW9uIiwiZ2V0Q2VsbCIsImNlbGxSZW5kZXJlciIsInJlY29yZCIsImV4dHJhUHJvcHMiLCJpc0hvdmVyaW5nIiwibW9kZWwiLCJpbmRleCIsImFyciIsIlJlbmRlcmVyIiwicHJvcHMiLCJrZXkiLCJsYXN0IiwibGVuZ3RoIiwiVHhsRGF0YUdyaWRSb3ciLCJhcmdzIiwiX3VwZGF0ZUhlaWdodHMiLCJfc2V0QmFzZVJvd0hlaWdodCIsIl9oYW5kbGVNb3VzZUVudGVyIiwiX2hhbmRsZU1vdXNlTGVhdmUiLCJzdGF0ZSIsIl9kZWJvdW5jZWRVcGRhdGVIZWlnaHRzIiwiX2Jhc2VIZWlnaHQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5leHRQcm9wcyIsImNvbHVtbk1vZGVsIiwicmVmcyIsInBpbm5lZENvbHVtbnMiLCJvbkhlaWdodFVwZGF0ZWQiLCJ1bnBpbm5lZENvbnRhaW5lciIsInVucGlubmVkQ29sdW1ucyIsInBpbm5lZENvbnRhaW5lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0eWxlIiwicmVtb3ZlUHJvcGVydHkiLCJwaW5uZWRDb250YWluZXJIZWlnaHQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJ1bnBpbm5lZENvbnRhaW5lckhlaWdodCIsImNoYW5nZWROb2RlIiwiY2hhbmdlZEhlaWdodCIsIk1hdGgiLCJtYXgiLCJzZXRTdGF0ZSIsImNvbXBvbmVudE5hbWUiLCJQSU5ORURfQVRUUiIsIlVOUElOTkVEX0FUVFIiLCJib3VuZEdldENlbGwiLCJwaW5uZWRDZWxscyIsImZpbHRlciIsInBpbm5lZCIsIm1hcCIsInVucGlubmVkQ2VsbHMiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJhbnkiLCJhcnJheSIsInN0cmluZyIsImlzUmVxdWlyZWQiLCJudW1iZXIiLCJsYXN0Um93IiwiYm9vbCIsImZ1bmMiLCJhcnJheU9mIiwibm9kZSIsIm9iamVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7QUFHQTs7QUFHQTs7OztBQUtBLElBQU1BO0FBRUpDLG1CQUFpQixPQUZiO0FBR0pDLFFBQU0sQ0FIRjtBQUlKQyxZQUFVO0FBSk4sRUFBTjs7QUFPQSxTQUFTQyxPQUFULENBQWlCQyxZQUFqQixFQUErQkMsTUFBL0IsRUFBdUNDLFVBQXZDLEVBQW1EQyxVQUFuRCxFQUErREMsS0FBL0QsRUFBc0VDLEtBQXRFLEVBQTZFQyxHQUE3RSxFQUFrRjtBQUNoRjtBQUNBLE1BQU1DLFdBQVdQLFlBQWpCO0FBQ0EsTUFBTVEsbUNBQ0ROLFVBREM7QUFFSkMsMEJBRkk7QUFHSk0sU0FBS0wsTUFBTUssR0FIUDtBQUlKQyxVQUFNTCxVQUFVQyxJQUFJSyxNQUFKLEdBQWEsQ0FKekI7QUFLSlAsZ0JBTEk7QUFNSkg7QUFOSSxJQUFOOztBQVNBLFNBQU8sOEJBQUMsUUFBRCxFQUFjTyxLQUFkLENBQVA7QUFDRDs7SUFHb0JJLGM7OztBQUNuQiw0QkFBcUI7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTkMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsaUxBQ1ZBLElBRFU7O0FBQUEsVUE2QnJCQyxjQTdCcUI7QUFBQTtBQUFBOztBQUFBLFVBb0VyQkMsaUJBcEVxQjtBQUFBO0FBQUE7O0FBQUEsVUFtRnJCQyxpQkFuRnFCO0FBQUE7QUFBQTs7QUFBQSxVQXVGckJDLGlCQXZGcUI7QUFBQTtBQUFBOztBQUduQixVQUFLQyxLQUFMLEdBQWEsRUFBRWYsWUFBWSxLQUFkLEVBQWI7O0FBRUEsVUFBS2dCLHVCQUFMLEdBQStCLHdCQUFTLE1BQUtMLGNBQWQsRUFBOEIsRUFBOUIsQ0FBL0I7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LGlCQUFVZ0UsTUFSTztBQVN6QmhDLFNBQU8saUJBQVVnQyxNQVRRO0FBVXpCYixpQkFBZSxpQkFBVVcsT0FBVixDQUFrQixpQkFBVUMsSUFBNUI7QUFWVSxDQUEzQjs7Ozs7Ozs7Z0NBbExNckUscUI7O2dDQU9HSSxPOztnQ0FnQllhLGMiLCJmaWxlIjoiX0RhdGFHcmlkUm93LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSYWRpdW0gZnJvbSAncmFkaXVtJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xuXG5pbXBvcnQgeyBmaW5kRE9NTm9kZSB9IGZyb20gJy4uL1JlYWN0VXRpbHMnO1xuaW1wb3J0IHtcbiAgQ0VMTF9XUkFQUEVSLFxufSBmcm9tICcuL0RhdGFHcmlkU3R5bGVzJztcbmltcG9ydCB7XG4gIHNldFN0eWxlc0Zvck5vZGUsXG59IGZyb20gJy4uL3N0eWxlcy9faGVscGVycy9qc1N0eWxlSGVscGVycyc7XG5pbXBvcnQge1xuICBQSU5ORURfV1JBUFBFUl9BVFRSLFxuICBVTlBJTk5FRF9XUkFQUEVSX0FUVFIsXG59IGZyb20gJy4vX2F0dHJpYnV0ZXMnO1xuXG5jb25zdCBQSU5ORURfV1JBUFBFUl9TVFlMRVMgPSB7XG4gIC4uLkNFTExfV1JBUFBFUixcbiAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICBsZWZ0OiAwLFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbn07XG5cbmZ1bmN0aW9uIGdldENlbGwoY2VsbFJlbmRlcmVyLCByZWNvcmQsIGV4dHJhUHJvcHMsIGlzSG92ZXJpbmcsIG1vZGVsLCBpbmRleCwgYXJyKSB7XG4gIC8vIG5lZWQgdG8gYXNzaWduIGhlcmUgb3IgSlNYIHdvbid0IHdvcmsgY29ycmVjdGx5XG4gIGNvbnN0IFJlbmRlcmVyID0gY2VsbFJlbmRlcmVyO1xuICBjb25zdCBwcm9wcyA9IHtcbiAgICAuLi5leHRyYVByb3BzLFxuICAgIGlzSG92ZXJpbmcsXG4gICAga2V5OiBtb2RlbC5rZXksXG4gICAgbGFzdDogaW5kZXggPT09IGFyci5sZW5ndGggLSAxLFxuICAgIG1vZGVsLFxuICAgIHJlY29yZCxcbiAgfTtcblxuICByZXR1cm4gPFJlbmRlcmVyIHsuLi5wcm9wc30gLz47XG59XG5cbkBSYWRpdW1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR4bERhdGFHcmlkUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgaXNIb3ZlcmluZzogZmFsc2UgfTtcblxuICAgIHRoaXMuX2RlYm91bmNlZFVwZGF0ZUhlaWdodHMgPSBkZWJvdW5jZSh0aGlzLl91cGRhdGVIZWlnaHRzLCA3MCk7XG4gICAgdGhpcy5fYmFzZUhlaWdodCA9IG51bGw7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLl9zZXRCYXNlUm93SGVpZ2h0KCk7XG4gICAgdGhpcy5fdXBkYXRlSGVpZ2h0cygpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9kZWJvdW5jZWRVcGRhdGVIZWlnaHRzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9kZWJvdW5jZWRVcGRhdGVIZWlnaHRzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLl91cGRhdGVIZWlnaHRzKCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLmNvbHVtbk1vZGVsICE9PSBuZXh0UHJvcHMuY29sdW1uTW9kZWwpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhlaWdodHMoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlSGVpZ2h0cyA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGhhdmUgYSBwaW5uZWQgY29sdW1uIGFuZCBhbGxvdyBmb3IgdHJ1bmNhdGluZyB3aXRoaW4gY2VsbHMsIHdlIG5lZWQgdG9cbiAgICAgKiBzZXQgdGhlIGhlaWdodCBmb3IgcGlubmVkL3VucGlubmVkIGNvbnRhaW5lciB0byBhY2NvbW9kYXRlIGZvciB0aGUgdHJ1bmNhdGlvbi5cbiAgICAgKiBUaGUgdW5waW5uZWQgY29udGFpbmVyIHdpbGwgYWRqdXN0IGFjY29yZGluZ2x5IHdoZW4gdHJ1bmNhdGlvbiBvY2N1cnMgc29cbiAgICAgKiB3ZSBqdXN0IGhhdmUgdG8gYWRqdXN0IHRoZSBoZWlnaHQgZm9yIHRoZSBwaW5uZWQgY29udGFpbmVyLCBob3dldmVyXG4gICAgICogd2Ugc3RpbGwgbmVlZCB0byBhY2NvdW50IGZvciBjYXNlcyB3aGVuIHRoZSBiYXNlIHBpbm5lZCBjb250YWluZXIgaGVpZ2h0IGlzXG4gICAgICogZ3JlYXRlciB0aGFuIHRoZSB1bnBpbm5lZCBpbiB3aGljaCBjYXNlIHdlIHdvdWxkIHNldCB0aGUgdW5waW5uZWRDb250YWluZXJcbiAgICAgKiBoZWlnaHQgdG8gdGhlIHBpbm5lZCBjb250YWluZXIgaGVpZ2h0LlxuICAgICAqL1xuICAgIGlmICghdGhpcy5yZWZzLnBpbm5lZENvbHVtbnMpIHJldHVybjtcblxuICAgIGNvbnN0IHsgb25IZWlnaHRVcGRhdGVkIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgdW5waW5uZWRDb250YWluZXIgPSBmaW5kRE9NTm9kZSh0aGlzLnJlZnMudW5waW5uZWRDb2x1bW5zKTtcbiAgICBjb25zdCBwaW5uZWRDb250YWluZXIgPSBmaW5kRE9NTm9kZSh0aGlzLnJlZnMucGlubmVkQ29sdW1ucyk7XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBoZWlnaHQgc3R5bGluZyBzbyB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGhlaWdodCBuZWVkZWQgdG8gZGlzcGxheVxuICAgICAgLy8gZWl0aGVyIGNvbnRhaW5lci5cbiAgICAgIHVucGlubmVkQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICAgIHBpbm5lZENvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnaGVpZ2h0Jyk7XG5cbiAgICAgIGNvbnN0IHBpbm5lZENvbnRhaW5lckhlaWdodCA9IHBpbm5lZENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICBjb25zdCB1bnBpbm5lZENvbnRhaW5lckhlaWdodCA9IHVucGlubmVkQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgY29uc3QgY2hhbmdlZE5vZGUgPSBwaW5uZWRDb250YWluZXJIZWlnaHQgPiB1bnBpbm5lZENvbnRhaW5lckhlaWdodCA/XG4gICAgICAgIHVucGlubmVkQ29udGFpbmVyIDpcbiAgICAgICAgcGlubmVkQ29udGFpbmVyO1xuICAgICAgY29uc3QgY2hhbmdlZEhlaWdodCA9IE1hdGgubWF4KHBpbm5lZENvbnRhaW5lckhlaWdodCwgdW5waW5uZWRDb250YWluZXJIZWlnaHQpO1xuXG4gICAgICBzZXRTdHlsZXNGb3JOb2RlKGNoYW5nZWROb2RlLCB7XG4gICAgICAgIGhlaWdodDogYCR7Y2hhbmdlZEhlaWdodH1weGAsXG4gICAgICB9KTtcblxuICAgICAgb25IZWlnaHRVcGRhdGVkICYmIG9uSGVpZ2h0VXBkYXRlZCh7IGNoYW5nZWROb2RlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3NldEJhc2VSb3dIZWlnaHQgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXR0aW5nIHRoZSByb3cgYmFzZUhlaWdodCBiZWNhdXNlIHdlIG5lZWQgdGhpcyB0byBtYWtlIGNvbXBhcmlzb25zIHdpdGggaW4gY2FzZXNcbiAgICAgKiB3aGVyZSB0aGUgcGlubmVkIGNvbnRhaW5lciBoZWlnaHQgaXMgbGFyZ2VyIHRoYW4gdW5waW5uZWQgYnkgZGVmYXVsdCwgd2hpY2ggd2lsbFxuICAgICAqIG9jY3VyIGZvciBhbnkgcGlubmVkIGNlbGwgd2l0aCB0ZXh0IHRoYXQgd3JhcHNcbiAgICAgKlxuICAgICAqIE5PVEU6IE9ubHkgYXBwbGllcyBpZiB3ZSBoYXZlIGEgcGlubmVkIGNvbHVtblxuICAgICAqL1xuICAgIGlmICghdGhpcy5yZWZzLnBpbm5lZENvbHVtbnMpIHJldHVybjtcbiAgICBjb25zdCBwaW5uZWRDb250YWluZXIgPSBmaW5kRE9NTm9kZSh0aGlzLnJlZnMucGlubmVkQ29sdW1ucyk7XG4gICAgY29uc3QgcGlubmVkQ29udGFpbmVySGVpZ2h0ID0gcGlubmVkQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgIHRoaXMuX2Jhc2VIZWlnaHQgPSBwaW5uZWRDb250YWluZXJIZWlnaHQ7XG4gIH1cblxuICBfaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNIb3ZlcmluZzogdHJ1ZSB9KTtcbiAgfVxuXG4gIF9oYW5kbGVNb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpc0hvdmVyaW5nOiBmYWxzZSB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsUmVuZGVyZXIsXG4gICAgICBjb2x1bW5Nb2RlbCxcbiAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlY29yZCxcbiAgICAgIHN0eWxlLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBQSU5ORURfQVRUUiA9IHsgW1BJTk5FRF9XUkFQUEVSX0FUVFJdOiB0cnVlIH07XG4gICAgY29uc3QgVU5QSU5ORURfQVRUUiA9IHsgW1VOUElOTkVEX1dSQVBQRVJfQVRUUl06IHRydWUgfTtcbiAgICBjb25zdCBib3VuZEdldENlbGwgPSAoLi4uYXJncykgPT5cbiAgICAgIGdldENlbGwoXG4gICAgICAgIGNlbGxSZW5kZXJlcixcbiAgICAgICAgcmVjb3JkLFxuICAgICAgICB7IGluZGV4LCAuLi5wcm9wcyB9LFxuICAgICAgICB0aGlzLnN0YXRlLmlzSG92ZXJpbmcsXG4gICAgICAgIC4uLmFyZ3NcbiAgICAgICk7XG5cbiAgICBjb25zdCBwaW5uZWRDZWxscyA9IGNvbHVtbk1vZGVsXG4gICAgICAuZmlsdGVyKG1vZGVsID0+IG1vZGVsLnBpbm5lZClcbiAgICAgIC5tYXAoYm91bmRHZXRDZWxsKTtcblxuICAgIGNvbnN0IHVucGlubmVkQ2VsbHMgPSBjb2x1bW5Nb2RlbFxuICAgICAgLmZpbHRlcihtb2RlbCA9PiAhbW9kZWwucGlubmVkKVxuICAgICAgLm1hcChib3VuZEdldENlbGwpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgZGF0YS1jb21wb25lbnQ9e2NvbXBvbmVudE5hbWV9XG4gICAgICAgIGRhdGEtcm93PXtpbmRleH1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuX2hhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5faGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgID5cblxuICAgICAgICB7ISFwaW5uZWRDZWxscy5sZW5ndGggJiZcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICB7Li4uUElOTkVEX0FUVFJ9XG4gICAgICAgICAgICBrZXk9XCJwaW5uZWRcIlxuICAgICAgICAgICAgcmVmPVwicGlubmVkQ29sdW1uc1wiXG4gICAgICAgICAgICBzdHlsZT17UElOTkVEX1dSQVBQRVJfU1RZTEVTfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtwaW5uZWRDZWxsc31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuXG4gICAgICAgIDxkaXZcbiAgICAgICAgICB7Li4uVU5QSU5ORURfQVRUUn1cbiAgICAgICAgICBrZXk9XCJ1bnBpbm5lZFwiXG4gICAgICAgICAgcmVmPVwidW5waW5uZWRDb2x1bW5zXCJcbiAgICAgICAgICBzdHlsZT17Q0VMTF9XUkFQUEVSfVxuICAgICAgICA+XG4gICAgICAgICAge3VucGlubmVkQ2VsbHN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5UeGxEYXRhR3JpZFJvdy5wcm9wVHlwZXMgPSB7XG4gIGNlbGxSZW5kZXJlcjogUHJvcFR5cGVzLmFueSxcbiAgY29sdW1uTW9kZWw6IFByb3BUeXBlcy5hcnJheSxcbiAgY29tcG9uZW50TmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBpbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFzdFJvdzogUHJvcFR5cGVzLmJvb2wsXG4gIG9uSGVpZ2h0VXBkYXRlZDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBpbm5lZENlbGxzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksXG4gIHJlY29yZDogUHJvcFR5cGVzLm9iamVjdCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHVucGlubmVkQ2VsbHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKSxcbn07XG4iXX0=