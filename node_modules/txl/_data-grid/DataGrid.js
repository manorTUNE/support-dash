'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class; /* eslint no-param-reassign: "off" */


var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _sortBy = require('lodash/sortBy');

var _sortBy2 = _interopRequireDefault(_sortBy);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _ReactUtils = require('../ReactUtils');

var _jsStyleHelpers = require('../styles/_helpers/jsStyleHelpers');

var _helpers = require('../styles/helpers');

var _DataGridStyles = require('./DataGridStyles');

var _attributes = require('./_attributes');

var _LoadingIndicator = require('../progress-indicators/LoadingIndicator');

var _LoadingIndicator2 = _interopRequireDefault(_LoadingIndicator);

var _DataGridHeaderRow = require('./_DataGridHeaderRow');

var _DataGridHeaderRow2 = _interopRequireDefault(_DataGridHeaderRow);

var _DataGridBodyRow = require('./_DataGridBodyRow');

var _DataGridBodyRow2 = _interopRequireDefault(_DataGridBodyRow);

var _DataGridRowSizer = require('./_DataGridRowSizer');

var _DataGridRowSizer2 = _interopRequireDefault(_DataGridRowSizer);

var _ColumnModelPropType = require('./_ColumnModelPropType');

var _ColumnModelPropType2 = _interopRequireDefault(_ColumnModelPropType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * polyfill safari and possibly other browsers
 * an error was thrown from react internals without it
 */

require('core-js/modules/es6.array.from');

var COMPONENT_SELECTOR = '[data-component="TxlDataGrid"]';
var PINNED_COLUMN_SELECTOR = '[' + _attributes.PINNED_COLUMN_ATTR + ']';
var PINNED_WRAPPER_SELECTOR = '[' + _attributes.PINNED_WRAPPER_ATTR + ']';
var UNPINNED_WRAPPER_SELECTOR = '[' + _attributes.UNPINNED_WRAPPER_ATTR + ']';

var INVALID_COLUMN_MODEL_MESSAGE = 'Invalid column model. Column models must contain at least one column and must contain only one type of columns (grouped or ungrouped)';

function getColumnSelector(key) {
  return COMPONENT_SELECTOR + ' [data-column="' + key + '"]';
}

function getColumnRule(_ref) {
  var model = _ref.model,
      index = _ref.index,
      columnWidths = _ref.columnWidths;

  var rules = { width: columnWidths[index] + 'px' };
  return (0, _jsStyleHelpers.getPrefixedCssRuleset)(getColumnSelector(model.key), rules);
}

function getNoDataInnerContent(contents) {
  return _react2.default.createElement(
    'div',
    { style: _DataGridStyles.INTERMEDIATE_CONTENT_INNER_STYLES },
    _react2.default.createElement(
      'div',
      { style: _DataGridStyles.NO_DATA_CONTENT_STYLES },
      contents
    )
  );
}

// @TODO - remove radium :hover
// @TODO - add th cell hover styles
// @TODO - update width on resize based calculated width, and set flex-grow and shrink to 0
// @TODO - possibly disabled resize until working cross browser
// @TODO - only bind mousemove handler when resizing
// @TODO - add onResizeCallback
// @TODO - testing
// @TODO  -make so scrolling while moused over pinned column scrolls container
// @TODO - capture  horizontal and vertical scroll handlers and trigger scroll of correct element,
// kind of funky in firefox @TODO - fix maxWidth - possibly by setting pined/unpinned wrappers to
// the width of the children on render/resize

/**
 * @NOTE - In this component you will find a lot of deviation from the normal react way of doing
 *   things, i.e. direct DOM style maniuplation, direct stylesheet maniuplation etc... this is not
 *   the recommmended way of doing things in most cases but were done for performance reasons that
 *   woud be hindered by a lot of rerenders, especially around scroll behavior, resizing, and
 *   pinned columns
 */

var TxlDataGrid = (0, _radium2.default)(_class = function (_React$Component) {
  (0, _inherits3.default)(TxlDataGrid, _React$Component);

  function TxlDataGrid() {
    var _ref2;

    (0, _classCallCheck3.default)(this, TxlDataGrid);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref2 = TxlDataGrid.__proto__ || (0, _getPrototypeOf2.default)(TxlDataGrid)).call.apply(_ref2, [this].concat(args)));

    _this._checkColumnModelFormat = function () {
      return _this.___checkColumnModelFormat__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._generateColumnModels = function () {
      return _this.___generateColumnModels__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleRowSizerChange = function () {
      return _this.___handleRowSizerChange__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._updateStylesAndCaches = function () {
      return _this.___updateStylesAndCaches__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._updateUnpinnedColumnOffset = function () {
      return _this.___updateUnpinnedColumnOffset__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._updateColumnWidthStyles = function () {
      return _this.___updateColumnWidthStyles__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._updateColumnRule = function () {
      return _this.___updateColumnRule__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._initDOMCache = function () {
      return _this.___initDOMCache__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._updateDimensionCache = function () {
      return _this.___updateDimensionCache__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._getHeaderDims = function () {
      return _this.___getHeaderDims__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._initScrollElem = function () {
      return _this.___initScrollElem__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleScrollUpdate = function () {
      return _this.___handleScrollUpdate__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleHeaderHeightUpdate = function () {
      return _this.___handleHeaderHeightUpdate__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleHeaderPlaceholderRef = function () {
      return _this.___handleHeaderPlaceholderRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleHeaderWrapperRef = function () {
      return _this.___handleHeaderWrapperRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleScrollerRef = function () {
      return _this.___handleScrollerRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleHeaderRef = function () {
      return _this.___handleHeaderRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleGroupHeaderRef = function () {
      return _this.___handleGroupHeaderRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._handleNoResultStateRef = function () {
      return _this.___handleNoResultStateRef__REACT_HOT_LOADER__.apply(_this, arguments);
    };

    _this._lastScrollTop = 0; // scrollTop Cache
    _this._lastScrollLeft = 0; // scrollTop Cache
    _this._fixed = _this.props.stickyHeader; // whether the header is fixed or not
    _this._wasLastFixed = null; // fixed header cache
    _this._resizing = false; // when resizing width of a column
    _this._columnWidths = []; // hold current widths of all columns
    // columns that have been resized and their actual widths should be recorded
    _this._resizedCols = {};
    _this._resizedColWidths = {}; // hold current widths of all columns that have been user resized
    _this._documentScroller = null; // document scrolling element, body or html depending on browser
    // contains the header so that can hide overflow when fixed header is translated along the x-axis
    _this._headerWrapper = null;
    _this._header = null; // header element
    _this._groupHeader = null; // group header element
    _this._headerUnpinnedWrapper = null; // header unpinned container
    _this._groupHeaderUnpinnedWrapper = null; // group header unpinned container
    // header placeholder element holds position when scroll is fixed
    _this._headerPlaceholder = null;
    _this._scroller = null; // wrapper container - scrolling container for horizontal scroll
    _this._node = null; // the current component
    _this._styleSheet = null; // the stylesheet to update properties for
    _this._scrollListener = null; // general scrollListener

    // dimensions
    _this._nodeDims = {};

    var columnModels = _this._generateColumnModels(_this.props.columnModel);
    _this.state = (0, _extends3.default)({}, columnModels, {
      hoverKey: ''
    });
    return _this;
  }

  (0, _createClass3.default)(TxlDataGrid, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this._initDOMCache();
      this._updateStylesAndCaches();

      this._scrollListener = function () {
        window.requestAnimationFrame(_this2._handleScrollUpdate);
      };

      // would be better in componentDidUpdate,
      // but for now stickyHeader is on or off initially and cannot be changed
      if (this.props.stickyHeader) {
        this._initScrollElem();
        window.addEventListener('scroll', this._scrollListener);
        this._scroller.addEventListener('scroll', this._scrollListener);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(_ref3) {
      var columnModel = _ref3.columnModel;

      if (this.props.columnModel !== columnModel) {
        this.setState(this._generateColumnModels(columnModel));
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('scroll', this._scrollListener);
      this._scroller.removeEventListener('scroll', this._scrollListener);
    }
  }, {
    key: '___checkColumnModelFormat__REACT_HOT_LOADER__',
    value: function ___checkColumnModelFormat__REACT_HOT_LOADER__() {
      return this.___checkColumnModelFormat__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___checkColumnModelFormat__REACT_HOT_LOADER__',
    value: function ___checkColumnModelFormat__REACT_HOT_LOADER__() {
      return this.___checkColumnModelFormat__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___checkColumnModelFormat__REACT_HOT_LOADER__',
    value: function ___checkColumnModelFormat__REACT_HOT_LOADER__(columnModel) {
      if ((0, _isEmpty2.default)(columnModel)) {
        throw new Error(INVALID_COLUMN_MODEL_MESSAGE);
      }

      var containsGroupedColumns = !!columnModel.find(function (model) {
        return !!model.columns;
      });

      if (containsGroupedColumns) {
        columnModel.forEach(function (model) {
          if (!model.columns) {
            throw new Error(INVALID_COLUMN_MODEL_MESSAGE);
          }
        });
      }
    }
  }, {
    key: '___generateColumnModels__REACT_HOT_LOADER__',
    value: function ___generateColumnModels__REACT_HOT_LOADER__() {
      return this.___generateColumnModels__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___generateColumnModels__REACT_HOT_LOADER__',
    value: function ___generateColumnModels__REACT_HOT_LOADER__() {
      return this.___generateColumnModels__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___generateColumnModels__REACT_HOT_LOADER__',
    value: function ___generateColumnModels__REACT_HOT_LOADER__(columnModel) {
      this._checkColumnModelFormat(columnModel);
      var isGrouped = !!columnModel[0].columns;

      if (!isGrouped) {
        return {
          columnModel: (0, _sortBy2.default)(columnModel, 'pinned'),
          groupedColumnModel: []
        };
      }

      var hasPinnedColumnGroups = !!columnModel.find(function (model) {
        return model.pinned;
      });

      if (!hasPinnedColumnGroups) {
        return {
          columnModel: columnModel.reduce(function (a, b) {
            return b.columns ? a.concat.apply(a, (0, _toConsumableArray3.default)(b.columns)) : a;
          }, []),
          groupedColumnModel: columnModel
        };
      }

      var groupedColumnModel = (0, _sortBy2.default)(columnModel, 'pinned').map(function (groupColumn) {
        // Pin sub-headers of pinned grouped header
        if (groupColumn.pinned) {
          return (0, _extends3.default)({}, groupColumn, {
            columns: groupColumn.columns.map(function (column) {
              return (0, _extends3.default)({}, column, {
                pinned: true
              });
            })
          });
        }

        return groupColumn;
      });

      var individualColumnModel = [];
      groupedColumnModel.forEach(function (model) {
        individualColumnModel.push.apply(individualColumnModel, (0, _toConsumableArray3.default)(model.columns));
      });

      return {
        columnModel: individualColumnModel,
        groupedColumnModel: groupedColumnModel
      };
    }
  }, {
    key: '___handleRowSizerChange__REACT_HOT_LOADER__',
    value: function ___handleRowSizerChange__REACT_HOT_LOADER__() {
      return this.___handleRowSizerChange__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleRowSizerChange__REACT_HOT_LOADER__',
    value: function ___handleRowSizerChange__REACT_HOT_LOADER__() {
      return this.___handleRowSizerChange__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleRowSizerChange__REACT_HOT_LOADER__',
    value: function ___handleRowSizerChange__REACT_HOT_LOADER__(columnWidths) {
      this._columnWidths = columnWidths;
      this._updateStylesAndCaches();
    }
  }, {
    key: '___updateStylesAndCaches__REACT_HOT_LOADER__',
    value: function ___updateStylesAndCaches__REACT_HOT_LOADER__() {
      return this.___updateStylesAndCaches__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateStylesAndCaches__REACT_HOT_LOADER__',
    value: function ___updateStylesAndCaches__REACT_HOT_LOADER__() {
      return this.___updateStylesAndCaches__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateStylesAndCaches__REACT_HOT_LOADER__',
    value: function ___updateStylesAndCaches__REACT_HOT_LOADER__() {
      var _this3 = this;

      /**
       * On the initial call from the sizer, stylesheet will not be ready.
       * This method will recursively call itself until it can continue.
       */

      if (!this._styleSheet) {
        window.requestAnimationFrame(this._updateStylesAndCaches);
      } else {
        this._updateColumnWidthStyles();

        /**
         * Updating column widths means that we need to wait until the next
         * animationframe to update our dimensions cache, since the width
         * update will impact the overall height of the grid.
         */

        window.requestAnimationFrame(function () {
          _this3._updateDimensionCache();
          _this3._updateUnpinnedColumnOffset();

          /**
           * When the header is fixed and a resize happens, we need to trigger
           * the scroll update callback to correctly resize the fixed header.
           */
          if (_this3.props.stickyHeader) {
            _this3._handleScrollUpdate();
          }
        });
      }
    }
  }, {
    key: '___updateUnpinnedColumnOffset__REACT_HOT_LOADER__',
    value: function ___updateUnpinnedColumnOffset__REACT_HOT_LOADER__() {
      return this.___updateUnpinnedColumnOffset__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateUnpinnedColumnOffset__REACT_HOT_LOADER__',
    value: function ___updateUnpinnedColumnOffset__REACT_HOT_LOADER__() {
      return this.___updateUnpinnedColumnOffset__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateUnpinnedColumnOffset__REACT_HOT_LOADER__',
    value: function ___updateUnpinnedColumnOffset__REACT_HOT_LOADER__() {
      this._scroller.style.paddingLeft = this._pinnedColumnWidths + 'px';
      this._noResultState.style.marginLeft = '-' + this._pinnedColumnWidths + 'px';
    }
  }, {
    key: '___updateColumnWidthStyles__REACT_HOT_LOADER__',
    value: function ___updateColumnWidthStyles__REACT_HOT_LOADER__() {
      return this.___updateColumnWidthStyles__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateColumnWidthStyles__REACT_HOT_LOADER__',
    value: function ___updateColumnWidthStyles__REACT_HOT_LOADER__() {
      return this.___updateColumnWidthStyles__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateColumnWidthStyles__REACT_HOT_LOADER__',
    value: function ___updateColumnWidthStyles__REACT_HOT_LOADER__() {
      var _this4 = this;

      var _state = this.state,
          columnModel = _state.columnModel,
          groupedColumnModel = _state.groupedColumnModel;


      columnModel.forEach(function (model, index) {
        _this4._updateColumnRule({ index: index, model: model });
      });

      groupedColumnModel.forEach(function (_ref4) {
        var subHeaders = _ref4.columns,
            key = _ref4.key;

        var firstSubHeaderIndex = columnModel.indexOf(subHeaders[0]);
        var subHeaderWidths = _this4._columnWidths.slice(firstSubHeaderIndex, firstSubHeaderIndex + subHeaders.length);
        var totalSubHeaderWidth = subHeaderWidths.reduce(function (a, b) {
          return a + b;
        }, 0);

        var columnSelector = getColumnSelector(key);
        (0, _jsStyleHelpers.deleteRulesetBySelector)(_this4._styleSheet, columnSelector);

        var widthRule = { width: totalSubHeaderWidth + 'px' };
        _this4._styleSheet.insertRule((0, _jsStyleHelpers.getPrefixedCssRuleset)(columnSelector, widthRule), 0);
      });
    }
  }, {
    key: '___updateColumnRule__REACT_HOT_LOADER__',
    value: function ___updateColumnRule__REACT_HOT_LOADER__() {
      return this.___updateColumnRule__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateColumnRule__REACT_HOT_LOADER__',
    value: function ___updateColumnRule__REACT_HOT_LOADER__() {
      return this.___updateColumnRule__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateColumnRule__REACT_HOT_LOADER__',
    value: function ___updateColumnRule__REACT_HOT_LOADER__(_ref5) {
      var model = _ref5.model,
          index = _ref5.index;

      (0, _jsStyleHelpers.deleteRulesetBySelector)(this._styleSheet, getColumnSelector(model.key));

      var columnWidths = this._columnWidths;

      this._styleSheet.insertRule(getColumnRule({ columnWidths: columnWidths, index: index, model: model }), 0);
    }
  }, {
    key: '___initDOMCache__REACT_HOT_LOADER__',
    value: function ___initDOMCache__REACT_HOT_LOADER__() {
      return this.___initDOMCache__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___initDOMCache__REACT_HOT_LOADER__',
    value: function ___initDOMCache__REACT_HOT_LOADER__() {
      return this.___initDOMCache__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___initDOMCache__REACT_HOT_LOADER__',
    value: function ___initDOMCache__REACT_HOT_LOADER__() {
      this._node = (0, _ReactUtils.findDOMNode)(this);
      this._styleSheet = (0, _ReactUtils.findDOMNode)(this.refs.stylesheet).sheet;

      if (this._groupHeader) {
        this._groupHeaderUnpinnedWrapper = this._groupHeader.querySelector(UNPINNED_WRAPPER_SELECTOR);
      }

      this._headerUnpinnedWrapper = this._header.querySelector(UNPINNED_WRAPPER_SELECTOR);
    }
  }, {
    key: '___updateDimensionCache__REACT_HOT_LOADER__',
    value: function ___updateDimensionCache__REACT_HOT_LOADER__() {
      return this.___updateDimensionCache__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateDimensionCache__REACT_HOT_LOADER__',
    value: function ___updateDimensionCache__REACT_HOT_LOADER__() {
      return this.___updateDimensionCache__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___updateDimensionCache__REACT_HOT_LOADER__',
    value: function ___updateDimensionCache__REACT_HOT_LOADER__() {
      this._nodeDims = this._node.getBoundingClientRect();
      this._pinnedColumnWidths = 0;
      this._nodeWidth = this._node.getBoundingClientRect().width;

      var pinnedColumns = this._header.querySelector(PINNED_WRAPPER_SELECTOR);
      if (pinnedColumns) {
        var nodes = pinnedColumns.querySelectorAll(PINNED_COLUMN_SELECTOR);
        this._pinnedColumnWidths = [].concat((0, _toConsumableArray3.default)(nodes)).reduce(function (prev, node) {
          return prev += node.getBoundingClientRect().width;
        }, 0);
      }
      this._wasLastFixed = null; // not really a dimension but needs to be cleared
    }
  }, {
    key: '___getHeaderDims__REACT_HOT_LOADER__',


    // This function's purpose is to determine and set the scrolling element for the main viewport
    // this can differ by browser and can either be html or body
    value: function ___getHeaderDims__REACT_HOT_LOADER__() {
      return this.___getHeaderDims__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___getHeaderDims__REACT_HOT_LOADER__',
    value: function ___getHeaderDims__REACT_HOT_LOADER__() {
      return this.___getHeaderDims__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___getHeaderDims__REACT_HOT_LOADER__',
    value: function ___getHeaderDims__REACT_HOT_LOADER__() {
      return this._headerWrapper.getBoundingClientRect();
    }
  }, {
    key: '___initScrollElem__REACT_HOT_LOADER__',
    value: function ___initScrollElem__REACT_HOT_LOADER__() {
      return this.___initScrollElem__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___initScrollElem__REACT_HOT_LOADER__',
    value: function ___initScrollElem__REACT_HOT_LOADER__() {
      return this.___initScrollElem__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___initScrollElem__REACT_HOT_LOADER__',
    value: function ___initScrollElem__REACT_HOT_LOADER__() {
      var _this5 = this;

      var HTML_SELECTOR = 'body';
      var BODY_SELECTOR = 'html';
      var POTENTIAL_SELECTORS = [BODY_SELECTOR, HTML_SELECTOR];
      var BODY = document.querySelector(BODY_SELECTOR);
      var HTML = document.querySelector(HTML_SELECTOR);
      var POTENTIAL_NODES = [BODY, HTML];

      // set minHeights to more than 100% so scrollTop can actually be set
      POTENTIAL_SELECTORS.forEach(function (selector) {
        _this5._styleSheet.insertRule((0, _jsStyleHelpers.getPrefixedCssRuleset)(selector, { minHeight: '101% !important' }), 0);
      });

      // coerce the potential Elems to have a positive scrollTop
      POTENTIAL_NODES.forEach(function (node) {
        node.scrollTop = node.scrollTop || 1;
      });

      // set the scrolling element to whichever has a positive scrollTop
      // the non-scrolling element should always be 0
      this._documentScroller = BODY.scrollTop > 0 ? BODY : HTML;

      // reset scrollTop to 0 if is 1 (assumed changed by the above code)
      this._documentScroller.scrollTop = this._documentScroller.scrollTop === 1 ? 0 : this._documentScroller.scrollTop;

      // reset minHeights
      POTENTIAL_SELECTORS.forEach(function (selector) {
        (0, _jsStyleHelpers.deleteRulesetBySelector)(_this5._styleSheet, selector);
      });
    }
  }, {
    key: '___handleScrollUpdate__REACT_HOT_LOADER__',


    /*
      Handle updating the header placeholder size once DataGridRow has updated the header heights
      to be the same between the pinned columns and unpinned columns.
    */
    value: function ___handleScrollUpdate__REACT_HOT_LOADER__() {
      return this.___handleScrollUpdate__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleScrollUpdate__REACT_HOT_LOADER__',
    value: function ___handleScrollUpdate__REACT_HOT_LOADER__() {
      return this.___handleScrollUpdate__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleScrollUpdate__REACT_HOT_LOADER__',
    value: function ___handleScrollUpdate__REACT_HOT_LOADER__() {
      var curTop = this._documentScroller.scrollTop;
      var curDocLeft = this._documentScroller.scrollLeft;
      var curLeft = this._scroller.scrollLeft;
      var stickTop = this.props.stickTop;

      var headerHeight = this._getHeaderDims().height;
      var nodeHeight = this._nodeDims.height;

      /**
       * offset is not cached but content can change around it so we need to recalculate
       * @TODO - possibly find a less expensive way to do this (mutation observers?)
       */
      var nextNode = this._node;
      var nodeOffsetTop = 0;
      while (nextNode) {
        nodeOffsetTop += nextNode.offsetTop;
        nextNode = nextNode.offsetParent;
      }

      this._fixed = curTop >= nodeOffsetTop - stickTop && curTop <= nodeOffsetTop - stickTop + nodeHeight - headerHeight;

      (0, _jsStyleHelpers.setStylesForNode)(this._headerUnpinnedWrapper, {
        transform: this._fixed ? 'translateX(' + -curLeft + 'px)' : null
      });

      if (this._groupHeaderUnpinnedWrapper) {
        (0, _jsStyleHelpers.setStylesForNode)(this._groupHeaderUnpinnedWrapper, {
          transform: this._fixed ? 'translateX(' + -curLeft + 'px)' : null
        });
      }

      // has to be done every time whether previously fixed or not
      (0, _jsStyleHelpers.setStylesForNode)(this._headerWrapper, {
        transform: this._fixed ? 'translateX(' + -curDocLeft + 'px)' : null
      });

      // fixing or unfixing for the first time
      if (this._fixed !== this._wasLastFixed) {
        (0, _jsStyleHelpers.setStylesForNode)(this._headerWrapper, {
          marginLeft: this._fixed ? '-' + this._pinnedColumnWidths + 'px' : null,
          overflow: this._fixed ? 'hidden' : null,
          paddingLeft: this._fixed ? this._pinnedColumnWidths + 'px' : null,
          position: this._fixed ? 'fixed' : null,
          top: this._fixed ? this.props.stickTop + 'px' : null,
          width: this._fixed ? this._nodeWidth + 'px' : null
        });

        (0, _jsStyleHelpers.setStylesForNode)(this._headerPlaceholder, {
          height: this._fixed ? headerHeight + 'px' : null
        });

        this._wasLastFixed = this._fixed;
      }
    }
  }, {
    key: '___handleHeaderHeightUpdate__REACT_HOT_LOADER__',
    value: function ___handleHeaderHeightUpdate__REACT_HOT_LOADER__() {
      return this.___handleHeaderHeightUpdate__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderHeightUpdate__REACT_HOT_LOADER__',
    value: function ___handleHeaderHeightUpdate__REACT_HOT_LOADER__() {
      return this.___handleHeaderHeightUpdate__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderHeightUpdate__REACT_HOT_LOADER__',
    value: function ___handleHeaderHeightUpdate__REACT_HOT_LOADER__() {
      var headerHeight = this._getHeaderDims().height;

      (0, _jsStyleHelpers.setStylesForNode)(this._headerPlaceholder, {
        height: this._fixed ? headerHeight + 'px' : null
      });
    }
  }, {
    key: '___handleHeaderPlaceholderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderPlaceholderRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderPlaceholderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderPlaceholderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderPlaceholderRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderPlaceholderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderPlaceholderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderPlaceholderRef__REACT_HOT_LOADER__(ref) {
      this._headerPlaceholder = ref;
    }
  }, {
    key: '___handleHeaderWrapperRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderWrapperRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderWrapperRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderWrapperRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderWrapperRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderWrapperRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderWrapperRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderWrapperRef__REACT_HOT_LOADER__(ref) {
      this._headerWrapper = ref;
    }
  }, {
    key: '___handleScrollerRef__REACT_HOT_LOADER__',
    value: function ___handleScrollerRef__REACT_HOT_LOADER__() {
      return this.___handleScrollerRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleScrollerRef__REACT_HOT_LOADER__',
    value: function ___handleScrollerRef__REACT_HOT_LOADER__() {
      return this.___handleScrollerRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleScrollerRef__REACT_HOT_LOADER__',
    value: function ___handleScrollerRef__REACT_HOT_LOADER__(ref) {
      this._scroller = ref;
    }
  }, {
    key: '___handleHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderRef__REACT_HOT_LOADER__() {
      return this.___handleHeaderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleHeaderRef__REACT_HOT_LOADER__(ref) {
      this._header = (0, _ReactUtils.findDOMNode)(ref);
    }
  }, {
    key: '___handleGroupHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleGroupHeaderRef__REACT_HOT_LOADER__() {
      return this.___handleGroupHeaderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleGroupHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleGroupHeaderRef__REACT_HOT_LOADER__() {
      return this.___handleGroupHeaderRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleGroupHeaderRef__REACT_HOT_LOADER__',
    value: function ___handleGroupHeaderRef__REACT_HOT_LOADER__(ref) {
      this._groupHeader = (0, _ReactUtils.findDOMNode)(ref);
    }
  }, {
    key: '___handleNoResultStateRef__REACT_HOT_LOADER__',
    value: function ___handleNoResultStateRef__REACT_HOT_LOADER__() {
      return this.___handleNoResultStateRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleNoResultStateRef__REACT_HOT_LOADER__',
    value: function ___handleNoResultStateRef__REACT_HOT_LOADER__() {
      return this.___handleNoResultStateRef__REACT_HOT_LOADER__.apply(this, arguments);
    }
  }, {
    key: '___handleNoResultStateRef__REACT_HOT_LOADER__',
    value: function ___handleNoResultStateRef__REACT_HOT_LOADER__(ref) {
      this._noResultState = ref;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          sortedKey = _props.sortedKey,
          sortedDirection = _props.sortedDirection,
          onSortRequested = _props.onSortRequested,
          noDataContent = _props.noDataContent;
      var _state2 = this.state,
          columnModel = _state2.columnModel,
          groupedColumnModel = _state2.groupedColumnModel;


      var isGrouped = groupedColumnModel.length > 0;

      var loadingContent = this.props.loadingContent || _react2.default.createElement(
        'div',
        { style: _DataGridStyles.INTERMEDIATE_CONTENT_STYLES },
        getNoDataInnerContent(_react2.default.createElement(_LoadingIndicator2.default, null))
      );

      var noDataElem = _react2.default.createElement(
        'div',
        { style: _DataGridStyles.NO_RESULTS_CONTENT_STYLES },
        getNoDataInnerContent(noDataContent)
      );

      var showNoDataContent = !this.props.isLoading && !this.props.data.length;
      var rowCount = !this.props.isLoading ? this.props.data.length : 0;

      return _react2.default.createElement(
        'div',
        {
          id: this.props.id,
          'data-component': 'TxlDataGrid',
          style: _DataGridStyles.WRAPPER_STYLES
        },
        _react2.default.createElement('style', {
          type: 'text/css',
          ref: 'stylesheet'
        }),
        _react2.default.createElement(_DataGridRowSizer2.default, {
          onRowSizeChange: this._handleRowSizerChange,
          columnModel: columnModel
        }),
        _react2.default.createElement(
          'div',
          {
            style: _DataGridStyles.SCROLLER_STYLES,
            ref: this._handleScrollerRef
          },
          _react2.default.createElement(
            'div',
            {
              style: _DataGridStyles.HEADER_WRAPPER_STYLES,
              ref: this._handleHeaderWrapperRef
            },
            isGrouped && _react2.default.createElement(_DataGridHeaderRow2.default, {
              columnModel: groupedColumnModel,
              sortedKey: sortedKey,
              ref: this._handleGroupHeaderRef
            }),
            _react2.default.createElement(_DataGridHeaderRow2.default, {
              columnModel: columnModel,
              sortedKey: sortedKey,
              sortedDirection: sortedDirection,
              onHeightUpdated: this._handleHeaderHeightUpdate,
              onSortRequested: onSortRequested,
              ref: this._handleHeaderRef
            })
          ),
          _react2.default.createElement('div', { ref: this._handleHeaderPlaceholderRef }),
          _react2.default.createElement(
            'div',
            { ref: this._handleNoResultStateRef },
            this.props.isLoading && loadingContent,
            showNoDataContent && noDataElem
          ),
          this.props.data.map(function (record, index) {
            return _react2.default.createElement(_DataGridBodyRow2.default, {
              key: index,
              index: index,
              record: record,
              columnModel: columnModel,
              lastRow: index === rowCount - 1
            });
          })
        )
      );
    }
  }]);
  return TxlDataGrid;
}(_react2.default.Component)) || _class;

exports.default = TxlDataGrid;


TxlDataGrid.propTypes = {
  columnModel: _react.PropTypes.arrayOf(_ColumnModelPropType2.default).isRequired,
  data: _react.PropTypes.array,
  id: _react.PropTypes.string,
  isLoading: _react.PropTypes.bool,
  loadingContent: _react.PropTypes.node,
  noDataContent: _react.PropTypes.node,
  onSortRequested: _DataGridHeaderRow2.default.propTypes.onSortRequested,
  sortedDirection: _DataGridHeaderRow2.default.propTypes.sortedDirection,
  sortedKey: _DataGridHeaderRow2.default.propTypes.sortedKey,
  stickTop: _react.PropTypes.number, // in px
  stickyHeader: _react.PropTypes.bool
};

TxlDataGrid.defaultProps = {
  isLoading: false,
  noDataContent: 'No Results',
  stickTop: (0, _helpers.gridUnitsRaw)(13), // same height as header
  stickyHeader: false
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(COMPONENT_SELECTOR, 'COMPONENT_SELECTOR', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(PINNED_COLUMN_SELECTOR, 'PINNED_COLUMN_SELECTOR', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(PINNED_WRAPPER_SELECTOR, 'PINNED_WRAPPER_SELECTOR', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(UNPINNED_WRAPPER_SELECTOR, 'UNPINNED_WRAPPER_SELECTOR', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(INVALID_COLUMN_MODEL_MESSAGE, 'INVALID_COLUMN_MODEL_MESSAGE', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(getColumnSelector, 'getColumnSelector', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(getColumnRule, 'getColumnRule', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(getNoDataInnerContent, 'getNoDataInnerContent', 'src/_data-grid/DataGrid.jsx');

  __REACT_HOT_LOADER__.register(TxlDataGrid, 'TxlDataGrid', 'src/_data-grid/DataGrid.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fZGF0YS1ncmlkL0RhdGFHcmlkLmpzeCJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiQ09NUE9ORU5UX1NFTEVDVE9SIiwiUElOTkVEX0NPTFVNTl9TRUxFQ1RPUiIsIlBJTk5FRF9XUkFQUEVSX1NFTEVDVE9SIiwiVU5QSU5ORURfV1JBUFBFUl9TRUxFQ1RPUiIsIklOVkFMSURfQ09MVU1OX01PREVMX01FU1NBR0UiLCJnZXRDb2x1bW5TZWxlY3RvciIsImtleSIsImdldENvbHVtblJ1bGUiLCJtb2RlbCIsImluZGV4IiwiY29sdW1uV2lkdGhzIiwicnVsZXMiLCJ3aWR0aCIsImdldE5vRGF0YUlubmVyQ29udGVudCIsImNvbnRlbnRzIiwiVHhsRGF0YUdyaWQiLCJhcmdzIiwiX2NoZWNrQ29sdW1uTW9kZWxGb3JtYXQiLCJfZ2VuZXJhdGVDb2x1bW5Nb2RlbHMiLCJfaGFuZGxlUm93U2l6ZXJDaGFuZ2UiLCJfdXBkYXRlU3R5bGVzQW5kQ2FjaGVzIiwiX3VwZGF0ZVVucGlubmVkQ29sdW1uT2Zmc2V0IiwiX3VwZGF0ZUNvbHVtbldpZHRoU3R5bGVzIiwiX3VwZGF0ZUNvbHVtblJ1bGUiLCJfaW5pdERPTUNhY2hlIiwiX3VwZGF0ZURpbWVuc2lvbkNhY2hlIiwiX2dldEhlYWRlckRpbXMiLCJfaW5pdFNjcm9sbEVsZW0iLCJfaGFuZGxlU2Nyb2xsVXBkYXRlIiwiX2hhbmRsZUhlYWRlckhlaWdodFVwZGF0ZSIsIl9oYW5kbGVIZWFkZXJQbGFjZWhvbGRlclJlZiIsIl9oYW5kbGVIZWFkZXJXcmFwcGVyUmVmIiwiX2hhbmRsZVNjcm9sbGVyUmVmIiwiX2hhbmRsZUhlYWRlclJlZiIsIl9oYW5kbGVHcm91cEhlYWRlclJlZiIsIl9oYW5kbGVOb1Jlc3VsdFN0YXRlUmVmIiwiX2xhc3RTY3JvbGxUb3AiLCJfbGFzdFNjcm9sbExlZnQiLCJfZml4ZWQiLCJwcm9wcyIsInN0aWNreUhlYWRlciIsIl93YXNMYXN0Rml4ZWQiLCJfcmVzaXppbmciLCJfY29sdW1uV2lkdGhzIiwiX3Jlc2l6ZWRDb2xzIiwiX3Jlc2l6ZWRDb2xXaWR0aHMiLCJfZG9jdW1lbnRTY3JvbGxlciIsIl9oZWFkZXJXcmFwcGVyIiwiX2hlYWRlciIsIl9ncm91cEhlYWRlciIsIl9oZWFkZXJVbnBpbm5lZFdyYXBwZXIiLCJfZ3JvdXBIZWFkZXJVbnBpbm5lZFdyYXBwZXIiLCJfaGVhZGVyUGxhY2Vob2xkZXIiLCJfc2Nyb2xsZXIiLCJfbm9kZSIsIl9zdHlsZVNoZWV0IiwiX3Njcm9sbExpc3RlbmVyIiwiX25vZGVEaW1zIiwiY29sdW1uTW9kZWxzIiwiY29sdW1uTW9kZWwiLCJzdGF0ZSIsImhvdmVyS2V5Iiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFN0YXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkVycm9yIiwiY29udGFpbnNHcm91cGVkQ29sdW1ucyIsImZpbmQiLCJjb2x1bW5zIiwiZm9yRWFjaCIsImlzR3JvdXBlZCIsImdyb3VwZWRDb2x1bW5Nb2RlbCIsImhhc1Bpbm5lZENvbHVtbkdyb3VwcyIsInBpbm5lZCIsInJlZHVjZSIsImEiLCJiIiwiY29uY2F0IiwibWFwIiwiZ3JvdXBDb2x1bW4iLCJjb2x1bW4iLCJpbmRpdmlkdWFsQ29sdW1uTW9kZWwiLCJwdXNoIiwic3R5bGUiLCJwYWRkaW5nTGVmdCIsIl9waW5uZWRDb2x1bW5XaWR0aHMiLCJfbm9SZXN1bHRTdGF0ZSIsIm1hcmdpbkxlZnQiLCJzdWJIZWFkZXJzIiwiZmlyc3RTdWJIZWFkZXJJbmRleCIsImluZGV4T2YiLCJzdWJIZWFkZXJXaWR0aHMiLCJzbGljZSIsImxlbmd0aCIsInRvdGFsU3ViSGVhZGVyV2lkdGgiLCJjb2x1bW5TZWxlY3RvciIsIndpZHRoUnVsZSIsImluc2VydFJ1bGUiLCJyZWZzIiwic3R5bGVzaGVldCIsInNoZWV0IiwicXVlcnlTZWxlY3RvciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9ub2RlV2lkdGgiLCJwaW5uZWRDb2x1bW5zIiwibm9kZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicHJldiIsIm5vZGUiLCJIVE1MX1NFTEVDVE9SIiwiQk9EWV9TRUxFQ1RPUiIsIlBPVEVOVElBTF9TRUxFQ1RPUlMiLCJCT0RZIiwiZG9jdW1lbnQiLCJIVE1MIiwiUE9URU5USUFMX05PREVTIiwic2VsZWN0b3IiLCJtaW5IZWlnaHQiLCJzY3JvbGxUb3AiLCJjdXJUb3AiLCJjdXJEb2NMZWZ0Iiwic2Nyb2xsTGVmdCIsImN1ckxlZnQiLCJzdGlja1RvcCIsImhlYWRlckhlaWdodCIsImhlaWdodCIsIm5vZGVIZWlnaHQiLCJuZXh0Tm9kZSIsIm5vZGVPZmZzZXRUb3AiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJ0cmFuc2Zvcm0iLCJvdmVyZmxvdyIsInBvc2l0aW9uIiwidG9wIiwicmVmIiwic29ydGVkS2V5Iiwic29ydGVkRGlyZWN0aW9uIiwib25Tb3J0UmVxdWVzdGVkIiwibm9EYXRhQ29udGVudCIsImxvYWRpbmdDb250ZW50Iiwibm9EYXRhRWxlbSIsInNob3dOb0RhdGFDb250ZW50IiwiaXNMb2FkaW5nIiwiZGF0YSIsInJvd0NvdW50IiwiaWQiLCJyZWNvcmQiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJhcnJheU9mIiwiaXNSZXF1aXJlZCIsImFycmF5Iiwic3RyaW5nIiwiYm9vbCIsIm51bWJlciIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFBQTs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7QUFLQTs7QUFDQTs7QUFTQTs7QUFLQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7QUFLQUEsUUFBUSxnQ0FBUjs7QUFFQSxJQUFNQyxxQkFBcUIsZ0NBQTNCO0FBQ0EsSUFBTUMsbUVBQU47QUFDQSxJQUFNQyxxRUFBTjtBQUNBLElBQU1DLHlFQUFOOztBQUVBLElB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QUdFLHNCQUFRNEksTUFIVjtBQUlFLDJCQUFhMUYsV0FKZjtBQUtFLHVCQUFTbEQsVUFBVTBJLFdBQVc7QUFMaEMsY0FEbUI7QUFBQSxXQUFwQjtBQTdCSDtBQWJGLE9BREY7QUF3REQ7OztFQTFic0MsZ0JBQU1HLFM7O2tCQUExQnZJLFc7OztBQTZickJBLFlBQVl3SSxTQUFaLEdBQXdCO0FBQ3RCNUYsZUFBYSxpQkFBVTZGLE9BQVYsZ0NBQXVDQyxVQUQ5QjtBQUV0QlAsUUFBTSxpQkFBVVEsS0FGTTtBQUd0Qk4sTUFBSSxpQkFBVU8sTUFIUTtBQUl0QlYsYUFBVyxpQkFBVVcsSUFKQztBQUt0QmQsa0JBQWdCLGlCQUFVaEMsSUFMSjtBQU10QitCLGlCQUFlLGlCQUFVL0IsSUFOSDtBQU90QjhCLG1CQUFpQiw0QkFBa0JXLFNBQWxCLENBQTRCWCxlQVB2QjtBQVF0QkQsbUJBQWlCLDRCQUFrQlksU0FBbEIsQ0FBNEJaLGVBUnZCO0FBU3RCRCxhQUFXLDRCQUFrQmEsU0FBbEIsQ0FBNEJiLFNBVGpCO0FBVXRCYixZQUFVLGlCQUFVZ0MsTUFWRSxFQVVNO0FBQzVCckgsZ0JBQWMsaUJBQVVvSDtBQVhGLENBQXhCOztBQWNBN0ksWUFBWStJLFlBQVosR0FBMkI7QUFDekJiLGFBQVcsS0FEYztBQUV6QkosaUJBQWUsWUFGVTtBQUd6QmhCLFlBQVUsMkJBQU0sRUFBTixDQUhlLEVBR0o7QUFDckJyRixnQkFBYztBQUpXLENBQTNCOzs7Ozs7OztnQ0F6Zk14QyxrQjs7Z0NBQ0FDLHNCOztnQ0FDQUMsdUI7O2dDQUNBQyx5Qjs7Z0NBRUFDLDRCOztnQ0FHR0MsaUI7O2dDQUlBRSxhOztnQ0FLQU0scUI7O2dDQTZCWUUsVyIsImZpbGUiOiJEYXRhR3JpZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuaW1wb3J0IFJlYWN0LCB7XG4gIFByb3BUeXBlcyxcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJhZGl1bSBmcm9tICdyYWRpdW0nO1xuaW1wb3J0IHNvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JztcbmltcG9ydCBpc0VtcHR5IGZyb20gJ2xvZGFzaC9pc0VtcHR5JztcblxuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICcuLi9SZWFjdFV0aWxzJztcbmltcG9ydCB7XG4gIGdldFByZWZpeGVkQ3NzUnVsZXNldCxcbiAgZGVsZXRlUnVsZXNldEJ5U2VsZWN0b3IsXG4gIHNldFN0eWxlc0Zvck5vZGUsXG59IGZyb20gJy4uL3N0eWxlcy9faGVscGVycy9qc1N0eWxlSGVscGVycyc7XG5pbXBvcnQgeyBncmlkVW5pdHNSYXcgYXMgZ3VSYXcgfSBmcm9tICcuLi9zdHlsZXMvaGVscGVycyc7XG5pbXBvcnQge1xuICBJTlRFUk1FRElBVEVfQ09OVEVOVF9TVFlMRVMsXG4gIFdSQVBQRVJfU1RZTEVTLFxuICBTQ1JPTExFUl9TVFlMRVMsXG4gIEhFQURFUl9XUkFQUEVSX1NUWUxFUyxcbiAgTk9fUkVTVUxUU19DT05URU5UX1NUWUxFUyxcbiAgSU5URVJNRURJQVRFX0NPTlRFTlRfSU5ORVJfU1RZTEVTLFxuICBOT19EQVRBX0NPTlRFTlRfU1RZTEVTLFxufSBmcm9tICcuL0RhdGFHcmlkU3R5bGVzJztcbmltcG9ydCB7XG4gIFBJTk5FRF9DT0xVTU5fQVRUUixcbiAgUElOTkVEX1dSQVBQRVJfQVRUUixcbiAgVU5QSU5ORURfV1JBUFBFUl9BVFRSLFxufSBmcm9tICcuL19hdHRyaWJ1dGVzJztcbmltcG9ydCBMb2FkaW5nSW5kaWNhdG9yIGZyb20gJy4uL3Byb2dyZXNzLWluZGljYXRvcnMvTG9hZGluZ0luZGljYXRvcic7XG5pbXBvcnQgRGF0YUdyaWRIZWFkZXJSb3cgZnJvbSAnLi9fRGF0YUdyaWRIZWFkZXJSb3cnO1xuaW1wb3J0IERhdGFHcmlkQm9keVJvdyBmcm9tICcuL19EYXRhR3JpZEJvZHlSb3cnO1xuaW1wb3J0IERhdGFHcmlkUm93U2l6ZXIgZnJvbSAnLi9fRGF0YUdyaWRSb3dTaXplcic7XG5pbXBvcnQgQ29sdW1uTW9kZWxQcm9wVHlwZSBmcm9tICcuL19Db2x1bW5Nb2RlbFByb3BUeXBlJztcblxuLyoqXG4gKiBwb2x5ZmlsbCBzYWZhcmkgYW5kIHBvc3NpYmx5IG90aGVyIGJyb3dzZXJzXG4gKiBhbiBlcnJvciB3YXMgdGhyb3duIGZyb20gcmVhY3QgaW50ZXJuYWxzIHdpdGhvdXQgaXRcbiAqL1xuXG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcblxuY29uc3QgQ09NUE9ORU5UX1NFTEVDVE9SID0gJ1tkYXRhLWNvbXBvbmVudD1cIlR4bERhdGFHcmlkXCJdJztcbmNvbnN0IFBJTk5FRF9DT0xVTU5fU0VMRUNUT1IgPSBgWyR7UElOTkVEX0NPTFVNTl9BVFRSfV1gO1xuY29uc3QgUElOTkVEX1dSQVBQRVJfU0VMRUNUT1IgPSBgWyR7UElOTkVEX1dSQVBQRVJfQVRUUn1dYDtcbmNvbnN0IFVOUElOTkVEX1dSQVBQRVJfU0VMRUNUT1IgPSBgWyR7VU5QSU5ORURfV1JBUFBFUl9BVFRSfV1gO1xuXG5jb25zdCBJTlZBTElEX0NPTFVNTl9NT0RFTF9NRVNTQUdFID1cbiAgJ0ludmFsaWQgY29sdW1uIG1vZGVsLiBDb2x1bW4gbW9kZWxzIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY29sdW1uIGFuZCBtdXN0IGNvbnRhaW4gb25seSBvbmUgdHlwZSBvZiBjb2x1bW5zIChncm91cGVkIG9yIHVuZ3JvdXBlZCknO1xuXG5mdW5jdGlvbiBnZXRDb2x1bW5TZWxlY3RvcihrZXkpIHtcbiAgcmV0dXJuIGAke0NPTVBPTkVOVF9TRUxFQ1RPUn0gW2RhdGEtY29sdW1uPVwiJHtrZXl9XCJdYDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sdW1uUnVsZSh7IG1vZGVsLCBpbmRleCwgY29sdW1uV2lkdGhzIH0pIHtcbiAgY29uc3QgcnVsZXMgPSB7IHdpZHRoOiBgJHtjb2x1bW5XaWR0aHNbaW5kZXhdfXB4YCB9O1xuICByZXR1cm4gZ2V0UHJlZml4ZWRDc3NSdWxlc2V0KGdldENvbHVtblNlbGVjdG9yKG1vZGVsLmtleSksIHJ1bGVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9EYXRhSW5uZXJDb250ZW50KGNvbnRlbnRzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17SU5URVJNRURJQVRFX0NPTlRFTlRfSU5ORVJfU1RZTEVTfT5cbiAgICAgIDxkaXYgc3R5bGU9e05PX0RBVEFfQ09OVEVOVF9TVFlMRVN9Pntjb250ZW50c308L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuLy8gQFRPRE8gLSByZW1vdmUgcmFkaXVtIDpob3ZlclxuLy8gQFRPRE8gLSBhZGQgdGggY2VsbCBob3ZlciBzdHlsZXNcbi8vIEBUT0RPIC0gdXBkYXRlIHdpZHRoIG9uIHJlc2l6ZSBiYXNlZCBjYWxjdWxhdGVkIHdpZHRoLCBhbmQgc2V0IGZsZXgtZ3JvdyBhbmQgc2hyaW5rIHRvIDBcbi8vIEBUT0RPIC0gcG9zc2libHkgZGlzYWJsZWQgcmVzaXplIHVudGlsIHdvcmtpbmcgY3Jvc3MgYnJvd3NlclxuLy8gQFRPRE8gLSBvbmx5IGJpbmQgbW91c2Vtb3ZlIGhhbmRsZXIgd2hlbiByZXNpemluZ1xuLy8gQFRPRE8gLSBhZGQgb25SZXNpemVDYWxsYmFja1xuLy8gQFRPRE8gLSB0ZXN0aW5nXG4vLyBAVE9ETyAgLW1ha2Ugc28gc2Nyb2xsaW5nIHdoaWxlIG1vdXNlZCBvdmVyIHBpbm5lZCBjb2x1bW4gc2Nyb2xscyBjb250YWluZXJcbi8vIEBUT0RPIC0gY2FwdHVyZSAgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2Nyb2xsIGhhbmRsZXJzIGFuZCB0cmlnZ2VyIHNjcm9sbCBvZiBjb3JyZWN0IGVsZW1lbnQsXG4vLyBraW5kIG9mIGZ1bmt5IGluIGZpcmVmb3ggQFRPRE8gLSBmaXggbWF4V2lkdGggLSBwb3NzaWJseSBieSBzZXR0aW5nIHBpbmVkL3VucGlubmVkIHdyYXBwZXJzIHRvXG4vLyB0aGUgd2lkdGggb2YgdGhlIGNoaWxkcmVuIG9uIHJlbmRlci9yZXNpemVcblxuLyoqXG4gKiBATk9URSAtIEluIHRoaXMgY29tcG9uZW50IHlvdSB3aWxsIGZpbmQgYSBsb3Qgb2YgZGV2aWF0aW9uIGZyb20gdGhlIG5vcm1hbCByZWFjdCB3YXkgb2YgZG9pbmdcbiAqICAgdGhpbmdzLCBpLmUuIGRpcmVjdCBET00gc3R5bGUgbWFuaXVwbGF0aW9uLCBkaXJlY3Qgc3R5bGVzaGVldCBtYW5pdXBsYXRpb24gZXRjLi4uIHRoaXMgaXMgbm90XG4gKiAgIHRoZSByZWNvbW1tZW5kZWQgd2F5IG9mIGRvaW5nIHRoaW5ncyBpbiBtb3N0IGNhc2VzIGJ1dCB3ZXJlIGRvbmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgdGhhdFxuICogICB3b3VkIGJlIGhpbmRlcmVkIGJ5IGEgbG90IG9mIHJlcmVuZGVycywgZXNwZWNpYWxseSBhcm91bmQgc2Nyb2xsIGJlaGF2aW9yLCByZXNpemluZywgYW5kXG4gKiAgIHBpbm5lZCBjb2x1bW5zXG4gKi9cblxuQFJhZGl1bVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHhsRGF0YUdyaWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5fbGFzdFNjcm9sbFRvcCA9IDA7IC8vIHNjcm9sbFRvcCBDYWNoZVxuICAgIHRoaXMuX2xhc3RTY3JvbGxMZWZ0ID0gMDsgLy8gc2Nyb2xsVG9wIENhY2hlXG4gICAgdGhpcy5fZml4ZWQgPSB0aGlzLnByb3BzLnN0aWNreUhlYWRlcjsgLy8gd2hldGhlciB0aGUgaGVhZGVyIGlzIGZpeGVkIG9yIG5vdFxuICAgIHRoaXMuX3dhc0xhc3RGaXhlZCA9IG51bGw7IC8vIGZpeGVkIGhlYWRlciBjYWNoZVxuICAgIHRoaXMuX3Jlc2l6aW5nID0gZmFsc2U7IC8vIHdoZW4gcmVzaXppbmcgd2lkdGggb2YgYSBjb2x1bW5cbiAgICB0aGlzLl9jb2x1bW5XaWR0aHMgPSBbXTsgLy8gaG9sZCBjdXJyZW50IHdpZHRocyBvZiBhbGwgY29sdW1uc1xuICAgIC8vIGNvbHVtbnMgdGhhdCBoYXZlIGJlZW4gcmVzaXplZCBhbmQgdGhlaXIgYWN0dWFsIHdpZHRocyBzaG91bGQgYmUgcmVjb3JkZWRcbiAgICB0aGlzLl9yZXNpemVkQ29scyA9IHt9O1xuICAgIHRoaXMuX3Jlc2l6ZWRDb2xXaWR0aHMgPSB7fTsgLy8gaG9sZCBjdXJyZW50IHdpZHRocyBvZiBhbGwgY29sdW1ucyB0aGF0IGhhdmUgYmVlbiB1c2VyIHJlc2l6ZWRcbiAgICB0aGlzLl9kb2N1bWVudFNjcm9sbGVyID0gbnVsbDsgLy8gZG9jdW1lbnQgc2Nyb2xsaW5nIGVsZW1lbnQsIGJvZHkgb3IgaHRtbCBkZXBlbmRpbmcgb24gYnJvd3NlclxuICAgIC8vIGNvbnRhaW5zIHRoZSBoZWFkZXIgc28gdGhhdCBjYW4gaGlkZSBvdmVyZmxvdyB3aGVuIGZpeGVkIGhlYWRlciBpcyB0cmFuc2xhdGVkIGFsb25nIHRoZSB4LWF4aXNcbiAgICB0aGlzLl9oZWFkZXJXcmFwcGVyID0gbnVsbDtcbiAgICB0aGlzLl9oZWFkZXIgPSBudWxsOyAvLyBoZWFkZXIgZWxlbWVudFxuICAgIHRoaXMuX2dyb3VwSGVhZGVyID0gbnVsbDsgLy8gZ3JvdXAgaGVhZGVyIGVsZW1lbnRcbiAgICB0aGlzLl9oZWFkZXJVbnBpbm5lZFdyYXBwZXIgPSBudWxsOyAvLyBoZWFkZXIgdW5waW5uZWQgY29udGFpbmVyXG4gICAgdGhpcy5fZ3JvdXBIZWFkZXJVbnBpbm5lZFdyYXBwZXIgPSBudWxsOyAvLyBncm91cCBoZWFkZXIgdW5waW5uZWQgY29udGFpbmVyXG4gICAgLy8gaGVhZGVyIHBsYWNlaG9sZGVyIGVsZW1lbnQgaG9sZHMgcG9zaXRpb24gd2hlbiBzY3JvbGwgaXMgZml4ZWRcbiAgICB0aGlzLl9oZWFkZXJQbGFjZWhvbGRlciA9IG51bGw7XG4gICAgdGhpcy5fc2Nyb2xsZXIgPSBudWxsOyAvLyB3cmFwcGVyIGNvbnRhaW5lciAtIHNjcm9sbGluZyBjb250YWluZXIgZm9yIGhvcml6b250YWwgc2Nyb2xsXG4gICAgdGhpcy5fbm9kZSA9IG51bGw7IC8vIHRoZSBjdXJyZW50IGNvbXBvbmVudFxuICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBudWxsOyAvLyB0aGUgc3R5bGVzaGVldCB0byB1cGRhdGUgcHJvcGVydGllcyBmb3JcbiAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IG51bGw7ICAvLyBnZW5lcmFsIHNjcm9sbExpc3RlbmVyXG5cbiAgICAvLyBkaW1lbnNpb25zXG4gICAgdGhpcy5fbm9kZURpbXMgPSB7fTtcblxuICAgIGNvbnN0IGNvbHVtbk1vZGVscyA9IHRoaXMuX2dlbmVyYXRlQ29sdW1uTW9kZWxzKHRoaXMucHJvcHMuY29sdW1uTW9kZWwpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi5jb2x1bW5Nb2RlbHMsXG4gICAgICBob3ZlcktleTogJycsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2luaXRET01DYWNoZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlc0FuZENhY2hlcygpO1xuXG4gICAgdGhpcy5fc2Nyb2xsTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2hhbmRsZVNjcm9sbFVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIHdvdWxkIGJlIGJldHRlciBpbiBjb21wb25lbnREaWRVcGRhdGUsXG4gICAgLy8gYnV0IGZvciBub3cgc3RpY2t5SGVhZGVyIGlzIG9uIG9yIG9mZiBpbml0aWFsbHkgYW5kIGNhbm5vdCBiZSBjaGFuZ2VkXG4gICAgaWYgKHRoaXMucHJvcHMuc3RpY2t5SGVhZGVyKSB7XG4gICAgICB0aGlzLl9pbml0U2Nyb2xsRWxlbSgpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbExpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3Njcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbExpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHsgY29sdW1uTW9kZWwgfSkge1xuICAgIGlmICh0aGlzLnByb3BzLmNvbHVtbk1vZGVsICE9PSBjb2x1bW5Nb2RlbCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZW5lcmF0ZUNvbHVtbk1vZGVscyhjb2x1bW5Nb2RlbCkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY3JvbGxMaXN0ZW5lcik7XG4gICAgdGhpcy5fc2Nyb2xsZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2Nyb2xsTGlzdGVuZXIpO1xuICB9XG5cbiAgX2NoZWNrQ29sdW1uTW9kZWxGb3JtYXQgPSAoY29sdW1uTW9kZWwpID0+IHtcbiAgICBpZiAoaXNFbXB0eShjb2x1bW5Nb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0NPTFVNTl9NT0RFTF9NRVNTQUdFKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluc0dyb3VwZWRDb2x1bW5zID0gISFjb2x1bW5Nb2RlbC5maW5kKG1vZGVsID0+ICEhbW9kZWwuY29sdW1ucyk7XG5cbiAgICBpZiAoY29udGFpbnNHcm91cGVkQ29sdW1ucykge1xuICAgICAgY29sdW1uTW9kZWwuZm9yRWFjaCgobW9kZWwpID0+IHtcbiAgICAgICAgaWYgKCFtb2RlbC5jb2x1bW5zKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfQ09MVU1OX01PREVMX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2VuZXJhdGVDb2x1bW5Nb2RlbHMgPSAoY29sdW1uTW9kZWwpID0+IHtcbiAgICB0aGlzLl9jaGVja0NvbHVtbk1vZGVsRm9ybWF0KGNvbHVtbk1vZGVsKTtcbiAgICBjb25zdCBpc0dyb3VwZWQgPSAhIWNvbHVtbk1vZGVsWzBdLmNvbHVtbnM7XG5cbiAgICBpZiAoIWlzR3JvdXBlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uTW9kZWw6IHNvcnRCeShjb2x1bW5Nb2RlbCwgJ3Bpbm5lZCcpLFxuICAgICAgICBncm91cGVkQ29sdW1uTW9kZWw6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNQaW5uZWRDb2x1bW5Hcm91cHMgPSAhIWNvbHVtbk1vZGVsLmZpbmQobW9kZWwgPT4gbW9kZWwucGlubmVkKTtcblxuICAgIGlmICghaGFzUGlubmVkQ29sdW1uR3JvdXBzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2x1bW5Nb2RlbDogY29sdW1uTW9kZWwucmVkdWNlKChhLCBiKSA9PiAoYi5jb2x1bW5zID8gYS5jb25jYXQoLi4uYi5jb2x1bW5zKSA6IGEpLCBbXSksXG4gICAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlbDogY29sdW1uTW9kZWwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwZWRDb2x1bW5Nb2RlbCA9IHNvcnRCeShjb2x1bW5Nb2RlbCwgJ3Bpbm5lZCcpLm1hcCgoZ3JvdXBDb2x1bW4pID0+IHtcbiAgICAgIC8vIFBpbiBzdWItaGVhZGVycyBvZiBwaW5uZWQgZ3JvdXBlZCBoZWFkZXJcbiAgICAgIGlmIChncm91cENvbHVtbi5waW5uZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5ncm91cENvbHVtbixcbiAgICAgICAgICBjb2x1bW5zOiBncm91cENvbHVtbi5jb2x1bW5zLm1hcChjb2x1bW4gPT4gKHtcbiAgICAgICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgICAgIHBpbm5lZDogdHJ1ZSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cENvbHVtbjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluZGl2aWR1YWxDb2x1bW5Nb2RlbCA9IFtdO1xuICAgIGdyb3VwZWRDb2x1bW5Nb2RlbC5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgaW5kaXZpZHVhbENvbHVtbk1vZGVsLnB1c2goLi4ubW9kZWwuY29sdW1ucyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uTW9kZWw6IGluZGl2aWR1YWxDb2x1bW5Nb2RlbCxcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlbCxcbiAgICB9O1xuICB9XG5cbiAgX2hhbmRsZVJvd1NpemVyQ2hhbmdlID0gKGNvbHVtbldpZHRocykgPT4ge1xuICAgIHRoaXMuX2NvbHVtbldpZHRocyA9IGNvbHVtbldpZHRocztcbiAgICB0aGlzLl91cGRhdGVTdHlsZXNBbmRDYWNoZXMoKTtcbiAgfVxuXG4gIF91cGRhdGVTdHlsZXNBbmRDYWNoZXMgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogT24gdGhlIGluaXRpYWwgY2FsbCBmcm9tIHRoZSBzaXplciwgc3R5bGVzaGVldCB3aWxsIG5vdCBiZSByZWFkeS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJlY3Vyc2l2ZWx5IGNhbGwgaXRzZWxmIHVudGlsIGl0IGNhbiBjb250aW51ZS5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fc3R5bGVTaGVldCkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl91cGRhdGVTdHlsZXNBbmRDYWNoZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVDb2x1bW5XaWR0aFN0eWxlcygpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0aW5nIGNvbHVtbiB3aWR0aHMgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAqIGFuaW1hdGlvbmZyYW1lIHRvIHVwZGF0ZSBvdXIgZGltZW5zaW9ucyBjYWNoZSwgc2luY2UgdGhlIHdpZHRoXG4gICAgICAgKiB1cGRhdGUgd2lsbCBpbXBhY3QgdGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoZSBncmlkLlxuICAgICAgICovXG5cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25DYWNoZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVVbnBpbm5lZENvbHVtbk9mZnNldCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBoZWFkZXIgaXMgZml4ZWQgYW5kIGEgcmVzaXplIGhhcHBlbnMsIHdlIG5lZWQgdG8gdHJpZ2dlclxuICAgICAgICAgKiB0aGUgc2Nyb2xsIHVwZGF0ZSBjYWxsYmFjayB0byBjb3JyZWN0bHkgcmVzaXplIHRoZSBmaXhlZCBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zdGlja3lIZWFkZXIpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVVucGlubmVkQ29sdW1uT2Zmc2V0ID0gKCkgPT4ge1xuICAgIHRoaXMuX3Njcm9sbGVyLnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7dGhpcy5fcGlubmVkQ29sdW1uV2lkdGhzfXB4YDtcbiAgICB0aGlzLl9ub1Jlc3VsdFN0YXRlLnN0eWxlLm1hcmdpbkxlZnQgPSBgLSR7dGhpcy5fcGlubmVkQ29sdW1uV2lkdGhzfXB4YDtcbiAgfVxuXG4gIF91cGRhdGVDb2x1bW5XaWR0aFN0eWxlcyA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb2x1bW5Nb2RlbCxcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlbCxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbHVtbk1vZGVsLmZvckVhY2goKG1vZGVsLCBpbmRleCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlQ29sdW1uUnVsZSh7IGluZGV4LCBtb2RlbCB9KTtcbiAgICB9KTtcblxuICAgIGdyb3VwZWRDb2x1bW5Nb2RlbC5mb3JFYWNoKCh7IGNvbHVtbnM6IHN1YkhlYWRlcnMsIGtleSB9KSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFN1YkhlYWRlckluZGV4ID0gY29sdW1uTW9kZWwuaW5kZXhPZihzdWJIZWFkZXJzWzBdKTtcbiAgICAgIGNvbnN0IHN1YkhlYWRlcldpZHRocyA9XG4gICAgICAgIHRoaXMuX2NvbHVtbldpZHRocy5zbGljZShmaXJzdFN1YkhlYWRlckluZGV4LCBmaXJzdFN1YkhlYWRlckluZGV4ICsgc3ViSGVhZGVycy5sZW5ndGgpO1xuICAgICAgY29uc3QgdG90YWxTdWJIZWFkZXJXaWR0aCA9IHN1YkhlYWRlcldpZHRocy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblxuICAgICAgY29uc3QgY29sdW1uU2VsZWN0b3IgPSBnZXRDb2x1bW5TZWxlY3RvcihrZXkpO1xuICAgICAgZGVsZXRlUnVsZXNldEJ5U2VsZWN0b3IodGhpcy5fc3R5bGVTaGVldCwgY29sdW1uU2VsZWN0b3IpO1xuXG4gICAgICBjb25zdCB3aWR0aFJ1bGUgPSB7IHdpZHRoOiBgJHt0b3RhbFN1YkhlYWRlcldpZHRofXB4YCB9O1xuICAgICAgdGhpcy5fc3R5bGVTaGVldC5pbnNlcnRSdWxlKGdldFByZWZpeGVkQ3NzUnVsZXNldChjb2x1bW5TZWxlY3Rvciwgd2lkdGhSdWxlKSwgMCk7XG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlQ29sdW1uUnVsZSA9ICh7IG1vZGVsLCBpbmRleCB9KSA9PiB7XG4gICAgZGVsZXRlUnVsZXNldEJ5U2VsZWN0b3IodGhpcy5fc3R5bGVTaGVldCwgZ2V0Q29sdW1uU2VsZWN0b3IobW9kZWwua2V5KSk7XG5cbiAgICBjb25zdCBjb2x1bW5XaWR0aHMgPSB0aGlzLl9jb2x1bW5XaWR0aHM7XG5cbiAgICB0aGlzLl9zdHlsZVNoZWV0Lmluc2VydFJ1bGUoZ2V0Q29sdW1uUnVsZSh7IGNvbHVtbldpZHRocywgaW5kZXgsIG1vZGVsIH0pLCAwKTtcbiAgfVxuXG4gIF9pbml0RE9NQ2FjaGUgPSAoKSA9PiB7XG4gICAgdGhpcy5fbm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBmaW5kRE9NTm9kZSh0aGlzLnJlZnMuc3R5bGVzaGVldCkuc2hlZXQ7XG5cbiAgICBpZiAodGhpcy5fZ3JvdXBIZWFkZXIpIHtcbiAgICAgIHRoaXMuX2dyb3VwSGVhZGVyVW5waW5uZWRXcmFwcGVyID0gdGhpcy5fZ3JvdXBIZWFkZXIucXVlcnlTZWxlY3RvcihVTlBJTk5FRF9XUkFQUEVSX1NFTEVDVE9SKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJVbnBpbm5lZFdyYXBwZXIgPSB0aGlzLl9oZWFkZXIucXVlcnlTZWxlY3RvcihVTlBJTk5FRF9XUkFQUEVSX1NFTEVDVE9SKTtcbiAgfVxuXG4gIF91cGRhdGVEaW1lbnNpb25DYWNoZSA9ICgpID0+IHtcbiAgICB0aGlzLl9ub2RlRGltcyA9IHRoaXMuX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5fcGlubmVkQ29sdW1uV2lkdGhzID0gMDtcbiAgICB0aGlzLl9ub2RlV2lkdGggPSB0aGlzLl9ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgY29uc3QgcGlubmVkQ29sdW1ucyA9IHRoaXMuX2hlYWRlci5xdWVyeVNlbGVjdG9yKFBJTk5FRF9XUkFQUEVSX1NFTEVDVE9SKTtcbiAgICBpZiAocGlubmVkQ29sdW1ucykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBwaW5uZWRDb2x1bW5zLnF1ZXJ5U2VsZWN0b3JBbGwoUElOTkVEX0NPTFVNTl9TRUxFQ1RPUik7XG4gICAgICB0aGlzLl9waW5uZWRDb2x1bW5XaWR0aHMgPSBbLi4ubm9kZXNdLnJlZHVjZShcbiAgICAgICAgKHByZXYsIG5vZGUpID0+IChwcmV2ICs9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpLCAwKTtcbiAgICB9XG4gICAgdGhpcy5fd2FzTGFzdEZpeGVkID0gbnVsbDsgLy8gbm90IHJlYWxseSBhIGRpbWVuc2lvbiBidXQgbmVlZHMgdG8gYmUgY2xlYXJlZFxuICB9XG5cbiAgX2dldEhlYWRlckRpbXMgPSAoKSA9PiAodGhpcy5faGVhZGVyV3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbidzIHB1cnBvc2UgaXMgdG8gZGV0ZXJtaW5lIGFuZCBzZXQgdGhlIHNjcm9sbGluZyBlbGVtZW50IGZvciB0aGUgbWFpbiB2aWV3cG9ydFxuICAvLyB0aGlzIGNhbiBkaWZmZXIgYnkgYnJvd3NlciBhbmQgY2FuIGVpdGhlciBiZSBodG1sIG9yIGJvZHlcbiAgX2luaXRTY3JvbGxFbGVtID0gKCkgPT4ge1xuICAgIGNvbnN0IEhUTUxfU0VMRUNUT1IgPSAnYm9keSc7XG4gICAgY29uc3QgQk9EWV9TRUxFQ1RPUiA9ICdodG1sJztcbiAgICBjb25zdCBQT1RFTlRJQUxfU0VMRUNUT1JTID0gW0JPRFlfU0VMRUNUT1IsIEhUTUxfU0VMRUNUT1JdO1xuICAgIGNvbnN0IEJPRFkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEJPRFlfU0VMRUNUT1IpO1xuICAgIGNvbnN0IEhUTUwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEhUTUxfU0VMRUNUT1IpO1xuICAgIGNvbnN0IFBPVEVOVElBTF9OT0RFUyA9IFtCT0RZLCBIVE1MXTtcblxuICAgIC8vIHNldCBtaW5IZWlnaHRzIHRvIG1vcmUgdGhhbiAxMDAlIHNvIHNjcm9sbFRvcCBjYW4gYWN0dWFsbHkgYmUgc2V0XG4gICAgUE9URU5USUFMX1NFTEVDVE9SUy5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgdGhpcy5fc3R5bGVTaGVldC5pbnNlcnRSdWxlKFxuICAgICAgICBnZXRQcmVmaXhlZENzc1J1bGVzZXQoc2VsZWN0b3IsIHsgbWluSGVpZ2h0OiAnMTAxJSAhaW1wb3J0YW50JyB9KSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIGNvZXJjZSB0aGUgcG90ZW50aWFsIEVsZW1zIHRvIGhhdmUgYSBwb3NpdGl2ZSBzY3JvbGxUb3BcbiAgICBQT1RFTlRJQUxfTk9ERVMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5zY3JvbGxUb3AgPSBub2RlLnNjcm9sbFRvcCB8fCAxO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBzY3JvbGxpbmcgZWxlbWVudCB0byB3aGljaGV2ZXIgaGFzIGEgcG9zaXRpdmUgc2Nyb2xsVG9wXG4gICAgLy8gdGhlIG5vbi1zY3JvbGxpbmcgZWxlbWVudCBzaG91bGQgYWx3YXlzIGJlIDBcbiAgICB0aGlzLl9kb2N1bWVudFNjcm9sbGVyID0gQk9EWS5zY3JvbGxUb3AgPiAwID8gQk9EWSA6IEhUTUw7XG5cbiAgICAvLyByZXNldCBzY3JvbGxUb3AgdG8gMCBpZiBpcyAxIChhc3N1bWVkIGNoYW5nZWQgYnkgdGhlIGFib3ZlIGNvZGUpXG4gICAgdGhpcy5fZG9jdW1lbnRTY3JvbGxlci5zY3JvbGxUb3AgPVxuICAgICAgdGhpcy5fZG9jdW1lbnRTY3JvbGxlci5zY3JvbGxUb3AgPT09IDEgPyAwIDogdGhpcy5fZG9jdW1lbnRTY3JvbGxlci5zY3JvbGxUb3A7XG5cbiAgICAvLyByZXNldCBtaW5IZWlnaHRzXG4gICAgUE9URU5USUFMX1NFTEVDVE9SUy5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgZGVsZXRlUnVsZXNldEJ5U2VsZWN0b3IodGhpcy5fc3R5bGVTaGVldCwgc2VsZWN0b3IpO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZVNjcm9sbFVwZGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjdXJUb3AgPSB0aGlzLl9kb2N1bWVudFNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICBjb25zdCBjdXJEb2NMZWZ0ID0gdGhpcy5fZG9jdW1lbnRTY3JvbGxlci5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IGN1ckxlZnQgPSB0aGlzLl9zY3JvbGxlci5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHsgc3RpY2tUb3AgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaGVhZGVySGVpZ2h0ID0gdGhpcy5fZ2V0SGVhZGVyRGltcygpLmhlaWdodDtcbiAgICBjb25zdCBub2RlSGVpZ2h0ID0gdGhpcy5fbm9kZURpbXMuaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogb2Zmc2V0IGlzIG5vdCBjYWNoZWQgYnV0IGNvbnRlbnQgY2FuIGNoYW5nZSBhcm91bmQgaXQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZVxuICAgICAqIEBUT0RPIC0gcG9zc2libHkgZmluZCBhIGxlc3MgZXhwZW5zaXZlIHdheSB0byBkbyB0aGlzIChtdXRhdGlvbiBvYnNlcnZlcnM/KVxuICAgICAqL1xuICAgIGxldCBuZXh0Tm9kZSA9IHRoaXMuX25vZGU7XG4gICAgbGV0IG5vZGVPZmZzZXRUb3AgPSAwO1xuICAgIHdoaWxlIChuZXh0Tm9kZSkge1xuICAgICAgbm9kZU9mZnNldFRvcCArPSBuZXh0Tm9kZS5vZmZzZXRUb3A7XG4gICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm9mZnNldFBhcmVudDtcbiAgICB9XG5cbiAgICB0aGlzLl9maXhlZCA9IGN1clRvcCA+PSBub2RlT2Zmc2V0VG9wIC0gc3RpY2tUb3AgJiZcbiAgICAgIGN1clRvcCA8PSBub2RlT2Zmc2V0VG9wIC0gc3RpY2tUb3AgKyBub2RlSGVpZ2h0IC0gaGVhZGVySGVpZ2h0O1xuXG4gICAgc2V0U3R5bGVzRm9yTm9kZSh0aGlzLl9oZWFkZXJVbnBpbm5lZFdyYXBwZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fZml4ZWQgPyBgdHJhbnNsYXRlWCgkey1jdXJMZWZ0fXB4KWAgOiBudWxsLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX2dyb3VwSGVhZGVyVW5waW5uZWRXcmFwcGVyKSB7XG4gICAgICBzZXRTdHlsZXNGb3JOb2RlKHRoaXMuX2dyb3VwSGVhZGVyVW5waW5uZWRXcmFwcGVyLCB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZml4ZWQgPyBgdHJhbnNsYXRlWCgkey1jdXJMZWZ0fXB4KWAgOiBudWxsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaGFzIHRvIGJlIGRvbmUgZXZlcnkgdGltZSB3aGV0aGVyIHByZXZpb3VzbHkgZml4ZWQgb3Igbm90XG4gICAgc2V0U3R5bGVzRm9yTm9kZSh0aGlzLl9oZWFkZXJXcmFwcGVyLCB7XG4gICAgICB0cmFuc2Zvcm06IHRoaXMuX2ZpeGVkID8gYHRyYW5zbGF0ZVgoJHstY3VyRG9jTGVmdH1weClgIDogbnVsbCxcbiAgICB9KTtcblxuICAgIC8vIGZpeGluZyBvciB1bmZpeGluZyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICBpZiAodGhpcy5fZml4ZWQgIT09IHRoaXMuX3dhc0xhc3RGaXhlZCkge1xuICAgICAgc2V0U3R5bGVzRm9yTm9kZSh0aGlzLl9oZWFkZXJXcmFwcGVyLCB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IHRoaXMuX2ZpeGVkID8gYC0ke3RoaXMuX3Bpbm5lZENvbHVtbldpZHRoc31weGAgOiBudWxsLFxuICAgICAgICBvdmVyZmxvdzogdGhpcy5fZml4ZWQgPyAnaGlkZGVuJyA6IG51bGwsXG4gICAgICAgIHBhZGRpbmdMZWZ0OiB0aGlzLl9maXhlZCA/IGAke3RoaXMuX3Bpbm5lZENvbHVtbldpZHRoc31weGAgOiBudWxsLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5fZml4ZWQgPyAnZml4ZWQnIDogbnVsbCxcbiAgICAgICAgdG9wOiB0aGlzLl9maXhlZCA/IGAke3RoaXMucHJvcHMuc3RpY2tUb3B9cHhgIDogbnVsbCxcbiAgICAgICAgd2lkdGg6IHRoaXMuX2ZpeGVkID8gYCR7dGhpcy5fbm9kZVdpZHRofXB4YCA6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgc2V0U3R5bGVzRm9yTm9kZSh0aGlzLl9oZWFkZXJQbGFjZWhvbGRlciwge1xuICAgICAgICBoZWlnaHQ6IHRoaXMuX2ZpeGVkID8gYCR7aGVhZGVySGVpZ2h0fXB4YCA6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fd2FzTGFzdEZpeGVkID0gdGhpcy5fZml4ZWQ7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBIYW5kbGUgdXBkYXRpbmcgdGhlIGhlYWRlciBwbGFjZWhvbGRlciBzaXplIG9uY2UgRGF0YUdyaWRSb3cgaGFzIHVwZGF0ZWQgdGhlIGhlYWRlciBoZWlnaHRzXG4gICAgdG8gYmUgdGhlIHNhbWUgYmV0d2VlbiB0aGUgcGlubmVkIGNvbHVtbnMgYW5kIHVucGlubmVkIGNvbHVtbnMuXG4gICovXG4gIF9oYW5kbGVIZWFkZXJIZWlnaHRVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaGVhZGVySGVpZ2h0ID0gdGhpcy5fZ2V0SGVhZGVyRGltcygpLmhlaWdodDtcblxuICAgIHNldFN0eWxlc0Zvck5vZGUodGhpcy5faGVhZGVyUGxhY2Vob2xkZXIsIHtcbiAgICAgIGhlaWdodDogdGhpcy5fZml4ZWQgPyBgJHtoZWFkZXJIZWlnaHR9cHhgIDogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIF9oYW5kbGVIZWFkZXJQbGFjZWhvbGRlclJlZiA9IChyZWYpID0+IHtcbiAgICB0aGlzLl9oZWFkZXJQbGFjZWhvbGRlciA9IHJlZjtcbiAgfVxuXG4gIF9oYW5kbGVIZWFkZXJXcmFwcGVyUmVmID0gKHJlZikgPT4ge1xuICAgIHRoaXMuX2hlYWRlcldyYXBwZXIgPSByZWY7XG4gIH1cblxuICBfaGFuZGxlU2Nyb2xsZXJSZWYgPSAocmVmKSA9PiB7XG4gICAgdGhpcy5fc2Nyb2xsZXIgPSByZWY7XG4gIH1cblxuICBfaGFuZGxlSGVhZGVyUmVmID0gKHJlZikgPT4ge1xuICAgIHRoaXMuX2hlYWRlciA9IGZpbmRET01Ob2RlKHJlZik7XG4gIH1cblxuICBfaGFuZGxlR3JvdXBIZWFkZXJSZWYgPSAocmVmKSA9PiB7XG4gICAgdGhpcy5fZ3JvdXBIZWFkZXIgPSBmaW5kRE9NTm9kZShyZWYpO1xuICB9XG5cbiAgX2hhbmRsZU5vUmVzdWx0U3RhdGVSZWYgPSAocmVmKSA9PiB7XG4gICAgdGhpcy5fbm9SZXN1bHRTdGF0ZSA9IHJlZjtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3J0ZWRLZXksXG4gICAgICBzb3J0ZWREaXJlY3Rpb24sXG4gICAgICBvblNvcnRSZXF1ZXN0ZWQsXG4gICAgICBub0RhdGFDb250ZW50LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qge1xuICAgICAgY29sdW1uTW9kZWwsXG4gICAgICBncm91cGVkQ29sdW1uTW9kZWwsXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBpc0dyb3VwZWQgPSBncm91cGVkQ29sdW1uTW9kZWwubGVuZ3RoID4gMDtcblxuICAgIGNvbnN0IGxvYWRpbmdDb250ZW50ID0gdGhpcy5wcm9wcy5sb2FkaW5nQ29udGVudCB8fCAoXG4gICAgICA8ZGl2IHN0eWxlPXtJTlRFUk1FRElBVEVfQ09OVEVOVF9TVFlMRVN9PlxuICAgICAgICB7Z2V0Tm9EYXRhSW5uZXJDb250ZW50KDxMb2FkaW5nSW5kaWNhdG9yIC8+KX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG5cbiAgICBjb25zdCBub0RhdGFFbGVtID0gKFxuICAgICAgPGRpdiBzdHlsZT17Tk9fUkVTVUxUU19DT05URU5UX1NUWUxFU30+XG4gICAgICAgIHtnZXROb0RhdGFJbm5lckNvbnRlbnQobm9EYXRhQ29udGVudCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgY29uc3Qgc2hvd05vRGF0YUNvbnRlbnQgPSAhdGhpcy5wcm9wcy5pc0xvYWRpbmcgJiYgIXRoaXMucHJvcHMuZGF0YS5sZW5ndGg7XG4gICAgY29uc3Qgcm93Q291bnQgPSAhdGhpcy5wcm9wcy5pc0xvYWRpbmcgPyB0aGlzLnByb3BzLmRhdGEubGVuZ3RoIDogMDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGlkPXt0aGlzLnByb3BzLmlkfVxuICAgICAgICBkYXRhLWNvbXBvbmVudD1cIlR4bERhdGFHcmlkXCJcbiAgICAgICAgc3R5bGU9e1dSQVBQRVJfU1RZTEVTfVxuICAgICAgPlxuICAgICAgICA8c3R5bGVcbiAgICAgICAgICB0eXBlPVwidGV4dC9jc3NcIlxuICAgICAgICAgIHJlZj1cInN0eWxlc2hlZXRcIlxuICAgICAgICAvPlxuICAgICAgICA8RGF0YUdyaWRSb3dTaXplclxuICAgICAgICAgIG9uUm93U2l6ZUNoYW5nZT17dGhpcy5faGFuZGxlUm93U2l6ZXJDaGFuZ2V9XG4gICAgICAgICAgY29sdW1uTW9kZWw9e2NvbHVtbk1vZGVsfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9e1NDUk9MTEVSX1NUWUxFU31cbiAgICAgICAgICByZWY9e3RoaXMuX2hhbmRsZVNjcm9sbGVyUmVmfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgc3R5bGU9e0hFQURFUl9XUkFQUEVSX1NUWUxFU31cbiAgICAgICAgICAgIHJlZj17dGhpcy5faGFuZGxlSGVhZGVyV3JhcHBlclJlZn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7aXNHcm91cGVkICYmXG4gICAgICAgICAgICAgIDxEYXRhR3JpZEhlYWRlclJvd1xuICAgICAgICAgICAgICAgIGNvbHVtbk1vZGVsPXtncm91cGVkQ29sdW1uTW9kZWx9XG4gICAgICAgICAgICAgICAgc29ydGVkS2V5PXtzb3J0ZWRLZXl9XG4gICAgICAgICAgICAgICAgcmVmPXt0aGlzLl9oYW5kbGVHcm91cEhlYWRlclJlZn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDxEYXRhR3JpZEhlYWRlclJvd1xuICAgICAgICAgICAgICBjb2x1bW5Nb2RlbD17Y29sdW1uTW9kZWx9XG4gICAgICAgICAgICAgIHNvcnRlZEtleT17c29ydGVkS2V5fVxuICAgICAgICAgICAgICBzb3J0ZWREaXJlY3Rpb249e3NvcnRlZERpcmVjdGlvbn1cbiAgICAgICAgICAgICAgb25IZWlnaHRVcGRhdGVkPXt0aGlzLl9oYW5kbGVIZWFkZXJIZWlnaHRVcGRhdGV9XG4gICAgICAgICAgICAgIG9uU29ydFJlcXVlc3RlZD17b25Tb3J0UmVxdWVzdGVkfVxuICAgICAgICAgICAgICByZWY9e3RoaXMuX2hhbmRsZUhlYWRlclJlZn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiByZWY9e3RoaXMuX2hhbmRsZUhlYWRlclBsYWNlaG9sZGVyUmVmfSAvPlxuICAgICAgICAgIDxkaXYgcmVmPXt0aGlzLl9oYW5kbGVOb1Jlc3VsdFN0YXRlUmVmfT5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmlzTG9hZGluZyAmJiBsb2FkaW5nQ29udGVudH1cbiAgICAgICAgICAgIHtzaG93Tm9EYXRhQ29udGVudCAmJiBub0RhdGFFbGVtfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt0aGlzLnByb3BzLmRhdGEubWFwKChyZWNvcmQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICA8RGF0YUdyaWRCb2R5Um93XG4gICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgcmVjb3JkPXtyZWNvcmR9XG4gICAgICAgICAgICAgIGNvbHVtbk1vZGVsPXtjb2x1bW5Nb2RlbH1cbiAgICAgICAgICAgICAgbGFzdFJvdz17aW5kZXggPT09IHJvd0NvdW50IC0gMX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApKVxuICAgICAgICAgIH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblR4bERhdGFHcmlkLnByb3BUeXBlcyA9IHtcbiAgY29sdW1uTW9kZWw6IFByb3BUeXBlcy5hcnJheU9mKENvbHVtbk1vZGVsUHJvcFR5cGUpLmlzUmVxdWlyZWQsXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGlzTG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG4gIGxvYWRpbmdDb250ZW50OiBQcm9wVHlwZXMubm9kZSxcbiAgbm9EYXRhQ29udGVudDogUHJvcFR5cGVzLm5vZGUsXG4gIG9uU29ydFJlcXVlc3RlZDogRGF0YUdyaWRIZWFkZXJSb3cucHJvcFR5cGVzLm9uU29ydFJlcXVlc3RlZCxcbiAgc29ydGVkRGlyZWN0aW9uOiBEYXRhR3JpZEhlYWRlclJvdy5wcm9wVHlwZXMuc29ydGVkRGlyZWN0aW9uLFxuICBzb3J0ZWRLZXk6IERhdGFHcmlkSGVhZGVyUm93LnByb3BUeXBlcy5zb3J0ZWRLZXksXG4gIHN0aWNrVG9wOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBpbiBweFxuICBzdGlja3lIZWFkZXI6IFByb3BUeXBlcy5ib29sLFxufTtcblxuVHhsRGF0YUdyaWQuZGVmYXVsdFByb3BzID0ge1xuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBub0RhdGFDb250ZW50OiAnTm8gUmVzdWx0cycsXG4gIHN0aWNrVG9wOiBndVJhdygxMyksIC8vIHNhbWUgaGVpZ2h0IGFzIGhlYWRlclxuICBzdGlja3lIZWFkZXI6IGZhbHNlLFxufTtcbiJdfQ==