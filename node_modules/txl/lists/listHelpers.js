'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasGroupedItems = exports.getItemLabelByValue = exports.getItemByValue = exports.getFilteredGroupItemList = exports.getFilteredFlatItemList = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A grouping of option items
 * @typedef {Object} OptionGroup
 * @property {string} label - Label of group in list
 * @property {OptionItem[]} items - Collection of options
 */

/**
 * An option item to be used in a list
 * @typedef {Object} OptionItem
 * @property {string} label - Label of item in list
 * @property {string} value - Value used if option selected
 */

/**
 * Is array a flat list of items or a group of lists of items?
 * @param  {Object[]} list Collection of options or option groups
 * @return {Boolean}
 */
function hasGroupedItems(list) {
  return !!(0, _get3.default)(list, '[0].items');
}

/**
 * Find item where item.value === value arg
 * @param  {(OptionItem[]|OptionGroup[])} [list=[]] - Collection of options or option groups
 * @param  {string} value - Value to match upon
 * @return {(Object|undefined)} - Item with matching value or `undefined`
 */
function getItemByValue() {
  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var value = arguments[1];

  if (value === undefined) return undefined;
  var items = list;
  if (hasGroupedItems(list)) {
    items = list.reduce(function (allItems, group) {
      return allItems.concat(group.items);
    }, []);
  }
  // find option with matching value prop
  return (0, _find2.default)(items, { value: value });
}

/**
 * Find label of item where item.value === value arg
 * @param  {(OptionItem[]|OptionGroup[])} [list=[]] - Collection of options or option groups
 * @param  {string} value - Value to match upon
 * @return {(string|undefined)} - Label of item where value matches or `undefined`
 */
function getItemLabelByValue() {
  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var value = arguments[1];

  return (0, _get3.default)(getItemByValue(list, value), 'label');
}

/**
 * Filter a list of options by searching their labels for a value (case insensitive)
 * @param  {OptionItem[]} list - List of options
 * @param  {string} value - The pattern to search for
 * @return {OptionItem[]} - Array of matching options
 */
function getFilteredFlatItemList(list, value) {
  var matchRegExp = new RegExp(value, 'i');
  return list.filter(function (item) {
    return matchRegExp.test(item.label);
  });
}

/**
 * Find option groups with items that contain `value`
 * @param  {Object[]} list - Option groups to search through
 * @param  {string} list[].label - Label visible to user
 * @param  {string} list[].value - Value of option used if option selected
 * @param  {string} value - The pattern to search for
 * @return {Object[]} - Collection of option groups where item.label contains value
 */
function getFilteredGroupItemList(list, value) {
  return list.reduce(function (accum, curr) {
    var group = {
      items: getFilteredFlatItemList(curr.items, value),
      label: curr.label
    };
    return group.items.length ? [].concat((0, _toConsumableArray3.default)(accum), [group]) : accum;
  }, []);
}

exports.getFilteredFlatItemList = getFilteredFlatItemList;
exports.getFilteredGroupItemList = getFilteredGroupItemList;
exports.getItemByValue = getItemByValue;
exports.getItemLabelByValue = getItemLabelByValue;
exports.hasGroupedItems = hasGroupedItems;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(hasGroupedItems, 'hasGroupedItems', 'src/lists/listHelpers.js');

  __REACT_HOT_LOADER__.register(getItemByValue, 'getItemByValue', 'src/lists/listHelpers.js');

  __REACT_HOT_LOADER__.register(getItemLabelByValue, 'getItemLabelByValue', 'src/lists/listHelpers.js');

  __REACT_HOT_LOADER__.register(getFilteredFlatItemList, 'getFilteredFlatItemList', 'src/lists/listHelpers.js');

  __REACT_HOT_LOADER__.register(getFilteredGroupItemList, 'getFilteredGroupItemList', 'src/lists/listHelpers.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saXN0cy9saXN0SGVscGVycy5qcyJdLCJuYW1lcyI6WyJoYXNHcm91cGVkSXRlbXMiLCJsaXN0IiwiZ2V0SXRlbUJ5VmFsdWUiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIml0ZW1zIiwicmVkdWNlIiwiYWxsSXRlbXMiLCJncm91cCIsImNvbmNhdCIsImdldEl0ZW1MYWJlbEJ5VmFsdWUiLCJnZXRGaWx0ZXJlZEZsYXRJdGVtTGlzdCIsIm1hdGNoUmVnRXhwIiwiUmVnRXhwIiwiZmlsdGVyIiwidGVzdCIsIml0ZW0iLCJsYWJlbCIsImdldEZpbHRlcmVkR3JvdXBJdGVtTGlzdCIsImFjY3VtIiwiY3VyciIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7OztBQU9BOzs7Ozs7O0FBT0E7Ozs7O0FBS0EsU0FBU0EsZUFBVCxDQUF5QkMsSUFBekIsRUFBK0I7QUFDN0IsU0FBTyxDQUFDLENBQUMsbUJBQUtBLElBQUwsRUFBVyxXQUFYLENBQVQ7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0MsY0FBVCxHQUEwQztBQUFBLE1BQWxCRCxJQUFrQix1RUFBWCxFQUFXO0FBQUEsTUFBUEUsS0FBTzs7QUFDeEMsTUFBSUEsVUFBVUMsU0FBZCxFQUF5QixPQUFPQSxTQUFQO0FBQ3pCLE1BQUlDLFFBQVFKLElBQVo7QUFDQSxNQUFJRCxnQkFBZ0JDLElBQWhCLENBQUosRUFBMkI7QUFDekJJLFlBQVFKLEtBQUtLLE1BQUwsQ0FBWSxVQUFDQyxRQUFELEVBQVdDLEtBQVg7QUFBQSxhQUFxQkQsU0FBU0UsTUFBVCxDQUFnQkQsTUFBTUgsS0FBdEIsQ0FBckI7QUFBQSxLQUFaLEVBQStELEVBQS9ELENBQVI7QUFDRDtBQUNEO0FBQ0EsU0FBTyxvQkFBS0EsS0FBTCxFQUFZLEVBQUVGLFlBQUYsRUFBWixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNPLG1CQUFULEdBQStDO0FBQUEsTUFBbEJULElBQWtCLHVFQUFYLEVBQVc7QUFBQSxNQUFQRSxLQUFPOztBQUM3QyxTQUFPLG1CQUFLRCxlQUFlRCxJQUFmLEVBQXFCRSxLQUFyQixDQUFMLEVBQWtDLE9BQWxDLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU1EsdUJBQVQsQ0FBaUNWLElBQWpDLEVBQXVDRSxLQUF2QyxFQUE4QztBQUM1QyxNQUFNUyxjQUFjLElBQUlDLE1BQUosQ0FBV1YsS0FBWCxFQUFrQixHQUFsQixDQUFwQjtBQUNBLFNBQU9GLEtBQUthLE1BQUwsQ0FBWTtBQUFBLFdBQVFGLFlBQVlHLElBQVosQ0FBaUJDLEtBQUtDLEtBQXRCLENBQVI7QUFBQSxHQUFaLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTQyx3QkFBVCxDQUFrQ2pCLElBQWxDLEVBQXdDRSxLQUF4QyxFQUErQztBQUM3QyxTQUFPRixLQUFLSyxNQUFMLENBQVksVUFBQ2EsS0FBRCxFQUFRQyxJQUFSLEVBQWlCO0FBQ2xDLFFBQU1aLFFBQVE7QUFDWkgsYUFBT00sd0JBQXdCUyxLQUFLZixLQUE3QixFQUFvQ0YsS0FBcEMsQ0FESztBQUVaYyxhQUFPRyxLQUFLSDtBQUZBLEtBQWQ7QUFJQSxXQUFPVCxNQUFNSCxLQUFOLENBQVlnQixNQUFaLDhDQUF5QkYsS0FBekIsSUFBZ0NYLEtBQWhDLEtBQXlDVyxLQUFoRDtBQUNELEdBTk0sRUFNSixFQU5JLENBQVA7QUFPRDs7UUFHQ1IsdUIsR0FBQUEsdUI7UUFDQU8sd0IsR0FBQUEsd0I7UUFDQWhCLGMsR0FBQUEsYztRQUNBUSxtQixHQUFBQSxtQjtRQUNBVixlLEdBQUFBLGU7Ozs7Ozs7O2dDQWhFT0EsZTs7Z0NBVUFFLGM7O2dDQWdCQVEsbUI7O2dDQVVBQyx1Qjs7Z0NBYUFPLHdCIiwiZmlsZSI6Imxpc3RIZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0IF9nZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5cbi8qKlxuICogQSBncm91cGluZyBvZiBvcHRpb24gaXRlbXNcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbkdyb3VwXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBMYWJlbCBvZiBncm91cCBpbiBsaXN0XG4gKiBAcHJvcGVydHkge09wdGlvbkl0ZW1bXX0gaXRlbXMgLSBDb2xsZWN0aW9uIG9mIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFuIG9wdGlvbiBpdGVtIHRvIGJlIHVzZWQgaW4gYSBsaXN0XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25JdGVtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBMYWJlbCBvZiBpdGVtIGluIGxpc3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHVzZWQgaWYgb3B0aW9uIHNlbGVjdGVkXG4gKi9cblxuLyoqXG4gKiBJcyBhcnJheSBhIGZsYXQgbGlzdCBvZiBpdGVtcyBvciBhIGdyb3VwIG9mIGxpc3RzIG9mIGl0ZW1zP1xuICogQHBhcmFtICB7T2JqZWN0W119IGxpc3QgQ29sbGVjdGlvbiBvZiBvcHRpb25zIG9yIG9wdGlvbiBncm91cHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0dyb3VwZWRJdGVtcyhsaXN0KSB7XG4gIHJldHVybiAhIV9nZXQobGlzdCwgJ1swXS5pdGVtcycpO1xufVxuXG4vKipcbiAqIEZpbmQgaXRlbSB3aGVyZSBpdGVtLnZhbHVlID09PSB2YWx1ZSBhcmdcbiAqIEBwYXJhbSAgeyhPcHRpb25JdGVtW118T3B0aW9uR3JvdXBbXSl9IFtsaXN0PVtdXSAtIENvbGxlY3Rpb24gb2Ygb3B0aW9ucyBvciBvcHRpb24gZ3JvdXBzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gbWF0Y2ggdXBvblxuICogQHJldHVybiB7KE9iamVjdHx1bmRlZmluZWQpfSAtIEl0ZW0gd2l0aCBtYXRjaGluZyB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICovXG5mdW5jdGlvbiBnZXRJdGVtQnlWYWx1ZShsaXN0ID0gW10sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgaXRlbXMgPSBsaXN0O1xuICBpZiAoaGFzR3JvdXBlZEl0ZW1zKGxpc3QpKSB7XG4gICAgaXRlbXMgPSBsaXN0LnJlZHVjZSgoYWxsSXRlbXMsIGdyb3VwKSA9PiBhbGxJdGVtcy5jb25jYXQoZ3JvdXAuaXRlbXMpLCBbXSk7XG4gIH1cbiAgLy8gZmluZCBvcHRpb24gd2l0aCBtYXRjaGluZyB2YWx1ZSBwcm9wXG4gIHJldHVybiBmaW5kKGl0ZW1zLCB7IHZhbHVlIH0pO1xufVxuXG4vKipcbiAqIEZpbmQgbGFiZWwgb2YgaXRlbSB3aGVyZSBpdGVtLnZhbHVlID09PSB2YWx1ZSBhcmdcbiAqIEBwYXJhbSAgeyhPcHRpb25JdGVtW118T3B0aW9uR3JvdXBbXSl9IFtsaXN0PVtdXSAtIENvbGxlY3Rpb24gb2Ygb3B0aW9ucyBvciBvcHRpb24gZ3JvdXBzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gbWF0Y2ggdXBvblxuICogQHJldHVybiB7KHN0cmluZ3x1bmRlZmluZWQpfSAtIExhYmVsIG9mIGl0ZW0gd2hlcmUgdmFsdWUgbWF0Y2hlcyBvciBgdW5kZWZpbmVkYFxuICovXG5mdW5jdGlvbiBnZXRJdGVtTGFiZWxCeVZhbHVlKGxpc3QgPSBbXSwgdmFsdWUpIHtcbiAgcmV0dXJuIF9nZXQoZ2V0SXRlbUJ5VmFsdWUobGlzdCwgdmFsdWUpLCAnbGFiZWwnKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgYSBsaXN0IG9mIG9wdGlvbnMgYnkgc2VhcmNoaW5nIHRoZWlyIGxhYmVscyBmb3IgYSB2YWx1ZSAoY2FzZSBpbnNlbnNpdGl2ZSlcbiAqIEBwYXJhbSAge09wdGlvbkl0ZW1bXX0gbGlzdCAtIExpc3Qgb2Ygb3B0aW9uc1xuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm4ge09wdGlvbkl0ZW1bXX0gLSBBcnJheSBvZiBtYXRjaGluZyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEZpbHRlcmVkRmxhdEl0ZW1MaXN0KGxpc3QsIHZhbHVlKSB7XG4gIGNvbnN0IG1hdGNoUmVnRXhwID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2knKTtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGl0ZW0gPT4gbWF0Y2hSZWdFeHAudGVzdChpdGVtLmxhYmVsKSk7XG59XG5cbi8qKlxuICogRmluZCBvcHRpb24gZ3JvdXBzIHdpdGggaXRlbXMgdGhhdCBjb250YWluIGB2YWx1ZWBcbiAqIEBwYXJhbSAge09iamVjdFtdfSBsaXN0IC0gT3B0aW9uIGdyb3VwcyB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtICB7c3RyaW5nfSBsaXN0W10ubGFiZWwgLSBMYWJlbCB2aXNpYmxlIHRvIHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gbGlzdFtdLnZhbHVlIC0gVmFsdWUgb2Ygb3B0aW9uIHVzZWQgaWYgb3B0aW9uIHNlbGVjdGVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHBhdHRlcm4gdG8gc2VhcmNoIGZvclxuICogQHJldHVybiB7T2JqZWN0W119IC0gQ29sbGVjdGlvbiBvZiBvcHRpb24gZ3JvdXBzIHdoZXJlIGl0ZW0ubGFiZWwgY29udGFpbnMgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0RmlsdGVyZWRHcm91cEl0ZW1MaXN0KGxpc3QsIHZhbHVlKSB7XG4gIHJldHVybiBsaXN0LnJlZHVjZSgoYWNjdW0sIGN1cnIpID0+IHtcbiAgICBjb25zdCBncm91cCA9IHtcbiAgICAgIGl0ZW1zOiBnZXRGaWx0ZXJlZEZsYXRJdGVtTGlzdChjdXJyLml0ZW1zLCB2YWx1ZSksXG4gICAgICBsYWJlbDogY3Vyci5sYWJlbCxcbiAgICB9O1xuICAgIHJldHVybiBncm91cC5pdGVtcy5sZW5ndGggPyBbLi4uYWNjdW0sIGdyb3VwXSA6IGFjY3VtO1xuICB9LCBbXSk7XG59XG5cbmV4cG9ydCB7XG4gIGdldEZpbHRlcmVkRmxhdEl0ZW1MaXN0LFxuICBnZXRGaWx0ZXJlZEdyb3VwSXRlbUxpc3QsXG4gIGdldEl0ZW1CeVZhbHVlLFxuICBnZXRJdGVtTGFiZWxCeVZhbHVlLFxuICBoYXNHcm91cGVkSXRlbXMsXG59O1xuIl19