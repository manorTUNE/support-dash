'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _radium = require('radium');

var _radium2 = _interopRequireDefault(_radium);

var _helpers = require('../styles/helpers');

var _TruncatedText = require('./TruncatedText.style');

var _FixedTooltipTarget = require('../_tooltips/FixedTooltipTarget');

var _FixedTooltipTarget2 = _interopRequireDefault(_FixedTooltipTarget);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRUNCATION_STYLES = {
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap',
  width: '100%'
};

var TxlTruncatedText = (0, _radium2.default)(_class = function (_React$Component) {
  (0, _inherits3.default)(TxlTruncatedText, _React$Component);

  function TxlTruncatedText() {
    var _ref;

    (0, _classCallCheck3.default)(this, TxlTruncatedText);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = TxlTruncatedText.__proto__ || (0, _getPrototypeOf2.default)(TxlTruncatedText)).call.apply(_ref, [this].concat(args)));

    _this._containerWidth = 0;
    _this._textWidth = 0;

    _this._handleMouseEnter = _this._handleMouseEnter.bind(_this);

    _this.state = {
      showTooltip: false
    };
    return _this;
  }

  (0, _createClass3.default)(TxlTruncatedText, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._setWidths();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this._setWidths();
    }
  }, {
    key: '_setWidths',
    value: function _setWidths() {
      this._containerWidth = this._container.offsetWidth;
      this._textWidth = this._measurementText.offsetWidth;
    }
  }, {
    key: '_handleMouseEnter',
    value: function _handleMouseEnter() {
      if (this._containerWidth >= this._textWidth) {
        this.setState({ showTooltip: false });
      } else {
        this.setState({ showTooltip: true });
      }
    }
  }, {
    key: '_renderMeasurementText',
    value: function _renderMeasurementText() {
      var _this2 = this;

      var measurementTextStyles = (0, _helpers.combineStyles)(_TruncatedText.ABSOLUTE_TEXT_STYLES, _TruncatedText.INVISIBLE_TEXT_STYLES);

      return _react2.default.createElement(
        'div',
        {
          ref: function ref(n) {
            _this2._measurementText = n;
          },
          style: measurementTextStyles
        },
        this.props.text
      );
    }
  }, {
    key: '_renderText',
    value: function _renderText() {
      var text = this.props.text;
      var showTooltip = this.state.showTooltip;


      if (showTooltip) {
        return _react2.default.createElement(
          _FixedTooltipTarget2.default,
          {
            style: TRUNCATION_STYLES,
            message: text
          },
          text
        );
      }

      return _react2.default.createElement(
        'div',
        { style: TRUNCATION_STYLES },
        text
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      return _react2.default.createElement(
        'div',
        {
          style: _TruncatedText.CONTAINER_STYLES,
          ref: function ref(n) {
            _this3._container = n;
          },
          onMouseEnter: this._handleMouseEnter
        },
        this._renderMeasurementText(),
        this._renderText()
      );
    }
  }]);
  return TxlTruncatedText;
}(_react2.default.Component)) || _class;

exports.default = TxlTruncatedText;


TxlTruncatedText.propTypes = {
  text: _react.PropTypes.string.isRequired
};
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(TRUNCATION_STYLES, 'TRUNCATION_STYLES', 'src/text/TruncatedText.jsx');

  __REACT_HOT_LOADER__.register(TxlTruncatedText, 'TxlTruncatedText', 'src/text/TruncatedText.jsx');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXh0L1RydW5jYXRlZFRleHQuanN4Il0sIm5hbWVzIjpbIlRSVU5DQVRJT05fU1RZTEVTIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJ3aGl0ZVNwYWNlIiwid2lkdGgiLCJUeGxUcnVuY2F0ZWRUZXh0IiwiYXJncyIsIl9jb250YWluZXJXaWR0aCIsIl90ZXh0V2lkdGgiLCJfaGFuZGxlTW91c2VFbnRlciIsImJpbmQiLCJzdGF0ZSIsInNob3dUb29sdGlwIiwiX3NldFdpZHRocyIsIl9jb250YWluZXIiLCJvZmZzZXRXaWR0aCIsIl9tZWFzdXJlbWVudFRleHQiLCJzZXRTdGF0ZSIsIm1lYXN1cmVtZW50VGV4dFN0eWxlcyIsIm4iLCJwcm9wcyIsInRleHQiLCJfcmVuZGVyTWVhc3VyZW1lbnRUZXh0IiwiX3JlbmRlclRleHQiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFHQTs7QUFLQTs7Ozs7O0FBRUEsSUFBTUEsb0JBQW9CO0FBQ3hCQyxZQUFVLFFBRGM7QUFFeEJDLGdCQUFjLFVBRlU7QUFHeEJDLGNBQVksUUFIWTtBQUl4QkMsU0FBTztBQUppQixDQUExQjs7SUFRcUJDLGdCOzs7QUFDbkIsOEJBQXFCO0FBQUE7O0FBQUE7O0FBQUEsc0NBQU5DLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLHFMQUNWQSxJQURVOztBQUduQixVQUFLQyxlQUFMLEdBQXVCLENBQXZCO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQixDQUFsQjs7QUFFQSxVQUFLQyxpQkFBTCxHQUF5QixNQUFLQSxpQkFBTCxDQUF1QkMsSUFBdkIsT0FBekI7O0FBRUEsVUFBS0MsS0FBTCxHQUFhO0FBQ1hDLG1CQUFhO0FBREYsS0FBYjtBQVJtQjtBQVdwQjs7Ozt3Q0FFbUI7QUFDbEIsV0FBS0MsVUFBTDtBQUNEOzs7eUNBRW9CO0FBQ25CLFdBQUtBLFVBQUw7QUFDRDs7O2lDQUVZO0FBQ1gsV0FBS04sZUFBTCxHQUF1QixLQUFLTyxVQUFMLENBQWdCQyxXQUF2QztBQUNBLFdBQUtQLFVBQUwsR0FBa0IsS0FBS1EsZ0JBQUwsQ0FBc0JELFdBQXhDO0FBQ0Q7Ozt3Q0FFbUI7QUFDbEIsVUFBSSxLQUFLUixlQUFMLElBQXdCLEtBQUtDLFVBQWpDLEVBQTZDO0FBQzNDLGFBQUtTLFFBQUwsQ0FBYyxFQUFFTCxhQUFhLEtBQWYsRUFBZDtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUtLLFFBQUwsQ0FBYyxFQUFFTCxhQUFhLElBQWYsRUFBZDtBQUNEO0FBQ0Y7Ozs2Q0FFd0I7QUFBQTs7QUFDdkIsVUFBTU0sd0JBQXdCLHNHQUE5Qjs7QUFLQSxhQUNFO0FBQUE7QUFBQTtBQUNFLGVBQUssYUFBQ0MsQ0FBRCxFQUFPO0FBQUUsbUJBQUtILGdCQUFMLEdBQXdCRyxDQUF4QjtBQUE0QixXQUQ1QztBQUVFLGlCQUFPRDtBQUZUO0FBSUcsYUFBS0UsS0FBTCxDQUFXQztBQUpkLE9BREY7QUFRRDs7O2tDQUVhO0FBQUEsVUFDSkEsSUFESSxHQUNLLEtBQUtELEtBRFYsQ0FDSkMsSUFESTtBQUFBLFVBRUpULFdBRkksR0FFWSxLQUFLRCxLQUZqQixDQUVKQyxXQUZJOzs7QUFJWixVQUFJQSxXQUFKLEVBQWlCO0FBQ2YsZUFDRTtBQUFBO0FBQUE7QUFDRSxtQkFBT1osaUJBRFQ7QUFFRSxxQkFBU3FCO0FBRlg7QUFJR0E7QUFKSCxTQURGO0FBUUQ7O0FBRUQsYUFDRTtBQUFBO0FBQUEsVUFBSyxPQUFPckIsaUJBQVo7QUFDR3FCO0FBREgsT0FERjtBQUtEOzs7NkJBRVE7QUFBQTs7QUFDUCxhQUNFO0FBQUE7QUFBQTtBQUNFLGdEQURGO0FBRUUsZUFBSyxhQUFDRixDQUFELEVBQU87QUFBRSxtQkFBS0wsVUFBTCxHQUFrQkssQ0FBbEI7QUFBc0IsV0FGdEM7QUFHRSx3QkFBYyxLQUFLVjtBQUhyQjtBQUtHLGFBQUthLHNCQUFMLEVBTEg7QUFNRyxhQUFLQyxXQUFMO0FBTkgsT0FERjtBQVVEOzs7RUFwRjJDLGdCQUFNQyxTOztrQkFBL0JuQixnQjs7O0FBdUZyQkEsaUJBQWlCb0IsU0FBakIsR0FBNkI7QUFDM0JKLFFBQU0saUJBQVVLLE1BQVYsQ0FBaUJDO0FBREksQ0FBN0I7Ozs7Ozs7O2dDQS9GTTNCLGlCOztnQ0FRZUssZ0IiLCJmaWxlIjoiVHJ1bmNhdGVkVGV4dC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmFkaXVtIGZyb20gJ3JhZGl1bSc7XG5cbmltcG9ydCB7XG4gIGNvbWJpbmVTdHlsZXMsXG59IGZyb20gJy4uL3N0eWxlcy9oZWxwZXJzJztcbmltcG9ydCB7XG4gIEFCU09MVVRFX1RFWFRfU1RZTEVTLFxuICBJTlZJU0lCTEVfVEVYVF9TVFlMRVMsXG4gIENPTlRBSU5FUl9TVFlMRVMsXG59IGZyb20gJy4vVHJ1bmNhdGVkVGV4dC5zdHlsZSc7XG5pbXBvcnQgRml4ZWRUb29sdGlwVGFyZ2V0IGZyb20gJy4uL190b29sdGlwcy9GaXhlZFRvb2x0aXBUYXJnZXQnO1xuXG5jb25zdCBUUlVOQ0FUSU9OX1NUWUxFUyA9IHtcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzEwMCUnLFxufTtcblxuQFJhZGl1bVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHhsVHJ1bmNhdGVkVGV4dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lcldpZHRoID0gMDtcbiAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xuXG4gICAgdGhpcy5faGFuZGxlTW91c2VFbnRlciA9IHRoaXMuX2hhbmRsZU1vdXNlRW50ZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBzaG93VG9vbHRpcDogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX3NldFdpZHRocygpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuX3NldFdpZHRocygpO1xuICB9XG5cbiAgX3NldFdpZHRocygpIHtcbiAgICB0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLl90ZXh0V2lkdGggPSB0aGlzLl9tZWFzdXJlbWVudFRleHQub2Zmc2V0V2lkdGg7XG4gIH1cblxuICBfaGFuZGxlTW91c2VFbnRlcigpIHtcbiAgICBpZiAodGhpcy5fY29udGFpbmVyV2lkdGggPj0gdGhpcy5fdGV4dFdpZHRoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd1Rvb2x0aXA6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgc2hvd1Rvb2x0aXA6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgX3JlbmRlck1lYXN1cmVtZW50VGV4dCgpIHtcbiAgICBjb25zdCBtZWFzdXJlbWVudFRleHRTdHlsZXMgPSBjb21iaW5lU3R5bGVzKFxuICAgICAgQUJTT0xVVEVfVEVYVF9TVFlMRVMsXG4gICAgICBJTlZJU0lCTEVfVEVYVF9TVFlMRVNcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXsobikgPT4geyB0aGlzLl9tZWFzdXJlbWVudFRleHQgPSBuOyB9fVxuICAgICAgICBzdHlsZT17bWVhc3VyZW1lbnRUZXh0U3R5bGVzfVxuICAgICAgPlxuICAgICAgICB7dGhpcy5wcm9wcy50ZXh0fVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIF9yZW5kZXJUZXh0KCkge1xuICAgIGNvbnN0IHsgdGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHNob3dUb29sdGlwIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHNob3dUb29sdGlwKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Rml4ZWRUb29sdGlwVGFyZ2V0XG4gICAgICAgICAgc3R5bGU9e1RSVU5DQVRJT05fU1RZTEVTfVxuICAgICAgICAgIG1lc3NhZ2U9e3RleHR9XG4gICAgICAgID5cbiAgICAgICAgICB7dGV4dH1cbiAgICAgICAgPC9GaXhlZFRvb2x0aXBUYXJnZXQ+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXtUUlVOQ0FUSU9OX1NUWUxFU30+XG4gICAgICAgIHt0ZXh0fVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT17Q09OVEFJTkVSX1NUWUxFU31cbiAgICAgICAgcmVmPXsobikgPT4geyB0aGlzLl9jb250YWluZXIgPSBuOyB9fVxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuX2hhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICA+XG4gICAgICAgIHt0aGlzLl9yZW5kZXJNZWFzdXJlbWVudFRleHQoKX1cbiAgICAgICAge3RoaXMuX3JlbmRlclRleHQoKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuVHhsVHJ1bmNhdGVkVGV4dC5wcm9wVHlwZXMgPSB7XG4gIHRleHQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbn07XG4iXX0=