'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _isUndefined = require('lodash/isUndefined');

var _isUndefined2 = _interopRequireDefault(_isUndefined);

var _isBoolean = require('lodash/isBoolean');

var _isBoolean2 = _interopRequireDefault(_isBoolean);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

var _CalendarUtils = require('../calendar-picker/_CalendarUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ANONYMOUS = 'ANONYMOUS';

function searchFunctionChecker(props, propName) {
  var componentName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ANONYMOUS;

  if (!(0, _isUndefined2.default)(props[propName])) {
    if (typeof props[propName] !== 'function') {
      return new Error(propName + ' was of type `' + (0, _typeof3.default)(props[propName]) + '` in ' + componentName + '. ' + 'Was expecting a Function.');
    }

    var returnValue = props[propName]();
    if (!(0, _isBoolean2.default)(returnValue)) {
      return new Error(propName + ' in ' + componentName + ' was a function, but returned a type ' + ('`' + (typeof returnValue === 'undefined' ? 'undefined' : (0, _typeof3.default)(returnValue)) + '`. Was expecting a boolean.'));
    }
  }
  return null;
}

/**
 * Wrapper function for custom propType validators to add ability to include .isRequired
 *
 * @param {Function} validate
 * @return {Function}
 */
var createChainableTypeChecker = function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName) {
    var componentName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ANONYMOUS;
    var location = arguments[4];
    var propFullName = arguments[5];

    if ((0, _isUndefined2.default)(props[propName])) {
      if (isRequired) {
        return new Error('Required prop `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
      }
      return null;
    }
    return validate(props, propName, componentName, location, propFullName);
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
};

/**
 * Custom PropType validation for validating a date range value, e.g., `[ startDate, endDate ]`
 */
var dateRange = createChainableTypeChecker(function (props, propName, componentName) {
  if (props[propName] !== undefined && Array.isArray(props[propName]) && !props[propName].length > 0 // empty array is default prop val, no need to validate
  && !_CalendarUtils.isValidDateRange.apply(undefined, (0, _toConsumableArray3.default)(props[propName]))) {
    return new Error(componentName + '.props.' + propName + ' is an invalid date range.');
  }
  return null;
});

/**
 * Custom PropType validation for validating shape of date range preset obj, e.g.,
 *
 * {
 *   endDate: TxlPropTypes.date,
 *   key: PropTypes.string,
 *   label: PropTypes.string,
 *   startDate: TxlPropTypes.date,
 * }
 */
var dateRangePreset = createChainableTypeChecker(function (props, propName, componentName) {
  var preset = props[propName];

  // wrap in try/catch so any errors thrown in forEach loops are returned from outer func
  try {
    // validate string types
    ['key', 'label'].forEach(function (stringProp) {
      if (preset[stringProp] !== undefined && typeof preset[stringProp] !== 'string') {
        throw new Error(componentName + '.props.' + propName + '.' + stringProp + ' should be a string.');
      }
    });

    // validate date types
    ['endDate', 'startDate'].forEach(function (dateProp) {
      if (preset[dateProp] !== undefined && !(0, _moment2.default)(preset[dateProp]).isValid()) {
        throw new Error(componentName + '.props.' + propName + '.' + dateProp + ' value (\'' + preset[dateProp] + '\')' + 'could not be coerced to moment.');
      }
    });
  } catch (err) {
    return err;
  }
  return null;
});

/**
 * PropType shape for time obj,
 * e.g., { hour: 22, minute: 9, second: 0 }
 */
var timeObj = createChainableTypeChecker(function (props, propName, componentName) {
  var timeObjVal = props[propName];

  // wrap in try/catch so any errors thrown in forEach loops are returned from outer func
  try {
    ['hour', 'minute'].forEach(function (requiredProp) {
      if (timeObjVal[requiredProp] === undefined) {
        throw new Error(componentName + '.props.' + propName + '.' + requiredProp + ' is a required prop.');
      }
    });

    var propRanges = [
    // note: range doesn't include ending, i.e., valid hour is 0..23
    { unit: 'hour', validRange: (0, _range2.default)(0, 24) }, { unit: 'minute', validRange: (0, _range2.default)(0, 60) }, { unit: 'second', validRange: (0, _range2.default)(0, 60) }];

    propRanges.forEach(function (_ref) {
      var unit = _ref.unit,
          validRange = _ref.validRange;

      var val = timeObjVal[unit];
      if (val !== undefined && !(val in validRange)) {
        throw new Error(componentName + '.props.' + propName + '.' + unit + ' must be an integer between ' + ('0 and ' + validRange[validRange.length - 1] + '.'));
      }
    });
  } catch (err) {
    return err;
  }
  return null;
});

var filterFunction = createChainableTypeChecker(searchFunctionChecker);

/**
 * Custom PropType validation for validating a moment|Date|string date prop
 */
var date = createChainableTypeChecker(function (props, propName, componentName) {
  if (props[propName] !== undefined && !(0, _moment2.default)(props[propName]).isValid()) {
    return new Error(componentName + '.props.' + propName + ' value (\'' + props[propName] + '\')' + 'could not be coerced to moment.');
  }
  return null;
});

var _default = {
  date: date,
  dateRange: dateRange,
  dateRangePreset: dateRangePreset,
  filterFunction: filterFunction,
  timeObj: timeObj
};
exports.default = _default;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(ANONYMOUS, 'ANONYMOUS', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(searchFunctionChecker, 'searchFunctionChecker', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(createChainableTypeChecker, 'createChainableTypeChecker', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(dateRange, 'dateRange', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(dateRangePreset, 'dateRangePreset', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(timeObj, 'timeObj', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(filterFunction, 'filterFunction', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(date, 'date', 'src/utils/propTypes.js');

  __REACT_HOT_LOADER__.register(_default, 'default', 'src/utils/propTypes.js');
}();

;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wcm9wVHlwZXMuanMiXSwibmFtZXMiOlsiQU5PTllNT1VTIiwic2VhcmNoRnVuY3Rpb25DaGVja2VyIiwicHJvcHMiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJFcnJvciIsInJldHVyblZhbHVlIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJsb2NhdGlvbiIsInByb3BGdWxsTmFtZSIsImNoYWluZWRDaGVja1R5cGUiLCJiaW5kIiwiZGF0ZVJhbmdlIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZGF0ZVJhbmdlUHJlc2V0IiwicHJlc2V0IiwiZm9yRWFjaCIsInN0cmluZ1Byb3AiLCJkYXRlUHJvcCIsImlzVmFsaWQiLCJlcnIiLCJ0aW1lT2JqIiwidGltZU9ialZhbCIsInJlcXVpcmVkUHJvcCIsInByb3BSYW5nZXMiLCJ1bml0IiwidmFsaWRSYW5nZSIsInZhbCIsImZpbHRlckZ1bmN0aW9uIiwiZGF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUEsSUFBTUEsWUFBWSxXQUFsQjs7QUFFQSxTQUFTQyxxQkFBVCxDQUErQkMsS0FBL0IsRUFBc0NDLFFBQXRDLEVBQTJFO0FBQUEsTUFBM0JDLGFBQTJCLHVFQUFYSixTQUFXOztBQUN6RSxNQUFJLENBQUMsMkJBQVlFLE1BQU1DLFFBQU4sQ0FBWixDQUFMLEVBQW1DO0FBQ2pDLFFBQUksT0FBT0QsTUFBTUMsUUFBTixDQUFQLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ3pDLGFBQU8sSUFBSUUsS0FBSixDQUNGRixRQUFILDRDQUFvQ0QsTUFBTUMsUUFBTixDQUFwQyxjQUE0REMsYUFBNUQsVUFDQSwyQkFGSyxDQUFQO0FBSUQ7O0FBRUQsUUFBTUUsY0FBY0osTUFBTUMsUUFBTixHQUFw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QUFQO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRCxDQWpDZSxDQUFoQjs7QUFtQ0EsSUFBTVEsaUJBQWlCM0IsMkJBQTJCTixxQkFBM0IsQ0FBdkI7O0FBRUE7OztBQUdBLElBQU1rQyxPQUFPNUIsMkJBQTJCLFVBQUNMLEtBQUQsRUFBUUMsUUFBUixFQUFrQkMsYUFBbEIsRUFBb0M7QUFDMUUsTUFBSUYsTUFBTUMsUUFBTixNQUFvQmEsU0FBcEIsSUFBaUMsQ0FBQyxzQkFBT2QsTUFBTUMsUUFBTixDQUFQLEVBQXdCc0IsT0FBeEIsRUFBdEMsRUFBeUU7QUFDdkUsV0FBTyxJQUFJcEIsS0FBSixDQUNGRCxhQUFILGVBQTBCRCxRQUExQixrQkFBOENELE1BQU1DLFFBQU4sQ0FBOUMsV0FDQSxpQ0FGSyxDQUFQO0FBSUQ7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVJZLENBQWI7O2VBVWU7QUFDYmdDLFlBRGE7QUFFYnBCLHNCQUZhO0FBR2JLLGtDQUhhO0FBSWJjLGdDQUphO0FBS2JQO0FBTGEsQzs7Ozs7Ozs7O2dDQWhLVDNCLFM7O2dDQUVHQyxxQjs7Z0NBMEJITSwwQjs7Z0NBNEJBUSxTOztnQ0FxQkFLLGU7O2dDQWlDQU8sTzs7Z0NBbUNBTyxjOztnQ0FLQUMsSSIsImZpbGUiOiJwcm9wVHlwZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnbG9kYXNoL2lzVW5kZWZpbmVkJztcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnbG9kYXNoL2lzQm9vbGVhbic7XG5pbXBvcnQgcmFuZ2UgZnJvbSAnbG9kYXNoL3JhbmdlJztcblxuaW1wb3J0IHsgaXNWYWxpZERhdGVSYW5nZSB9IGZyb20gJy4uL2NhbGVuZGFyLXBpY2tlci9fQ2FsZW5kYXJVdGlscyc7XG5cbmNvbnN0IEFOT05ZTU9VUyA9ICdBTk9OWU1PVVMnO1xuXG5mdW5jdGlvbiBzZWFyY2hGdW5jdGlvbkNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lID0gQU5PTllNT1VTKSB7XG4gIGlmICghaXNVbmRlZmluZWQocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgJHtwcm9wTmFtZX0gd2FzIG9mIHR5cGUgXFxgJHt0eXBlb2YgcHJvcHNbcHJvcE5hbWVdfVxcYCBpbiAke2NvbXBvbmVudE5hbWV9LiBgICtcbiAgICAgICAgJ1dhcyBleHBlY3RpbmcgYSBGdW5jdGlvbi4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJldHVyblZhbHVlID0gcHJvcHNbcHJvcE5hbWVdKCk7XG4gICAgaWYgKCFpc0Jvb2xlYW4ocmV0dXJuVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgJHtwcm9wTmFtZX0gaW4gJHtjb21wb25lbnROYW1lfSB3YXMgYSBmdW5jdGlvbiwgYnV0IHJldHVybmVkIGEgdHlwZSBgICtcbiAgICAgICAgYFxcYCR7dHlwZW9mIHJldHVyblZhbHVlfVxcYC4gV2FzIGV4cGVjdGluZyBhIGJvb2xlYW4uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiBmb3IgY3VzdG9tIHByb3BUeXBlIHZhbGlkYXRvcnMgdG8gYWRkIGFiaWxpdHkgdG8gaW5jbHVkZSAuaXNSZXF1aXJlZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbGlkYXRlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuY29uc3QgY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIgPSAodmFsaWRhdGUpID0+IHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKFxuICAgIGlzUmVxdWlyZWQsXG4gICAgcHJvcHMsXG4gICAgcHJvcE5hbWUsXG4gICAgY29tcG9uZW50TmFtZSA9IEFOT05ZTU9VUyxcbiAgICBsb2NhdGlvbixcbiAgICBwcm9wRnVsbE5hbWVcbiAgKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgYFJlcXVpcmVkIHByb3AgXFxgJHtwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWV9XFxgIHdhcyBub3Qgc3BlY2lmaWVkIGluIFxcYCR7Y29tcG9uZW50TmFtZX1cXGAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICB9XG5cbiAgY29uc3QgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufTtcblxuLyoqXG4gKiBDdXN0b20gUHJvcFR5cGUgdmFsaWRhdGlvbiBmb3IgdmFsaWRhdGluZyBhIGRhdGUgcmFuZ2UgdmFsdWUsIGUuZy4sIGBbIHN0YXJ0RGF0ZSwgZW5kRGF0ZSBdYFxuICovXG5jb25zdCBkYXRlUmFuZ2UgPSBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcigocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSA9PiB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICYmIEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKVxuICAgICYmICFwcm9wc1twcm9wTmFtZV0ubGVuZ3RoID4gMCAvLyBlbXB0eSBhcnJheSBpcyBkZWZhdWx0IHByb3AgdmFsLCBubyBuZWVkIHRvIHZhbGlkYXRlXG4gICAgJiYgIWlzVmFsaWREYXRlUmFuZ2UoLi4ucHJvcHNbcHJvcE5hbWVdKVxuICApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGAke2NvbXBvbmVudE5hbWV9LnByb3BzLiR7cHJvcE5hbWV9IGlzIGFuIGludmFsaWQgZGF0ZSByYW5nZS5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pO1xuXG4vKipcbiAqIEN1c3RvbSBQcm9wVHlwZSB2YWxpZGF0aW9uIGZvciB2YWxpZGF0aW5nIHNoYXBlIG9mIGRhdGUgcmFuZ2UgcHJlc2V0IG9iaiwgZS5nLixcbiAqXG4gKiB7XG4gKiAgIGVuZERhdGU6IFR4bFByb3BUeXBlcy5kYXRlLFxuICogICBrZXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gKiAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICogICBzdGFydERhdGU6IFR4bFByb3BUeXBlcy5kYXRlLFxuICogfVxuICovXG5jb25zdCBkYXRlUmFuZ2VQcmVzZXQgPSBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcigocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSA9PiB7XG4gIGNvbnN0IHByZXNldCA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAvLyB3cmFwIGluIHRyeS9jYXRjaCBzbyBhbnkgZXJyb3JzIHRocm93biBpbiBmb3JFYWNoIGxvb3BzIGFyZSByZXR1cm5lZCBmcm9tIG91dGVyIGZ1bmNcbiAgdHJ5IHtcbiAgICAvLyB2YWxpZGF0ZSBzdHJpbmcgdHlwZXNcbiAgICBbJ2tleScsICdsYWJlbCddLmZvckVhY2goKHN0cmluZ1Byb3ApID0+IHtcbiAgICAgIGlmIChwcmVzZXRbc3RyaW5nUHJvcF0gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJlc2V0W3N0cmluZ1Byb3BdICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tcG9uZW50TmFtZX0ucHJvcHMuJHtwcm9wTmFtZX0uJHtzdHJpbmdQcm9wfSBzaG91bGQgYmUgYSBzdHJpbmcuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdmFsaWRhdGUgZGF0ZSB0eXBlc1xuICAgIFsnZW5kRGF0ZScsICdzdGFydERhdGUnXS5mb3JFYWNoKChkYXRlUHJvcCkgPT4ge1xuICAgICAgaWYgKHByZXNldFtkYXRlUHJvcF0gIT09IHVuZGVmaW5lZCAmJiAhbW9tZW50KHByZXNldFtkYXRlUHJvcF0pLmlzVmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tcG9uZW50TmFtZX0ucHJvcHMuJHtwcm9wTmFtZX0uJHtkYXRlUHJvcH0gdmFsdWUgKCcke3ByZXNldFtkYXRlUHJvcF19JylgICtcbiAgICAgICAgICAnY291bGQgbm90IGJlIGNvZXJjZWQgdG8gbW9tZW50LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pO1xuXG4vKipcbiAqIFByb3BUeXBlIHNoYXBlIGZvciB0aW1lIG9iaixcbiAqIGUuZy4sIHsgaG91cjogMjIsIG1pbnV0ZTogOSwgc2Vjb25kOiAwIH1cbiAqL1xuY29uc3QgdGltZU9iaiA9IGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpID0+IHtcbiAgY29uc3QgdGltZU9ialZhbCA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAvLyB3cmFwIGluIHRyeS9jYXRjaCBzbyBhbnkgZXJyb3JzIHRocm93biBpbiBmb3JFYWNoIGxvb3BzIGFyZSByZXR1cm5lZCBmcm9tIG91dGVyIGZ1bmNcbiAgdHJ5IHtcbiAgICBbJ2hvdXInLCAnbWludXRlJ10uZm9yRWFjaCgocmVxdWlyZWRQcm9wKSA9PiB7XG4gICAgICBpZiAodGltZU9ialZhbFtyZXF1aXJlZFByb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbXBvbmVudE5hbWV9LnByb3BzLiR7cHJvcE5hbWV9LiR7cmVxdWlyZWRQcm9wfSBpcyBhIHJlcXVpcmVkIHByb3AuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvcFJhbmdlcyA9IFtcbiAgICAgIC8vIG5vdGU6IHJhbmdlIGRvZXNuJ3QgaW5jbHVkZSBlbmRpbmcsIGkuZS4sIHZhbGlkIGhvdXIgaXMgMC4uMjNcbiAgICAgIHsgdW5pdDogJ2hvdXInLCB2YWxpZFJhbmdlOiByYW5nZSgwLCAyNCkgfSxcbiAgICAgIHsgdW5pdDogJ21pbnV0ZScsIHZhbGlkUmFuZ2U6IHJhbmdlKDAsIDYwKSB9LFxuICAgICAgeyB1bml0OiAnc2Vjb25kJywgdmFsaWRSYW5nZTogcmFuZ2UoMCwgNjApIH0sXG4gICAgXTtcblxuICAgIHByb3BSYW5nZXMuZm9yRWFjaCgoeyB1bml0LCB2YWxpZFJhbmdlIH0pID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRpbWVPYmpWYWxbdW5pdF07XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgISh2YWwgaW4gdmFsaWRSYW5nZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbXBvbmVudE5hbWV9LnByb3BzLiR7cHJvcE5hbWV9LiR7dW5pdH0gbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gYCArXG4gICAgICAgICAgYDAgYW5kICR7dmFsaWRSYW5nZVt2YWxpZFJhbmdlLmxlbmd0aCAtIDFdfS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KTtcblxuY29uc3QgZmlsdGVyRnVuY3Rpb24gPSBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihzZWFyY2hGdW5jdGlvbkNoZWNrZXIpO1xuXG4vKipcbiAqIEN1c3RvbSBQcm9wVHlwZSB2YWxpZGF0aW9uIGZvciB2YWxpZGF0aW5nIGEgbW9tZW50fERhdGV8c3RyaW5nIGRhdGUgcHJvcFxuICovXG5jb25zdCBkYXRlID0gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkgPT4ge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSB1bmRlZmluZWQgJiYgIW1vbWVudChwcm9wc1twcm9wTmFtZV0pLmlzVmFsaWQoKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICBgJHtjb21wb25lbnROYW1lfS5wcm9wcy4ke3Byb3BOYW1lfSB2YWx1ZSAoJyR7cHJvcHNbcHJvcE5hbWVdfScpYCArXG4gICAgICAnY291bGQgbm90IGJlIGNvZXJjZWQgdG8gbW9tZW50LidcbiAgICApO1xuICB9XG4gIHJldHVybiBudWxsO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0ZSxcbiAgZGF0ZVJhbmdlLFxuICBkYXRlUmFuZ2VQcmVzZXQsXG4gIGZpbHRlckZ1bmN0aW9uLFxuICB0aW1lT2JqLFxufTtcbiJdfQ==